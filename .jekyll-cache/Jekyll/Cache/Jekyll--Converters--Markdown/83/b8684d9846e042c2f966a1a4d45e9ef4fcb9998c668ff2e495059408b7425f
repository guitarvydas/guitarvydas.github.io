I"{<p>Step back and try to define “expressiveness”.</p>

<p>What does that term mean?</p>

<p>Currently, I think that people use the term “expressiveness” to mean Implementation-ability.</p>

<p>Imagine a measuring-stick (aka ruler). It has two tick-marks on it. One is marked “airy fairy” and the other “implementation”.</p>

<p>I am trying to point out that there is a third tick-mark in between those two. This one is marked “DI” (Design Intent).</p>

<p>And then, there’s a fourth tick-mark, between “DI” and “Implementation”. It’s marked “Engineering”<sup id="fnref:eng" role="doc-noteref"><a href="#fn:eng" class="footnote">1</a></sup>.  And then, there are more tick-marks, ad infinitum. Everything is a fractal, we can sub-divide any problem (including sub-divisions).</p>

<p>I’m trying to point out that “expressiveness” is a relative term. It is relative to what you want to accomplish.</p>

<p>Currently, Implementation is considered first-class and everything else is considered to be second-class (or lower).</p>

<p>I am trying to point out that Architecture and Engineering (and Testing, and …) should be considered to be first-class things.</p>

<p>If you accept that “expressiveness” is a relative term, then the idea of <em>one-language-to-rule-them-all</em> evaporates.</p>

<p>You need at least one language for Implementation.</p>

<p>You need at least one language<sup id="fnref:lang" role="doc-noteref"><a href="#fn:lang" class="footnote">2</a></sup> for Architecture.</p>

<p>You need at least one language for Engineering.</p>

<p>And so on.</p>

<p>Today, we have many languages for Implementation, and zero languages for just about everything else.</p>

<p>Anecdote: My first full-time job was at Mitel Corp. where I was a “Software Test Engineer”. My job was to augment the testing of Mitel’s products before they went into the field. Part of my job was to examine designs and to make them more testable. I had the power to request design changes that would improve testability.  Designers would design and I would change the designs.  My goals were very different from their goals.  No one tried to abstract our goals and to union them into some kind of LCD (lowest common denominator).</p>

<p>If you believe, deep down, that <em>notation</em> is cheap, then you can build (and throw away) notations on a whim. I build nontations to help me build notations.</p>

<h1 id="see-also">See Also</h1>

<p><a href="https://guitarvydas.github.io/2021/01/14/References.html">References</a><br />
<a href="https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html">Table of Contents</a></p>

<script src="https://utteranc.es/client.js" repo="guitarvydas/guitarvydas.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async=""> 
</script>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:eng" role="doc-endnote">
      <p>Engineering is not Coding. Implementation is Coding. <a href="#fnref:eng" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:lang" role="doc-endnote">
      <p>Note that I use the words “language” and “notation” interchangeably. Most people think that languages are big, heavy things.  They, also, think that DSLs are big and heavy. I know that it is possible to cheat and build a <em>notation</em> in an afternoon. Language - to me - doesn’t necessarily mean something big and heavy. I’m trying to introduce the term <em>notation</em> to mean a light-weight DSL that takes no more than a few hours to build (maybe as little as a few minutes). I am forced to use the word “language” until the reader(s) knows what I mean when I say <em>notation</em>.  When you believe that syntax is cheap, then your workflow undergoes a fundamental change.  Syntax is cheap. <a href="#fnref:lang" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET