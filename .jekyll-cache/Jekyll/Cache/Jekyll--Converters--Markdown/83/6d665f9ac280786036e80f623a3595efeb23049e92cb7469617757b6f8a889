I"˜<p>I find this hard to say‚Ä¶</p>

<p>I‚Äôm an audiophile, I think that vinyl is better than CDs.</p>

<p>I think that B&amp;W photography is better than Color photograpy.</p>

<p>But, I do believe that everything is a fractal.</p>

<p>Taken to the extreme, this means that everything is digital.</p>

<p>Digital-ness is only a function of sampling frequency - our limitation on what we can enumerate.</p>

<p>Imagine a measuring stick (a ruler).  We can sub-divide each division into two more divisions. If we assign ‚Äú1‚Äù to one tick mark and ‚Äú2‚Äù to another tick mark, what do we call the tick-mark between ‚Äú1‚Äù and ‚Äú2? What about the tick marks between ‚Äú1‚Äù and that one?  How far down does this go?</p>

<p>Likewise, in software, we can sub-divide problems until what we have is ‚Äúgood enough‚Äù to solve the problem-at-hand.</p>

<p>What is Compile Time?</p>

<p>Lately, we have realized that Compile Time can be subsidivided into Type Checking and Implemenation. At the moment, that is ‚Äúgood enough‚Äù.</p>

<p>In the end, everything is interpreted.  A CPU is just a bunch of electronic circuits that interprets the opcodes (sequentially) that we stick in memory.</p>

<p>Compile Time is really just an optimization - the effort to interpret fewer opcodes less often.</p>

<p>Type checking is just software.</p>

<p>Type checking is an interpreter.</p>

<p>We‚Äôre getting better at type-checking.</p>

<p>We‚Äôre sub-dividing the problem we call ‚ÄúCompile Time‚Äù.</p>

<p>When are we going to stop?</p>

<p>Probably never.</p>

<p>It is folly to think that there is but one language to rule them all.</p>

<p>It is wrong to think that something is absolute<sup id="fnref:c" role="doc-noteref"><a href="#fn:c" class="footnote">1</a></sup>.</p>

<p>We should reflect this non-absoluteness in our software and programming languages.</p>

<p>It is folly to denote variables as we denote them today.</p>

<p>Variables should be hierarchical.</p>

<p>Software should be hierarchical.</p>

<p>Calling functions by-name<sup id="fnref:abs" role="doc-noteref"><a href="#fn:abs" class="footnote">2</a></sup> should not be allowed.</p>

<h1 id="see-also">See Also</h1>

<p><a href="https://guitarvydas.github.io/2021/01/14/References.html">References</a><br />
<a href="https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html">Table of Contents</a></p>

<script src="https://utteranc.es/client.js" repo="guitarvydas/guitarvydas.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async=""> 
</script>

<p>everything is a fractal -&gt; everything is digital<br />
it is just a question of sampling rate</p>

<p>quatum physics</p>

<p>speed of light</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:c" role="doc-endnote">
      <p>I quit Core Physics soon after some hippy tried to tell me about tachyons, i.e. that there are things that exceed the speed of light.¬†<a href="#fnref:c" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:abs" role="doc-endnote">
      <p>Absolute name.  Currently we think of functions as points in a global namespace. Function names, variable names, type names, etc. should be <em>relative</em> not <em>absolute</em>.  Namespaces should be hierarchical. We should refer to objects like we refer to UNIX directories - hierarchically.  I think that Java started to creep this notion in, but it didn‚Äôt go all the way.  Relative names should be the rule in our programming languages.  Local variables and parameters are relative (relative to the containing function). Inheritance doesn‚Äôt work well because it allows relative boundaries to be crossed (I favor composition, not inheritance).¬†<a href="#fnref:abs" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET