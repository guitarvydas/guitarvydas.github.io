I"§<p>Brainstorming is usually associated with creative arts.</p>

<p>Can the ideas of brainstorming be applied to programming?</p>

<p>What does that even mean?</p>

<p>Isn‚Äôt programming <em>Engineering</em>?</p>

<p>Isn‚Äôt that the antithesis of art?</p>

<p>Program Design (aka Software Architecture) <em>is</em> an act of creation.</p>

<p>Software Engineering is the activity that comes <em>after</em> Design.  Dot the I‚Äôs and cross the T‚Äôs, make sure that all relevant details are understood.</p>

<h1 id="engineering-is-not-coding">Engineering Is Not Coding</h1>

<p>Note that Software Engineering is <em>not</em> coding<sup id="fnref:eng" role="doc-noteref"><a href="#fn:eng" class="footnote">1</a></sup>.</p>

<p>See the discussion, below.</p>

<h1 id="what-do-you-need-to-brainstorm-software-designs">What Do You Need To Brainstorm Software Designs?</h1>

<ul>
  <li>You need the ability to jot ideas down with little resistance</li>
  <li>You need the ability to change your mind with little resistance</li>
  <li>You need to knowing a lot of different things<sup id="fnref:know" role="doc-noteref"><a href="#fn:know" class="footnote">2</a></sup>.</li>
</ul>

<p>‚ÄúThe more you know, the more creative you can be‚Äù (Pat Pattison, songwriting).</p>

<h1 id="what-inhibits-brainstorming">What Inhibits Brainstorming?</h1>
<p>Limited scope / knowledge - if all you know is how to use a hammer, everything looks like a nail</p>

<p>For example, if all you know is FP, then everything becomes a function. (This is backwards - focus on the problem first, then find a notation that fits the problem).</p>

<p>Low-level details. <a href="https://guitarvydas.github.io/2021/03/17/Details-Kill.html">Details Kill</a></p>

<p>Most current PLs drive at Implementation.  This inhibits thinking about anything but implementation.</p>

<p>Early Lisp tried to allow brainstorming (called Rapid Prototyping back then), but this was beat out of Lisp through the Common Lisp standardization process (the standardization process was agenda-driven: how to make it possible to compile Lisp).</p>

<h1 id="layers">Layers</h1>
<p>Construct thoughts + programs in a layered manner.</p>

<p>Suppress details to a lower layer.</p>

<p>Description of details only flows ‚Äúdownward‚Äù</p>

<h1 id="discussion-engineering-is-not-coding">Discussion: Engineering Is Not Coding</h1>
<p>Note that Software Engineering is <em>not</em> coding<sup id="fnref:eng:1" role="doc-noteref"><a href="#fn:eng" class="footnote">1</a></sup>.</p>

<p>Implementation is coding.</p>

<p>Software Engineering is the detailed thought process that comes after Software Architecture and before Software Implementation.</p>

<p>For example, imagine the difference between someone who designs automobiles and someone who repairs them.  If we insisted that our automobiles were repaired only by automobile designers, we would end paying custom rates for repair work (not to mention the possibility that the Designers don‚Äôt have a lot of experience with using repair tools).</p>

<p>Similarly, I suggest that we divide Software Development into several categories, e.g.</p>
<ul>
  <li>Software Architecture</li>
  <li>Software Engineering</li>
  <li>Software Implementation</li>
  <li>Software Quality Assurance</li>
  <li>etc.<br />
and pay only for what we need at any point in the process, allowing people to concentrate on activities that they are good at.</li>
</ul>

<h1 id="see-also">See Also</h1>

<p><a href="https://guitarvydas.github.io/2021/01/14/References.html">References</a><br />
<a href="https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html">Table of Contents</a></p>

<script src="https://utteranc.es/client.js" repo="guitarvydas/guitarvydas.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async=""> 
</script>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:eng" role="doc-endnote">
      <p>Note that ‚ÄúEngineering‚Äù is a legal term in some jurisdictions. In Ontario, Canada, it is <em>illegal</em> to use the term ‚ÄúEngineer‚Äù to describe someone who isn‚Äôt certified as an Engineer. Today, we mis-use the term ‚ÄúSoftware Engineer‚Äù to mean anyone who creates <em>code</em>. In fact, only a subset of code-creators are true Engineers.  [I know of a case where a company official was contacted and told to stop using the phrase ‚ÄúSoftware Engineer‚Äù in employment advertisements.]¬†<a href="#fnref:eng" class="reversefootnote" role="doc-backlink">&#8617;</a>¬†<a href="#fnref:eng:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:know" role="doc-endnote">
      <p>Different kinds of knowledge allow you to ‚Äúthink outside of the box‚Äù, i.e. to see different ways to approach the problem-at-hand ; to see similarities of the problem-at-hand to other paradigms. By ‚Äúdifferent kinds‚Äù, I don‚Äôt mean just kinds of programming, but, wildly different kinds of things. Examples from my experience: cooking, astronomy, photography using film and chemicals, wine-making, guitar-playing, trumpet, piano, soldering, wire-wrapping, Physics, EE, swimming, songwriting, etc. etc.¬†<a href="#fnref:know" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET