I"ü'<p>One form of complexity is caused by flattening dimensions in the Design space.</p>

<h1 id="overview">Overview</h1>
<p>Imagine that we need to write a big application.</p>

<p>The big application has many aspects to it.</p>

<p>It has many dimensions.</p>

<p>There are many degrees of freedom in the Design.</p>

<p>We can remove dimensions by flattening them out and expressing them in some sort of LCD (lowest common denominator) language.</p>

<p>We often try keep <em>all</em> of the design details, but we try to express them in only one notation.</p>

<p>The final result is complicated, because the reader needs to un-flatten the notation to be able to understand all of the dimensions of the design.</p>

<p>The reader needs to <em>reverse engineer</em> the notation to recover all of the dimensions.</p>

<h1 id="example">Example</h1>

<h2 id="compiler-pieces">Compiler Pieces</h2>
<p>Let‚Äôs say that we want to write a compiler.</p>

<p><a href="https://github.com/guitarvydas/guitarvydas.github.io/blob/master/assets/2021-06-01-compiler.png">compiler rough break-down (diagram)</a></p>

<p>We think of the compiler in separate dimensions:</p>

<ol>
  <li>The Grammar</li>
  <li>The Declarations</li>
  <li>The Uses of Declared Items</li>
  <li>Code Generation.</li>
</ol>

<p>Restated: We structure a compiler as follows:</p>
<ol>
  <li>Syntax Analysis</li>
  <li>Check the incoming program-to-be-compiled for syntax (lexing)</li>
  <li>Then, check the incoming program for grammar correctness (parsing)</li>
  <li>Make tables that hold all of the declared items (and their details)</li>
  <li>Check all of the incoming program-to-be-compiled for declaration-before-use</li>
  <li>Check for other kinds of errors</li>
  <li>Emit code.</li>
</ol>

<p>If we think about the compiler as above, then each step is ‚Äúeasy‚Äù.</p>

<p>If we schmoo all of the above into one big blob of code, then things get complicated.  Worse yet, maybe they begin to interact. Example: imagine that we make a change in (5) and something in (1) breaks.</p>

<p>Restated for emphasis: if we try to dumb down the design and include <em>everything</em> in one, single, notation, we get a complicated result that is hard to reason about.</p>

<p>The easiest way to think about the above is to keep the steps separated and isolated.</p>

<p>We need <em>separate</em> notations for each of the above steps.</p>

<p>Restated for emphasis: we want a notation for lexing, another notation for parsing, another notation for detail-gathering, another notation for semantics-checking and another notation for code emitting.</p>

<h2 id="denotational-semantics---accidental-complexity">Denotational Semantics -&gt; Accidental Complexity</h2>

<p>Denotational Semantics is an real-life example of how to make the above problem more complicated by using <em>one language to rule them all</em>.</p>

<p>Another phrase for this is <em>accidental complexity</em>.</p>

<p>Each step is simple on its own. If the steps are combined, then complexity emerges.</p>

<h2 id="compiling">Compiling</h2>
<p>We already know how to do lexing.  LEX ‚Äì&gt; REGEX.</p>

<p>We already know how to do parsing.  YACC, PEG, etc.</p>

<p>We already know how to store semantic information.  Hash tables.</p>

<p>We already know how to check semantics - use the above hash tables.</p>

<p>We already know how to emit code.  Printf(), Javascript template strings, etc, etc.</p>

<p>Note that the above things are all <em>separate</em> notations.  If we try to schmoo them altogether into an LCD language, they stop being separate and look more complicated than they really are.  If they start to interact (which they invariably do), we get unintended complexity.</p>

<h1 id="nesting">Nesting</h1>

<p>Many big wins in computing seem to be related to nesting.</p>

<p>Example, to organize global variables, we nested them ‚Äì&gt; scoped locals.</p>

<p>Example: to battle spaghetti code, we nested code ‚Äì&gt; Structured Programming.</p>

<p>Example: To organize data+functions, we nested them ‚Äì&gt; modules ‚Äì&gt; OOP.</p>

<h1 id="eliding">Eliding</h1>
<p>Q: Is eliding the same as flattening?</p>

<p>A: No.</p>

<h1 id="4d-mapped-to-2d">4D mapped to 2D</h1>

<p>Flattening is the <em>projection</em> of one dimesion onto others, effectively discarding a dimension.</p>

<p>I think of problems as being 4D (X/Y/Z/Time) yet I think that code is 2D (X/Y).</p>

<p>Eliding keeps the dimensions but hides them.</p>

<h1 id="design-provenence-via-githubdiffetc">Design Provenence via Github/diff/etc.</h1>
<p>For now, we can use <code class="language-plaintext highlighter-rouge">git</code> to show diffs from the original Design to any aspect of the design.</p>

<p>In the above example,</p>
<ol>
  <li>We store and edit the grammar on a grammar branch.</li>
  <li>We do semantic gathering on another branch. I suggest calling it <em>declare</em>.</li>
  <li>We do semantic checking on yet another branch. I suggest calling this branch <em>design rules</em>. Note that <em>type checking</em> falls into this branch.  There might be other things, beyond types, that we would want to check.  (N.B. Haskell sort-of does this.  A function declaration consists of a signature and some code.  Signatures are, effectively, checked in a separate stage.)</li>
  <li>We do code emission on yet another branch. I suggest calling this <em>emit</em>. We might want to optimize the emitted code - that‚Äôs yet another sub-branch - and so on, ad infinitum (everything is a fractal).</li>
</ol>

<p>Note that we might edit the grammar in step 1 to help us do step 3, and/or, we might edit the grammar from step 1 to help with step 4, and so on.</p>

<p>The edits in step 3 might be different from the edits in 4. If we try to combine them into a single LCD language, we will get uneccessary complexity.</p>
<h1 id="design-provenence-checking">Design Provenence Checking</h1>
<p>The best way to hang everything together is to ensure that edits are directly related to the original Design.</p>

<p>It would be nice if we could do this automatically, but, for now, we should give someone the job of manually checking provenence (using, say, git and diff) from step 1 to 2, 1 to 2 to 3, 1 to 2 to 3 to 4, and so on.</p>
<h1 id="diagrams">Diagrams</h1>
<p>The original Design is, often, just a bunch of diagrams on a white board.  Maybe the CEO, who doesn‚Äôt care about Engineering details, sketched the original Design.</p>

<p>OK - snapshot the diagrams and record provenence.</p>

<p>The <em>provenence checker</em> ensures that the top level Architecture is directly related to the whiteboard diagrams.  The <em>provenence checker</em> ensures that the Engineering ‚Äúblueprints‚Äù directly relate back to the Architecture. The <em>provenence checker</em> ensures that Implementation directly relates back to Engineering.  The <em>provenence checker</em> ensures that Testing relates directly back to Architecture/Engineering/Implementation/etc. If not, the <em>provenence checker</em> bubbles information back up the chain, checks the change(s) with the next level up and re-jigs the pieces until they all flow from one another without any singularities.</p>

<h2 id="automating-provenence-checking">Automating Provenence Checking</h2>
<p>Can we automate <em>provenence checking</em>?</p>

<p>Probably.</p>
<h2 id="automating-provenence-using-lcd-technology">Automating Provenence Using LCD Technology</h2>
<p>Can we automate <em>provenence checking</em> by using a single notation for <em>everything</em>?</p>

<p>Probably, but the job becomes more complicated.</p>

<h1 id="general-purpose-languages">General Purpose Languages</h1>
<p>Let‚Äôs put GPLs in their place.</p>

<p>They are not really <em>general purpose</em>, they are tuned for one kind of thought process - <em>Implementation</em>.</p>

<p>A lot of languages are tuned for Implementation.</p>

<h1 id="example---relational-languages">Example - Relational Languages</h1>

<p>This is just an example of the extremes in notation that can arise.</p>

<p>Relational languages break programming up into 2 parts:</p>

<ul>
  <li>description</li>
  <li>engine (implementation).</li>
</ul>

<p>The <em>good parts</em> of relational programming are:</p>

<ul>
  <li>
    <p>exhaustive search engine</p>
  </li>
  <li>
    <p>Syntax for exhaustive search.</p>
  </li>
</ul>

<p>PROLOG syntax defines a way to denote <em>logic variables</em> and to denote <em>rules</em>.  MiniKanren denotes these same kinds of things differently.</p>

<p>The concept of <em>printf</em> does not really fit the main intent of relational programming.</p>

<p>Q: Can relational languages create formatted output?</p>

<p>A: Yeah, but I‚Äôd rather use <em>printf</em> for formatting output than using PROLOG for such tasks</p>

<p>Formatted output is not the main thrust of relational programming.</p>

<p>The <em>one-languge-to-rule-them-all</em> mentality drives PROLOG implementors into bolting <em>format</em> into PROLOG and, thus, wasting brain power.</p>

<p>The <em>multi-language/multi-paradigm</em> mentality says that it is OK to use PROLOG even if it doesn‚Äôt create formatted output.  Use PROLOG for exhaustive pattern matching, and use something else (e.g. <em>printf</em> or JS <em>template strings</em> or bash strings) for formatting results.</p>

<h1 id="normalization">Normalization</h1>

<p>To do this effectively, we must employ a common <em>normalized form</em> for information (I favor <a href="https://guitarvydas.github.io/2021/03/16/Triples.html">triples</a> and <a href="https://guitarvydas.github.io/2021/01/17/Factbases.html">factbases</a>, <a href="https://guitarvydas.github.io/2021/04/26/Factbases-101.html">factbases 101</a>)</p>

<h1 id="see-also">See Also</h1>

<p><a href="https://guitarvydas.github.io/2021/01/14/References.html">References</a><br />
<a href="https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html">Table of Contents</a></p>

<script src="https://utteranc.es/client.js" repo="guitarvydas/guitarvydas.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async=""> 
</script>

:ET