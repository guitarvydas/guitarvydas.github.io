I"Q¬<p>I describe the implementation of a very simplistic example using inner concurrency and a handful of diagrams.</p>

<p>The example is <code class="language-plaintext highlighter-rouge">cat</code>.  It copies the contents of a file to the console, character by character.  It, also, outputs each character on a port (unused in this simple example).</p>

<p>This document is a snapshot of my current progress in describing these concepts.</p>

<h2 id="top-level">Top Level</h2>

<p><img src="/assets/cat.png" alt="Top Level of The Simple Example (cat)" /><br />
(obsidian:<br />
<img src="file:///Users/tarvydas/Desktop/blogs/guitarvydas.github.io/assets/cat.png" alt="cat.png" /><br />
)</p>

<p>The diagram represents a very simple system with three (3) components total</p>
<ul>
  <li>a Container</li>
  <li>two (2) Leaf components.</li>
</ul>

<p>The Container is called <code class="language-plaintext highlighter-rouge">top</code>.</p>

<p>The Leaf components are called <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">write</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Top</code> runs the two leaves concurrently and routes messages between them.</p>

<p><code class="language-plaintext highlighter-rouge">Top</code> is called (invoked) like a normal function and can return values like a normal function.  (In this example, <code class="language-plaintext highlighter-rouge">top</code> doesn‚Äôt bother to return anything).</p>

<p>When <code class="language-plaintext highlighter-rouge">top</code> is invoked, it is passed two (2) parameters</p>
<ol>
  <li>the filename to be read</li>
  <li>the filename to be written (which is ignored in this simple example, this example simply prints characters on the console and doesn‚Äôt write them to a file).</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">Top</code> injects these two filenames into the appropriate components and starts up concurrent dispatching.</p>

<p>How does <code class="language-plaintext highlighter-rouge">top</code> know when to stop dispatching?  One<sup id="fnref:sev" role="doc-noteref"><a href="#fn:sev" class="footnote">1</a></sup> of its children tells it to stop.  In this example, <code class="language-plaintext highlighter-rouge">read</code> invokes <code class="language-plaintext highlighter-rouge">conclude</code> when it hits end-of-file.</p>

<p>Note that the Leaf component <code class="language-plaintext highlighter-rouge">write</code> has an output <code class="language-plaintext highlighter-rouge">char</code> which is unused - <code class="language-plaintext highlighter-rouge">NC</code> (No Connection).</p>

<p><code class="language-plaintext highlighter-rouge">Write</code> does not know (cannot know) that its output <code class="language-plaintext highlighter-rouge">char</code> is not connected and, <code class="language-plaintext highlighter-rouge">write</code> continues to output characters to that output.  The <em>dispatcher</em> dumps messages coming from this pin on the floor (<code class="language-plaintext highlighter-rouge">pass</code> in Python lingo).</p>

<p>Note that <code class="language-plaintext highlighter-rouge">write</code> is never overwhelmed with too many input characters.  <code class="language-plaintext highlighter-rouge">Write</code> sends <em>request</em>s to <code class="language-plaintext highlighter-rouge">read</code> for each character.  [If we were concerned with efficiency, we might send big buffers of characters instead of single characters - but, that is left for Production Engineering to worry about].</p>

<h2 id="ports">Ports</h2>

<p>What is a Port?</p>

<p>A Port is a block (array) of data.</p>

<p>The data can be destructured into several sub-items, conforming to shapes that we call <em>types</em>.</p>

<p>All data on a single port arrives / leaves <em>at the same time</em>.</p>

<p>Ports, though, can fire at different times.</p>

<p><em>Functions</em> in traditional programming languages, have exactly one (1) input port and (1) output port and cause the caller to <em>block</em> (implicit synchronization).  Such functions receive all of their data at once.  We call that input data ‚Äúparameters‚Äù and imagine that they are separate items.  Such functions save up all of their output data and <code class="language-plaintext highlighter-rouge">send</code> it all at the same time in a single block.  If you know how compilers work, then you already know that parameters are stuffed into a global array (called The Stack) and are destructured by the callee. Likewise, compilers stuff all return data into the global array and the caller destructures the block when it wakes up again.  Compilers have different - aggressive - optimizing strategies, so the exact details might be different from what is described in the preceding.</p>

<p>Messages travel between ports.</p>

<h2 id="blocking">Blocking</h2>

<p>Blocking is synchronization.</p>

<p>Blocking is usually thought to be controlled by the Operating System.</p>

<p>Blocking actually happens in two (2) places, voiding the principal of locality-of-reference.</p>

<p>Blocking is controlled by:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">CALL</code> and <code class="language-plaintext highlighter-rouge">RETURN</code> low-level, built-in CPU instructions</li>
  <li>the Operating System.</li>
</ol>

<p>Note that the Operating System needs to implement preemption (an epicycle) to yank blocking control away from processes which use the low-level <code class="language-plaintext highlighter-rouge">CALL</code> and <code class="language-plaintext highlighter-rouge">RETURN</code> blocking instructions.</p>

<h2 id="synchronization-generalized">Synchronization Generalized</h2>

<p>The general form of synchronization is to <em>ask</em> and <em>receive</em> via asynchronous messages.</p>

<p>The general form of synchronization can be seen in network protocols and in everyday life (e.g. interacting with other people).</p>

<p>Programmers tend to have difficulty with <em>multitasking</em> because they try to invert the natural order of life (where everything is asynchronous by default) and need to (re)-learn how to deal with such inversions of primary instincts.</p>

<p>One <em>optimization</em> of synchronization is to use a global variable (The Stack) and the low-level, built-in <code class="language-plaintext highlighter-rouge">CALL</code> and<code class="language-plaintext highlighter-rouge">RETURN</code> instructions of the underlying CPUs.  In this case, the messages and state-machine protocols are implemented in hardware in an optimized manner.</p>

<h2 id="boxes">Boxes</h2>

<p>Boxes, on a diagram, represent software components.</p>

<p>Concentric boxes represent synchronous components that allow inheritance (AKA scoping).</p>

<p>Separate boxes that communicate via messages on ports represent asynchronous components.</p>

<p>Every system consists of a single box that encloses other boxes.</p>

<p>Distributed systems appear not to have a single enclosing box, but, that is because we elide the top-level box and view only its innards.  For example, a robot is composed of many computers.  A robot is a single, stand-alone system, but we tend not to need to view it that way, and instead consider all of its parts as being separate entities.   We can change our mental ‚Äúcamera angle‚Äù to zoom-in and view the robot as a bunch of separate parts, or, we can zoom-out and consider the robot as a whole, e.g. when interacting with other robots and objects.  Being able to change our zoom factor allows us to avoid becoming overwhelmed with details and to describe (script) higher-and-higher level interactions.</p>

<h2 id="messages">Messages</h2>

<p>A Message contains two fields:</p>
<ol>
  <li>an <em>etag</em></li>
  <li><em>data</em>.</li>
</ol>

<p>The <em>etag</em> is, currently, an implementation-dependent code (e.g. a number or a symbol or a string) that identifies the port (reason) that the message arrived on.</p>

<p><em>Data</em> is a block of data.  The shape and size of the data depends on the component.  Akin to the concept of <em>implementation-dependent</em> size and shape, <em>data</em> is <em>component-dependent</em>.</p>

<p>The system does not define the size and shape of message data.  This cannot be known until the component has been implemented.  The Sender is responsible for sending appropriate data.  The Receiver is responsible for input validation.</p>

<p><em>Future Consideration</em>: Can a type-checker / compiler / optimizer insert information into messages that help optimize the input validation phase(s)?</p>

<h2 id="how-to-use">How To Use</h2>

<h3 id="most-basic-usage">Most Basic Usage</h3>

<p>To run the basic tests:</p>

<p><code class="language-plaintext highlighter-rouge">node test.js</code></p>

<p>This should run three tests</p>
<ol>
  <li>read test using the Leaf <code class="language-plaintext highlighter-rouge">read.js</code></li>
  <li>write test using the Leaf <code class="language-plaintext highlighter-rouge">write.js</code></li>
  <li>container test using the Container <code class="language-plaintext highlighter-rouge">top.js</code></li>
</ol>

<p>The read test uses <code class="language-plaintext highlighter-rouge">readwrapper.js</code> to run the <code class="language-plaintext highlighter-rouge">read.js</code> Leaf.</p>

<p><code class="language-plaintext highlighter-rouge">Readwrapper.js</code> looks like a function / component to the outside world and can be called like a function.</p>

<p><code class="language-plaintext highlighter-rouge">Readwrapper.js</code> creates a <code class="language-plaintext highlighter-rouge">read</code> component by using <code class="language-plaintext highlighter-rouge">read.js</code> and sends a test string into the <code class="language-plaintext highlighter-rouge">read</code> component.  In this example, the test string is <code class="language-plaintext highlighter-rouge">"text.txt"</code>, which is the filename of a small bit of text that is opened and read by the component.  <code class="language-plaintext highlighter-rouge">Readwrapper</code> creates fake entry points for the main programmatic features of a Leaf component and then punts (delegates) all calls to these entry points to the actual component that is being wrapped (i.e. <code class="language-plaintext highlighter-rouge">read</code>).</p>

<p>It is expected that <code class="language-plaintext highlighter-rouge">read</code> opens and reads the file and produces output messages.  In this - very simple - case, <code class="language-plaintext highlighter-rouge">read</code> opens and read the file character-by-character, producing one output message for each character.</p>

<p>The idea is that the <code class="language-plaintext highlighter-rouge">read</code> component <code class="language-plaintext highlighter-rouge">send</code>s these messages to other components for processing, but, in this case, we simply want to verify that <code class="language-plaintext highlighter-rouge">read</code> works as expected.</p>

<p><code class="language-plaintext highlighter-rouge">Readwrapper</code> runs the <code class="language-plaintext highlighter-rouge">read</code> component, then dumps al of its outputs to the console for visual inspection.  This is a very low-level test.  As we build up larger and larger systems, we would write <em>test programs</em> to inspect the outputs instead of relying on manual inspection.</p>

<p>In this particular case, we expect <code class="language-plaintext highlighter-rouge">testwrapper.js</code> to output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read ...
r outputs (r::[o]char:a:(rw::[i]req:true:.))
r outputs (r::[o]char:b:(rw::[i]req:true:.))
r outputs (r::[o]char:c:(rw::[i]req:true:.))      
</code></pre></div></div>

<p>Decoding this output:</p>
<ul>
  <li>‚Äúr‚Äù is the name of the UUT <code class="language-plaintext highlighter-rouge">test.js</code></li>
  <li><code class="language-plaintext highlighter-rouge">(r::[o]char:a:(rw::[i]req:true:.))</code> is a message with tracing enabled</li>
  <li>tracing is read from left to right
    <ul>
      <li>the actual message comes first</li>
      <li>followed by a nested trace of all messages that caused this message</li>
      <li><code class="language-plaintext highlighter-rouge">r::[o]char:a</code> says that the component ‚Äúr‚Äù emitted an output message ([o]) with the etag <code class="language-plaintext highlighter-rouge">char</code> data <code class="language-plaintext highlighter-rouge">a</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">:(rw::[i]req:true:.)</code> is a trace that says the the component ‚Äúrw‚Äù (read wrapper) produced an input message tagged <code class="language-plaintext highlighter-rouge">req</code> and data <code class="language-plaintext highlighter-rouge">true</code> which was preceded by no other messages (<code class="language-plaintext highlighter-rouge">.</code>).</li>
    </ul>
  </li>
</ul>

<p>If we look at the source code for <code class="language-plaintext highlighter-rouge">read</code> (<code class="language-plaintext highlighter-rouge">read.js</code> / protoImplementation / handler), we see that it waits for a filename, then outputs one character message (<code class="language-plaintext highlighter-rouge">char</code>) every time it receives a <code class="language-plaintext highlighter-rouge">req</code> message. In normal usage, the <code class="language-plaintext highlighter-rouge">req</code> message would come from a downstream component, but in this test case, <code class="language-plaintext highlighter-rouge">testwrapper</code> generates (stub) <code class="language-plaintext highlighter-rouge">req</code> messages and injects these test messages into the <code class="language-plaintext highlighter-rouge">read</code> UUT with an appropriate etag (<code class="language-plaintext highlighter-rouge">req</code>).</p>

<p>The <code class="language-plaintext highlighter-rouge">read.js</code> component doesn‚Äôt know (cannot know) where the <code class="language-plaintext highlighter-rouge">req</code> messages come from and simple responds to each one.</p>

<p>When <code class="language-plaintext highlighter-rouge">read.js</code> encounters an end-of-file condition, it invokes the <code class="language-plaintext highlighter-rouge">conclude</code> entry point which finishes the test and causes <code class="language-plaintext highlighter-rouge">testwrapper</code> to call <code class="language-plaintext highlighter-rouge">finish</code> and return.  In normal (‚Äústeady-state‚Äù usage), a Container would be calling <code class="language-plaintext highlighter-rouge">read</code> and the Container would supply a <code class="language-plaintext highlighter-rouge">conclude</code> entry point.  In this case, because we are testing <code class="language-plaintext highlighter-rouge">read</code>, the <code class="language-plaintext highlighter-rouge">conclude</code> entry point is supplied by <code class="language-plaintext highlighter-rouge">testwrapper</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Writewrapper.js</code> is built in a similar way.  We expect the write test to display the characters on the console and to send each of the characters as output messages.  The <code class="language-plaintext highlighter-rouge">write.js</code> component is like the <code class="language-plaintext highlighter-rouge">tee</code> command in UNIX¬Æ - it outputs each input character to two different places.</p>

<p>In normal usage, we would expect downstream components to use the output messages from <code class="language-plaintext highlighter-rouge">write.js</code>.  In this test case, however, we ignore the messages and manually inspect them as they are output.</p>

<p><code class="language-plaintext highlighter-rouge">Topwrapper.js</code> is similar to the above, except that it uses a Container component and connects the output from <code class="language-plaintext highlighter-rouge">read</code> to the input of <code class="language-plaintext highlighter-rouge">write</code>. And, it connects the <code class="language-plaintext highlighter-rouge">request</code><br />
output from <code class="language-plaintext highlighter-rouge">write</code> to the <code class="language-plaintext highlighter-rouge">req</code> input of <code class="language-plaintext highlighter-rouge">read</code>.  N.B. the actual names of these etags is different - <code class="language-plaintext highlighter-rouge">request</code> vs. <code class="language-plaintext highlighter-rouge">req</code> - but neither Leaf component cares about this difference.  The routing table is set up in <code class="language-plaintext highlighter-rouge">top</code> and only <code class="language-plaintext highlighter-rouge">top</code> knows about the name differences.  An entry in <code class="language-plaintext highlighter-rouge">makeConnections()</code> explicitly wires the <code class="language-plaintext highlighter-rouge">w:request</code> output to the <code class="language-plaintext highlighter-rouge">r:req</code> input.</p>

<h2 id="testing">Testing</h2>
<p>The <code class="language-plaintext highlighter-rouge">readwrapper.js</code> code contains the term <code class="language-plaintext highlighter-rouge">uut</code>.  The term <em>uut</em> comes from the hardware-testing realm, meaning ‚ÄúUnit Under Test‚Äù.  To test electronic circuits as they come off of the production line, one sets up a testing workbench and drops the UUT into the workbench.  The workbench drives inputs into the circuit and records outputs from the circuit.  A program (software) is used to check that the outputs conform to the expected results.  This technique works because electronic circuits are inherently asynchronous and carry no dependencies.  It is possible to test electronic circuits using simple stimulus-response techniques because the circuits are stand-alone (have no dependencies, except for very basic things like needing power from a battery or power supply).  Testers - ATE (automated test equipment) can do basic black-box testing.  Testers can also do white-box testing by poking probes directly into parts of the circuit using what is called a <em>bed of nails</em>. Test Engineers review circuit designs, before production, and suggest changes to the designs to insert <em>TP</em>s - Test Points - into the production circuits, to enable a layered approach to white-box testing. For example, first a black-box test is used to determine a GO/NOGO status for each production board.  Most boards don‚Äôt fail and are shipped if they receive a ‚ÄúGO‚Äù status.  Boards that receive a ‚ÄúNO GO‚Äù status are tested further.  Electronic components can be expensive, so an attempt is made to repair ‚ÄúNO GO‚Äù boards.  The next layer of testing checks TPs to isolate problem areas.    This process continues to test deeper and deeper into the non-conforming circuits based on an ROI evaluation - ‚Äúis it worth the time to delve deeper into the problem(s) in the hopes of repairing the board, or, is it cheaper to discard the board?‚Äù.  Boards for which the problem issues are isolated are sent to a re-work station.  After being repaired, boards are put back into the production line for a new cycle of testing and shipping.</p>

<h3 id="other-usage">Other Usage</h3>

<p>Examine <code class="language-plaintext highlighter-rouge">test.js</code>.</p>

<p>It contains three (3) invocations of the test harness code.</p>

<p>The final invocation <code class="language-plaintext highlighter-rouge">testContainer</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function testContainer () {
    var tw = require ('./topwrapper');
    var testHarness = new tw.TopWrapper ();
    
    //testHarness.tracing = true;
    
    testHarness.begin ('test.txt', 'test.out');
    testHarness.route ();

    while (!testHarness.done ()) {
        testHarness.step ();
        testHarness.route ();
    }

    testHarness.finish ();
}
...
testContainer ();
</code></pre></div></div>
<p>invokes <code class="language-plaintext highlighter-rouge">top</code> in three (3) major steps:</p>
<ol>
  <li>begin
    <ul>
      <li><code class="language-plaintext highlighter-rouge">begin (*filename‚ÇÅ*, *filename‚ÇÇ*)</code></li>
      <li>followed by <code class="language-plaintext highlighter-rouge">route ()</code></li>
      <li>causes initialization of the <code class="language-plaintext highlighter-rouge">top</code> component, and,</li>
      <li>routes any initial outputs to other components
        <ul>
          <li>in this example, <em>filename‚ÇÅ</em> is sent to the <code class="language-plaintext highlighter-rouge">read</code> component, and,</li>
          <li><em>filename‚ÇÇ</em> is sent to the <code class="language-plaintext highlighter-rouge">write</code> component</li>
          <li>as per the first (top-level) diagram</li>
          <li><em>future consideration</em>: it seems that <code class="language-plaintext highlighter-rouge">begin()</code> might be implemented using some <code class="language-plaintext highlighter-rouge">varargs</code> mechanism, but, for this example, we hard-code the two parameters into test.js</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>the main loop (dispatch)
    <ul>
      <li>test for completion</li>
      <li>step the component (Containers try to step their children ; when no child has produced output, the Container declares itself to be ‚Äúfinished‚Äù and returns a flag that indicates whether there are messages on the Container‚Äôs output queue)</li>
    </ul>
  </li>
  <li>finish.</li>
</ol>

<h2 id="how-to-modify">How To Modify</h2>

<ul>
  <li>begin by examining <code class="language-plaintext highlighter-rouge">top</code> and <code class="language-plaintext highlighter-rouge">topwrapper</code></li>
  <li>create new components
    <ul>
      <li>for Leaf components, examine <code class="language-plaintext highlighter-rouge">read.js</code> and <code class="language-plaintext highlighter-rouge">write.js</code></li>
      <li>for Container componente, examine <code class="language-plaintext highlighter-rouge">top.js</code></li>
    </ul>
  </li>
</ul>

<p>N.B. it is OK to leave inputs and outputs not connected <em>NC</em>.  This allows multiple use (reuse) of components in different situations.  It is not necessary to predict how a component will be used.  It is not necessary to parameterize a component for new usages (write a wrapper instead).</p>

<p>N.B. it is OK to create feedback loops of messages - a component sends itself a message, or, a chain of events causes a message to be sent back to the front of the same component chain.</p>

<p>N.B. it is possible to test components in a stand-alone manner.  Components have zero (0) dependencies on other components.  Components have well-define input and output signatures.  Components never contain hard-wired names of other components.</p>

<h2 id="details-of-the-implementation">Details of the Implementation</h2>

<p>Each of the components is described by two uber-lists of attributes:</p>
<ol>
  <li>Signature</li>
  <li>Implementation (prototype implementation).</li>
</ol>

<p>When we define a component, we are defining a prototype.</p>

<p>When we want to compose a system using prototype components, we create <em>runnable</em> versions of each component (called <em>instances</em> in traditional programming).</p>

<p>We can include more than one instance of the same prototype in a Container component.  Each instance is given a unique id (a graphical position) and sometimes provide <em>synonyms</em> for the id that are easier for humans to read (the machine doesn‚Äôt care about the names, only humans do).  In general, we could provide more than one synonym for each component (e.g. a Greek letter vs. a phrase), but, in this simple example, we don‚Äôt bother to do that (to keep things simple for human-oriented reading).</p>

<p>In fact, in this simple example, we use the name of the prototypes (<code class="language-plaintext highlighter-rouge">Top</code>, <code class="language-plaintext highlighter-rouge">read</code>, <code class="language-plaintext highlighter-rouge">write</code>) as the names for the runnable components.  This cheat works because - in this simple example - we have exactly one instance of every component.  To relate this concept to traditional programming, imagine ‚Äúvariable names‚Äù in programming languages.  Such names actually denote byte offsets for destructuring the data blocks.  In the extreme case, we use De Bruijn indices to elide human-readable names with stack offset indices.</p>

<p>We compose programs in a layered manner.  We create prototypes, then compose them (by ‚Äúprogramming‚Äù).  Since the composed components can be used in other systems, they act as prototypes for use in the other systems.  This layering is <em>fractal</em> and continues downward and upward ad infinitum<sup id="fnref:turtles" role="doc-noteref"><a href="#fn:turtles" class="footnote">2</a></sup>.</p>

<h2 id="signature">Signature</h2>

<p>A signature contains three (3) pieces of information:</p>
<ol>
  <li>name</li>
  <li>inputs</li>
  <li>outputs.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var signature = {
    name: "read",
    inputs: [
        { "name": "filename", "structure": ["filename"] },
        { "name":"req", "structure":["req"] }
    ],
    outputs: [
        { "name": "char", "structure": ["char"] }
    ]
};
</code></pre></div></div>

<p>Each port has</p>
<ul>
  <li>name</li>
  <li>destructuring information.</li>
</ul>

<p>The destructuring information corresponds to what is called a <em>parameter list</em> in traditional languages.</p>

<p>Each port is asynchronous.  It does not make sense to describe all ports in a collapsed notation.</p>

<p><em>Future Consideration</em>:  Does the destructuring information belong in the top-level signature, or, can it be demoted to a different level of description, or, described only in the implementation layers?  Currently, type-checkers want to ‚Äúreach in‚Äù and know how each port is destructured.  Maybe type-checking can be moved to a separate pass (akin to, say, the Loader) and run in waves, checking only what can be checked with the given information and leaving breadcrumbs for future waves of checking?  A Component cannot be deemed to be <em>runnable</em> unless it contains no breadcrumbs.</p>

<h2 id="prototype-implementation">Prototype Implementation</h2>

<p>Each Component runs but one <code class="language-plaintext highlighter-rouge">step</code> when commanded to do so by its Container.  The <code class="language-plaintext highlighter-rouge">step</code> must return <code class="language-plaintext highlighter-rouge">true</code> if any output was generated by the Component, or <code class="language-plaintext highlighter-rouge">false</code><br />
 if the Component created no outputs.</p>

<p>Each implementation contains attributes:</p>
<ul>
  <li>name</li>
  <li>kind</li>
  <li>handler</li>
  <li>begin</li>
  <li>finish.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">name</code> must correspond exactly to the name in the component‚Äôs signature.</p>

<p><code class="language-plaintext highlighter-rouge">Kind</code> is either <code class="language-plaintext highlighter-rouge">leaf</code> or <code class="language-plaintext highlighter-rouge">container</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Begin</code> and <code class="language-plaintext highlighter-rouge">finish</code> are traditional functions that take one (1) parameter - <em>me</em> (like <em>self</em> or <em>this</em>).</p>

<p><code class="language-plaintext highlighter-rouge">Handler</code> is a function of two (2) parameters</p>
<ol>
  <li><em>me</em></li>
  <li><em>message</em></li>
</ol>

<h3 id="leaf">Leaf</h3>

<h3 id="container">Container</h3>

<ul>
  <li>children
    <ul>
      <li>each child prototype has
        <ul>
          <li>kind</li>
          <li>destructuring</li>
        </ul>
      </li>
      <li>each child runnable (instance) has
        <ul>
          <li>unique name</li>
          <li>unique runnable instantiation of kind</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>connections
    <ul>
      <li>each connection has
        <ul>
          <li>sender</li>
          <li>net name</li>
          <li>list of receivers</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>nets
    <ul>
      <li>name</li>
      <li>list of components on the net (key: ‚Äúlocks‚Äù)</li>
    </ul>
  </li>
</ul>

<p>Nets are needed only in bare-metal situations - to lock all receivers before deliving message.  Semantics: one message must be delivered to all receivers ‚Äúat the same time‚Äù.</p>

<p>In implementations that use implicity synchrony (e.g. most programming languages and operating systems today), locking is not needed, since it is covered by the implicit synchrony.</p>

<h3 id="wrappers">Wrappers</h3>

<h3 id="support-code">Support Code</h3>

<h3 id="drakon-diagram">Drakon Diagram</h3>

<h4 id="stepdrakon">Step.Drakon</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flowchart Try-component {
  start main
  skewer main {
    unless has-children try-self/1
    step-each-child
    unless child-produced-output try-self/2
    &gt; produced-output/0
  }
  skewer try-self {
    : try-self/1
    : try-self/2
    run-self
    unless self-produced-output no-output/3
    &gt; produced-output/0
  }
  skewer no-output {
    : no-output/3
    send no-output _
    &gt; finished/0
  }
  skewer produced-output {
    send produced-output _
    &gt; finished/0
  }
  skewer finished {
    end
  }
}
</code></pre></div></div>

<h3 id="dia-diagrams">Dia Diagrams</h3>

<h4 id="handlingdas">Handling.das</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implementation deliverInputMessageToAllChildrenOfSelf (message)
      { find connection from me on port message.etag
        { lock connection
          { for every receivers in connection =&gt; dest
            { synonym params = {me, message, dest}
              { cond
                { dest.name != me
                  { #deliver_input_from_container_input_to_child_input &lt;= params }
                }
                { dest.name == me
                  { #deliver_input_from_container_input_to_me_output &lt;= params }
                }
              }
            }
          }
        }
        { orelse
          { pass }
        }
      }
</code></pre></div></div>

<h4 id="routingdas">Routing.das</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implementation route
{ for every item in children of me =&gt; child
  { for every item in outputQueue of child.runnable =&gt; output_message
    { synonym message = output_message
      { find connection in me given child X message.etag =&gt; connection
        { lock connection
          { for every receivers in connection =&gt; dest
              { synonym params = {me, dest, message}
                { cond
                  { dest.name is not me
                    { @deliver_to_child_input &lt;= params }
                  }
                  { dest.name is me
                    { @deliver_to_me_output &lt;= params }
                  }
                }
            }
          }
        }
        { orelse
           { pass }
        }
      }
    }
    {@child.runnable.resetOutputQueue}
  }
}

sync deliver_to_child_input &lt;= me, dest, message
   // map message for receiver
  { var input_message &lt;= $i\{\{dest.etag, message.data} message}
    { lookup dest.name =&gt; receiver
      { @receiver.enqueueInput &lt;= input_message }
    }
  }

sync deliver_to_me_output &lt;= me, dest, message
  // map message for output
  { var output_message &lt;= $o\{\{receiver.etag, message.data} message}
    { @me.enqueueOutput &lt;= output_message }
  }
</code></pre></div></div>

<h4 id="find_connectiondas">Find_connection.das</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implementation find_connection (etag)
  { for every item in connections of me =&gt; connection
      { synonym sender = connection.sender
          { when all
              {
                  sender.name is me
                  sender.etag == etag
              }
              { -&gt; connection }
          }
      }
  }

</code></pre></div></div>

<h4 id="find_connection_in__medas">Find_connection_in__me.das</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implementation find_connection_in__me (childname, etag)
  { for every item in connections of me =&gt; connection
      { synonym sender = connection.sender
          { when all
              {
                  sender.name == childname
                  sender.etag == etag
              }
              { -&gt; connection }
          }
      }
  }

</code></pre></div></div>

<h3 id="appendix---github">Appendix - Github</h3>

<p><a href="https://github.com/guitarvydas/duct">code on github</a></p>

<h3 id="appendix---leaf-read">Appendix - Leaf ‚ÄúRead‚Äù</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const runnable = require('./runnable');
const fs = require('fs');

var signature = {
    name: "read",
    inputs: [
        { "name": "filename", "structure": ["filename"] },
        { "name":"req", "structure":["req"] }
    ],
    outputs: [
        { "name": "char", "structure": ["char"] }
    ]
};

let protoImplementation = {
    name: "read",
    kind: "leaf",
    handler: function (me, message) {
        if ("filename" === message.etag) {
            me.filename = message.data;
            me.contents = fs.readFileSync (me.filename, 'utf8');
            me.cindex = 0;
        } else if ("req" === message.etag) {
            if (eof (me)) {
                me.conclude ();
            } else {
                me.send ("char", nextChar (me), me.name, message);
            }
        } else {
            me.errorUnhandledMessage (message);
        }
    },
    begin: function () {},
    finish: function () {}
}

function Read (container) {
    let me = new runnable.Leaf (signature, protoImplementation, container, "read");
    me.name = "r";
    me.filename = null;
    me.contents = null;
    me.index = null;
    return me;
}

exports.Read = Read;

// helper functions

function eof (me) {
    if (me.cindex &gt; (me.contents.length - 1)) {
        return true;
    } else {
        return false;
    }
}

function nextChar (me) {
    let c = me.contents.substr (me.cindex, 1);
    me.cindex += 1;
    return c;
}
</code></pre></div></div>

<h3 id="appendix---leaf-write">Appendix - Leaf ‚ÄúWrite‚Äù</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const runnable = require('./runnable');

var signature = {
    name: "write",
    inputs: [
        { "name": "filename", "structure": ["filename"] },
        { "name": "char", "structure": ["char"] }
    ],
    outputs: [
        { "name": "request", "structure": ["request"] },
        { "char": "request", "structure": ["char"] }
    ]
};

var protoImplementation = {
    name: "write",
    kind: "leaf",
    handler: function (me, message) {
        if ("filename" === message.etag) {
            me.send ("request", true, me.name, message);
        } else if ("char" === message.etag) {
            process.stdout.write (message.data);
            me.send ("char", message.data, me.name, message);
            me.send ("request", true, me.name, message);
        } else {
            me.errorUnhandledMessage (message);
        }
    }
}

function Write (container) {
    let me = new runnable.Leaf (signature, protoImplementation, container);
    me.name = "w";
    me.filename = null;
    return me;
}

exports.Write = Write;

// This example code implements output to the console
// but is port-for-port compatible with output to a file (aka referential transparency)

// (in a future example, we will show how to create a 'write' part that wraps, both, 
//  file and console output ; this example is extra-KISS and does only one kind of output
//  to make the example a bare minimum)

</code></pre></div></div>

<h3 id="appendix---container-top">Appendix - Container ‚ÄúTop‚Äù</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const handling = require('./handling');
const deliver = require('./containerDeliver');
const routing = require('./routing');
const runnable = require('./runnable');


const top = require('./top');
const read = require ('./read');
const write = require ('./write');

var signature = {
    name: "top",
    inputs: [
        { "name": "input filename", "structure": ["infname"] },
        { "name": "output filename", "structure": ["outfname"] }
    ],
    outputs: [
    ]
};

function begin (me, infname, outfname) {
    me.inject ("input filename", infname);
    me.inject ("output filename", outfname);
}

function finish (me) {
}

var protoImplementation = {
    name: "top",
    kind: "container",
    handler: handling.deliverInputMessageToAllChildrenOfSelf,
    route: routing.route,
    begin: begin,
    finish: finish
}       
    
function makeChildren (me) {
    var child1 = new read.Read (me);
    var child2 = new write.Write (me);
    return [
        {"name": "r", "runnable": child1}, 
        {"name": "w", "runnable": child2}
    ];
}

function makeNets (me) {
    return [
        {"name":"‚áí‚ÇÅ","locks":["r"]},
        {"name":"‚áí‚ÇÇ","locks":["w"]},
        {"name":"‚áí‚ÇÉ","locks":["r"]},
        {"name":"‚áí‚ÇÑ","locks":["w"]}
    ];
}

function makeConnections (me) {
    return [
        {"sender":{"name":"_me","etag":"input filename"},
         "net":"‚áí‚ÇÅ",
         "receivers": [{"name":"r","etag":"filename"}]
        },                 
        {"sender":{"name":"_me","etag":"output filename"},
         "net":"‚áí‚ÇÇ",
         "receivers": [{"name":"w","etag":"filename"}]
        },                 
        {"sender":{"name":"r","etag":"char"},
         "net":"‚áí‚ÇÉ",
         "receivers": [{"name":"w","etag":"char"}]
        },                 
        {"sender":{"name":"w","etag":"request"},
         "net":"‚áí‚ÇÑ",
         "receivers": [{"name":"r","etag":"req"}]
        }
    ];
}

function Top (container) {
    let me = new runnable.Container (signature, protoImplementation, container);
    me.name = "T";
    me.children = makeChildren (container);
    me.nets = makeNets (container);
    me.connections = makeConnections (container);
    me.deliver_input_from_container_input_to_child_input = deliver.deliver_input_from_container_input_to_child_input;
    me.deliver_input_from_container_input_to_me_output = deliver.deliver_input_from_container_input_to_me_output;
    return me;
}

exports.Top = Top;
</code></pre></div></div>

<h3 id="appendix-readwrapper">Appendix ‚ÄúReadWrapper‚Äù</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var read = require ('./read');
var message = require ('./message');

function ReadWrapper () {
    this.name = "rw";
    this.begin = function () {
        // this.args = ???
        uut.begin ();
    };
    this.finish = function () {
        uut.finish ();
    };
    this.isValidETagForUUT = isValidETagForUUT;
    this.isInputETag = isInputETag;
    this.send = function (etag, v) {
        if (this.isValidETagForUUT (etag)) {
            var m = new message.InputMessageNoTrace (etag, v, this.name);
            this.uut.handler (this.uut, m);
        } else {
            console.error (`invalid input message ${etag}`);
        }
    };
    this._done = false;
    this.conclude = function () { 
        this.container._done = true; 
    };
    this.done = function () {return this._done;};
    this.route = function () {
        this.uut.route ();
        if (this.tracing) {
            destructivelyDisplayAllOutputsForAllChildren (this);
        }
    };    
    this.step = function () {
        this.uut.step ();
        this.route ();
    };    
    this.uut =  new read.Read (this);
    this.children = [{name: "uut", runnable: this.uut}];
}

function isValidETagForUUT (etag) {
    if (this.isInputETag (etag)) {
        return true;
    } else {
        return false;
    }
}

function isInputETag (etag) {
    var inputs = this.uut.signature.inputs;
    return inputs.some (input =&gt; { return (etag === input.name); });
}

function destructivelyDisplayAllOutputsForAllChildren (me) {
    me.children.forEach (child =&gt; {
        var r = child.runnable;
        displayAllOutputs (r);
        r.resetOutputQueue ();
    });
}

function displayAllOutputs (child) {
    child.outputQueue.forEach (m =&gt; {
        console.log (`${child.name} outputs ${recursiveDisplay (m)}`);
    })
}

function recursiveDisplay (m) {
    if (m) {
        return `(${m.comefrom}::[${m.kind}]${m.etag}:${m.data}:${recursiveDisplay (m.tracer)})`;
    } else {
        return '.';
    }
}

exports.ReadWrapper = ReadWrapper;
</code></pre></div></div>

<h3 id="appendix-writewrapper">Appendix ‚ÄúWriteWrapper‚Äù</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var write = require ('./write');
var message = require ('./message');

function WriteWrapper () {
    this.name = "ww";
    this.begin = function () {
        // this.args = ???
        uut.begin ();
    };
    this.finish = function () {
        uut.finish ();
    };
    this.isValidETagForUUT = isValidETagForUUT;
    this.isInputETag = isInputETag;
    this.send = function (etag, v) {
        if (this.isValidETagForUUT (etag)) {
            var m = new message.OutputMessageNoTrace (etag, v, this.name, undefined);
            this.uut.handler (this.uut, m);
        } else {
            console.error (`invalid input message ${message.etag}`);
        }
    };
    this._done = false;
    this.conclude = function () { 
        this.container._done = true; 
    };
    this.done = function () {return this._done;};
    this.route = function () {
        if (this.tracing) {
            destructivelyDisplayAllOutputsForAllChildren (this);
        }
    };    
    this.step = function () {
        this.uut.step ();
        this.route ();
    };    
    this.uut =  new write.Write (this);
    this.children = [{name: "uut", runnable: this.uut}];
}

function isValidETagForUUT (etag) {
    if (this.isInputETag (etag)) {
        return true;
    } else {
        return false;
    }
}

function isInputETag (etag) {
    var inputs = this.uut.signature.inputs;
    return inputs.some (input =&gt; { return (etag === input.name); });
}

function destructivelyDisplayAllOutputsForAllChildren (me) {
    me.children.forEach (child =&gt; {
        var r = child.runnable;
        displayAllOutputs (r);
        r.resetOutputQueue ();
    });
}

function displayAllOutputs (child) {
    child.outputQueue.forEach (m =&gt; {
        console.log (`${child.name} outputs ${recursiveDisplay (m)}`);
    })
}

function recursiveDisplay (m) {
    if (m) {
        return `(${m.comefrom}::[${m.kind}]${m.etag}:${m.data}:${recursiveDisplay (m.tracer)})`;
    } else {
        return '.';
    }
}

exports.WriteWrapper = WriteWrapper;
</code></pre></div></div>

<h3 id="appendix-topwrapper">Appendix ‚ÄúTopWrapper‚Äù</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var top = require ('./top');
var message = require ('./message');

function TopWrapper (infname, outfname) {
    this.name = "tw";
    this.tracing = false;

    this.begin = function (infname, outfname) {
        this.uut.begin (this.uut, infname, outfname);
    };
    this.finish = function () {
        this.uut.finish (this.uut);
    };
    this.isValidETagForUUT = isValidETagForUUT;
    this.isInputETag = isInputETag;
    this.send = function (etag, v) {
        if (this.isValidETagForUUT (etag)) {
            var m = new message.OutputMessageNoTrace (etag, v, this.name, undefined);
            this.uut.handler (this.uut, m);
        } else {
            console.error (`invalid input message ${message.etag}`);
        }
    };
    this._done = false;
    this.conclude = function () { 
        this.container._done = true; 
    };
    this.done = function () {return this._done;};
    this.route = function () {
        destructivelyDisplayAllOutputsForAllChildrenAndDestroy (this);
    };    
    this.step = function () {
        this.uut.step ();
        if (this.tracing) {
            recursiveTraceOutput (this.uut);
        }
        this.route ();
    };    
    this.uut =  new top.Top (this);
    this.handler = this.step;
    this.children = [{name: "uut", runnable: this.uut}];
    this.route = function () {
        this.uut.route ();
    }
}

function isValidETagForUUT (etag) {
    if (this.isInputETag (etag)) {
        return true;
    } else {
        return false;
    }
}

function isInputETag (etag) {
    var inputs = this.uut.signature.inputs;
    return inputs.some (input =&gt; { return (etag === input.name); });
}

function destructivelyDisplayAllOutputsForAllChildren (me) {
    me.children.forEach (child =&gt; {
        var r = child.runnable;
        displayAllOutputs (r);
        r.resetOutputQueue ();
    });
}

function displayAllOutputsForAllChildren (me) {
    me.children.forEach (child =&gt; {
        displayAllOutputs (child.runnable);
    });
}

function displayAllOutputs (runnablechild) {
    runnablechild.outputQueue.forEach (m =&gt; {
        console.log (`${runnablechild.name} outputs ${recursiveDisplay (m)}`);
    })
}

function recursiveDisplay (m) {
    if (m) {
        return `(${m.comefrom}::[${m.kind}]${m.etag}:${m.data}:${recursiveDisplay (m.tracer)})`;
    } else {
        return '.';
    }
}

function recursivelyDisplayAllOutputsForAllChildren (me) {
    recursiveTraceOutput (me.uut);
}

function recursiveTraceOutput (me) {
    displayAllOutputsForAllChildren (me);
    me.children.forEach (childobject =&gt; {
        recursiveTraceOutput (childobject.runnable);
    });
}

exports.TopWrapper = TopWrapper;
</code></pre></div></div>

<h3 id="appendix-testjs">Appendix ‚ÄúTest.js‚Äù</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
function testRead () {
    var rw = require ('./readwrapper');
    var testHarness = new rw.ReadWrapper ();
    testHarness.send ("filename", "test.txt");
    while (!testHarness.done ()) {
        testHarness.send ("req", true); 
        testHarness.step ();
        testHarness.route ();
    }
}

function testWrite () {
    var ww = require ('./writewrapper');
    var testHarness = new ww.WriteWrapper ();
    testHarness.send ("filename", "test.out");
    testHarness.step ();
    testHarness.route ();
    testHarness.send ("char", "x");
    testHarness.step ();
    testHarness.route ();
    testHarness.send ("char", "y");
    testHarness.step ();
    testHarness.route ();
    testHarness.send ("char", "z");
    testHarness.step ();
    testHarness.route ();
}

function testContainer () {
    var tw = require ('./topwrapper');
    var testHarness = new tw.TopWrapper ();
    
    //testHarness.tracing = true;
    
    testHarness.begin ('test.txt', 'test.out');
    testHarness.route ();

    while (!testHarness.done ()) {
        testHarness.step ();
        testHarness.route ();
    }
}

console.log ();
console.log ('read ...');
testRead ();

console.log ();
console.log ('write ...');
testWrite ();

console.log ();
console.log ();
console.log ('top ...');
testContainer ();
</code></pre></div></div>

<h2 id="see-also">See Also</h2>

<p><a href="https://guitarvydas.github.io/2022/03/20/ƒó-Concurrent-Lambdas.html">ƒó - Concurrent Lambdas Working Paper 1</a></p>

<p><a href="https://guitarvydas.github.io/2022/04/11/ƒó-Working-Paper-2.html">ƒó - Concurrent Lambdas Working Paper 2</a></p>

<p><a href="https://guitarvydas.github.io/2021/12/10/Table-of-Contents-Dec-01-2021.html">Table of Contents as of Dec. 01 2021</a><br />
<a href="https://guitarvydas.github.io">Blog</a><br />
<a href="https://www.youtube.com/channel/UC9EJr0nKHwadbHUtc5zHdmQ/videos">Videos</a><br />
<a href="https://guitarvydas.github.io/2021/01/14/References.html">References</a><br />
<a href="https://leanpub.com/u/paul-tarvydas.html">Books</a></p>

<script src="https://utteranc.es/client.js" repo="guitarvydas/guitarvydas.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous"> 
</script>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:sev" role="doc-endnote">
      <p>Or several of its children tell it to stop‚Ä¶¬†<a href="#fnref:sev" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:turtles" role="doc-endnote">
      <p>‚ÄúTurtles all the way down‚Äù. https://en.wikipedia.org/wiki/Turtles_all_the_way_down.¬†<a href="#fnref:turtles" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET