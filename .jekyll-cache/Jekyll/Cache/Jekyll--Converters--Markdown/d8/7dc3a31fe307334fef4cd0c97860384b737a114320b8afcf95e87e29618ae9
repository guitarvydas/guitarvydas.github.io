I"y<h1 id="happy-path-culture">Happy Path Culture</h1>

<p>Programming suffers from <em>happy path culture</em> - a form of chauvanism that denies that design errors can happen.</p>

<p>It is <em>assumed</em> that a program will work.</p>

<p>The fact that most software doesn‚Äôt work until it leaves the development phase, has been largely ignored.</p>

<p>Many languages and tools are based on this happy path assumption, hence, emphasis has been placed on editing baubles (like auto-completion) and strong typing.</p>

<p>Early languages, esp. Lisp, emphasized debugging and what happens on paths other than the happy path.</p>

<h1 id="ux-psychology---if-it-does-everything-it-must-be-good-right">UX Psychology - If It Does Everything, It Must Be Good, Right?</h1>

<p>‚ÄúCorrect‚Äù programs might not correctly satisfy requirements.</p>

<p>Strong typing helps only with creating programs that satisfy the programmer‚Äôs idea of what the requirements are.</p>

<p>Strong typing can help with <em>brainstorming</em> the requirements, but only does so in an ad-hoc manner.</p>

<p>Maybe, we will never be able to formalize requirements, since requirements are given by humans and only a subset of those are Architects, Engineers and Implementors.</p>

<p>Agile and UML are attempts at formalizing the process of gathering and specifying requirements.</p>

<h2 id="the-universe-vs-the-drunkards-walk">The Universe vs. The Drunkard‚Äôs Walk</h2>

<p>It might be possible to define the <em>universe</em> of possible programming actions and languages.</p>

<p>This, though, is not the same as defining <em>useful subets</em> of the universe.</p>

<p>The goal of Designing solutions is to <em>choose</em> paths through the universe that make it easier to think about and express Architectures.</p>

<p>DI - Design Intent - is what successful Architects express.</p>

<p>Engineers ensure that all of the T‚Äôs are crossed and I‚Äôs dotted in an architecture.</p>

<p>Implementors create code from Engineering specifications.</p>

<p>The goal of the above activities it not to discard details, but to elide them and layer them so that the Design is understandable. [<em>Designs for practical solutions are rarely easy-to-understand.  Certain practices make them harder to comprehend while other practices make Designs easier to comprehend</em>.]</p>

<h2 id="implementation-languages">Implementation Languages</h2>

<p>Many of the current-day languages are targetted at implementation (Rust, Python, JS, Java, C, etc., etc. (if a language includes a <code class="language-plaintext highlighter-rouge">+</code> or allows definition of data structures, then it is an implementation language.))</p>

<h2 id="languages-for-di">Languages For DI</h2>

<p>I list some of the necessary features for languages that cater to Design Intent:</p>

<ul>
  <li>Low friction for creating Architectures.</li>
  <li>Low friction for abandoning code and rewriting it when design changes are recognized.</li>
  <li>Low friction to design iteration</li>
  <li>Isolation (build-and-forget).</li>
</ul>

<h1 id="see-also">See Also</h1>

<p><a href="https://guitarvydas.github.io/2021/06/06/Isolation-II.html">Isolation II</a></p>

<p><a href="https://guitarvydas.github.io/2021/06/07/Isolation-III.html">Isolation III</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/Isolation.html">Isolation</a></p>

<p><a href="https://guitarvydas.github.io">Blog</a><br />
<a href="https://guitarvydas.github.io/2021/01/14/References.html">References</a></p>

<script src="https://utteranc.es/client.js" repo="guitarvydas/guitarvydas.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async=""> 
</script>

:ET