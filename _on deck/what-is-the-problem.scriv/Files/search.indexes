<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="F92ACE99-7CDE-49FB-AA2D-DE122CB1BA31">
            <Title>Trajectory Calculation</Title>
            <Text>Trajectory calculation is a single-thread problem.

Do the math, return an answer.

</Text>
        </Document>
        <Document ID="ABDED7BA-AEDA-4D52-8E2C-2B8C9E76B804">
            <Text>What is the problem?

I see that computers are used for

	1)	mathematical calculations, e.g. trajectory calculation for ballistics
	2)	machine control.


</Text>
        </Document>
        <Document ID="ED99F516-32B0-4F86-ACC9-14E4F07B8F62">
            <Title>Machine Control</Title>
            <Text>Machine control is a parallel problem.

A solution to a parallel problem starts with a solution in the concurrent paradigm space.

</Text>
        </Document>
        <Document ID="940F1490-2B42-4729-AFA9-816B6DA55DB6">
            <Title>Using Single Threads to Solve a Concurrent Problem</Title>
            <Text>Solving a concurrent problem using a bunch of single threads leads to accidental complexity (as witnessed by multitasking libraries).

Solving a concurrent problem in the concurrent paradigm has a bad reputation, due to conflation of issues when trying to solve this same kind of problem using multiple non-concurrent threads.

Multitasking does not solve only the concurrent aspects of a problem, it conflates multiple problems &amp; optimizations together, e.g. concurrency, memory sharing, cpu sharing.  This conflation makes the problem harder to solve and leads to accidental complexity.  

Concurrency is easy, concurrency + memory sharing + cpu sharing is hard.</Text>
            <Comments>an optimization
an optimization</Comments>
        </Document>
    </Documents>
</SearchIndexes>