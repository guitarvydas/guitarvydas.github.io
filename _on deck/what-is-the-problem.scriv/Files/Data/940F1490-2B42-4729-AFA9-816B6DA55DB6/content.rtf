{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\froman\fcharset0 Palatino-Italic;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 Solving a concurrent problem using a bunch of single threads leads to accidental complexity (as witnessed by multitasking libraries).\
\
Solving a concurrent problem in the 
\f1\i concurrent paradigm
\f0\i0  has a bad reputation, due to conflation of issues when trying to solve this same kind of problem using multiple non-concurrent threads.\
\
Multitasking does not solve 
\f1\i only
\f0\i0  the concurrent aspects of a problem, it conflates multiple problems & optimizations together, e.g. concurrency, memory {\field{\*\fldinst{HYPERLINK "scrivcmt://37D153C5-0A9B-4336-AB5E-405A120BA95F"}}{\fldrslt sharing,}} cpu {\field{\*\fldinst{HYPERLINK "scrivcmt://13E8DC8D-7FD7-462E-AE1B-4A6E2FD0E6CB"}}{\fldrslt sharing}}.  This conflation makes the problem harder to solve and leads to accidental complexity.  \
\
Concurrency is 
\f1\i easy
\f0\i0 , concurrency + memory sharing + cpu sharing is 
\f1\i hard
\f0\i0 .}