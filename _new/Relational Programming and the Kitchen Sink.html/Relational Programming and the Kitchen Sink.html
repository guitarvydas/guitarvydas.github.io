<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Relational Programming and the Kitchen Sink</title>
	<meta name="author" content=""/>
</head>
<body>

<h1 id="everythingbutthekitchensink">Everything But The Kitchen Sink</h1>

<p>I use the phrase &#8220;everything but the kitchen sink&#8221; as an analogy.</p>

<p>In my words, the phrase means trying to do everything at once instead of partitioning the work.</p>

<p>Emacs is everything but the kitchen sink.</p>

<p>Most PLs are everything but the kitchen sinks.</p>

<p>IMO, everything is a fractal. Everything can be subdivided into smaller pieces.</p>

<p>IMO, programming tasks should be subdivided into smaller pieces.<a href="#fn:1" id="fnref:1" title="see footnote" class="footnote"><sup>1</sup></a></p>

<h1 id="relationalprogramming">Relational Programming</h1>

<p>I argue that we can strip relational programming down to its basics and that this will help us create code that creates code that …</p>

<p>The basics of relational programming are:</p>

<ol>
<li>exhaustive search</li>
<li>triples.</li>
</ol>

<p>Everything else is added, unnecessary, complexity.</p>

<p>We already know how to express both basics: (a) as loops of loops (but, the syntax is horrible) and (b) functions of exactly two arguments (not 0, not 1, not more than 2).</p>

<p>PROLOG, also, suggests a concise, human-readable, syntax for exhaustive search.</p>

<p>The easiest introduction to PROLOG that I have encountered is Nils Holm&#8217;s &#8220;Prolog Control in Six Slides&#8221;.</p>

<p>[In &#8220;Ohm in Small Steps&#8221;, I show one way to transpile Holm&#8217;s Scheme code to Javascript. The transpiler should port easily to other output languages that support anonymous functions.]</p>

<h1 id="thesoftwareatom">The Software ATOM</h1>

<p>In &#8220;Everything is a Fractal&#8221;, I mention relational programming.</p>

<p>My interest is in finding the atom of software.</p>

<p>Many languages have been invented, and each one purports to be The Answer (to software development).</p>

<p>Projectional editing consists of research into creating different views on code.</p>

<p>I believe that if we had an atom of software, we could create multiple views on the code (and the data) and we could create multiple languages for the same code and data. We could re-skin code at will.</p>

<p>I call such skins &#8220;SCNs&#8221; - Solution Centric Notations.<a href="#fn:2" id="fnref:2" title="see footnote" class="footnote"><sup>2</sup></a></p>

<h2 id="theatomofsoftware">The ATOM of Software</h2>

<p>I — currently — believe that triples are the ATOM of code and that relational programming shows us how to write low-level code and data in triple format.</p>

<p>In my words, an Atom is the smallest indivisible sub-part of a system.</p>

<p>In my view, everything is a fractal, so I believe that Atoms can be further subdivided.</p>

<p>From this perspective, an Atom is only meaningful in terms of a solution. An Atom is a point where the Architect / Engineer chose (v: to choose) to quit subdividing a sub-problem and chose to implement the solution to the sub-problem.</p>

<p>[Corollary: Different Architects might choose different sets of Atoms.]</p>

<h2 id="assembleratoms-isthereahigherlevel">Assembler ATOMS - Is There a Higher Level?</h2>

<p>Assembler is a triple-based language.</p>

<p>For example
MOV R1, R0
is a triple (!).</p>

<p>Techniques have been devised to write code that writes code, given assembler. Such techniques have been buried in compiler technology literature. I think that such tools and techniques need to be brought out and made available to all programmers, not just compiler-writers.</p>

<p>It is much easier to write code that writes code when the input has been normalized to triple form.</p>

<p>Some compiler technologies have leaked out to mortal programmers — e.g. REGEX.</p>

<p>Most compiler technology, though, remains shrouded in mystery.</p>

<p>Most programmers recognize and use the technology called gcc, but few know that it is based on early compiler peepholing techniques explored by Fraser and Davidson. That technology is called RTL.</p>

<p>Technologies, that look similarly useful, include Cordy&#8217;s OCG and Holt&#8217;s Data Descriptors. Holt&#8217;s/Cordy&#8217;s/Wortman&#8217;s S/SL is a forerunner to PEG-like technologies.</p>

<p>I believe that compiler parsing technologies are ripe for picking — e.g. PEG — and for making available to mortal programmers. Such technology needs to be REGEX&#8217;ed.</p>

<p>Since inventing assembler, we (the royal we) have found utility in inventing 1st-class functions, and, garbage collection, and, relational programming, and, …</p>

<p>Is there a triple-like notation that employs 1st-class functions and garbage collection? Early Lisp<a href="#fn:3" id="fnref:3" title="see footnote" class="footnote"><sup>3</sup></a> was an early form of this kind of thing. Relational Programming might give us some clues. OO and FP might give us clues. Closures and anonymous functions (found in Lisp, and more recent languages like JavaScript and Python) give us clues. Hierachical filesystems might give us a clue.</p>

<p>Of course, assembler can do any of the above, but it needs to be skinned for human readability and complexity management.</p>

<p>I favour the use of toolbox languages for building skins. Are there a toolbox languages that make building skins — SCNs — easier than using assembler?</p>

<p>We (the royal we) have spent a great deal of effort developing language skins aimed at human readability, and we have not spent much effort on developing languages for machine readability (Rebol and TXL are different takes on this subject).</p>

<h1 id="codethatwritescode">Code That Writes Code</h1>

<p>Note that I do not believe that the ATOM will result in human-readable code.</p>

<p>I want to write code that writes code.</p>

<p>Machine-readable is &#8220;better&#8221; than human-readable code, if one is trying to write code that writes code.</p>

<h1 id="fdd-failuredrivendesign">FDD - Failure Driven Design</h1>

<p>In another essay, I discuss FDD — Failure Driven Design.</p>

<p>When software works, we abandon it (&#8220;release&#8221; it).</p>

<p>When software doesn&#8217;t work, we work on it.</p>

<p>Most of the time, we work on failed code (design, code, etc.).</p>

<p>Relational programming ties in with FDD as one of the possible technologies for writing code that writes code.</p>

<h1 id="whatsmissingwhattothrowout">What&#8217;s Missing? What to Throw Out?</h1>

<p>The current forms of relational programming — PROLOG and miniKanren — have nothing missing.</p>

<p>I believe that relational programming languages encourage the use of too much detail.</p>

<p>Details kill.</p>

<p>A programming language, to be useful, needs to elide details (but not ignore them).</p>

<p>No language can be The One Language to Rule Them All.</p>

<p>We need a multiple skins — SCLs — that help us elide details in a problem-specific way.</p>

<p>The good part of relational programming is the notion that pattern-matching can be done automatically and under-the-hood.</p>

<p>The bad parts of relational programming are everything else.</p>

<p>For example, I would rather use printf to format output strings than trying to fit formatting into the relational paradigm (it is possible, but it is not pretty).</p>

<p>Relational programming should stick to triples only. Functors that have more than 2 arguments should not be used. (In fact, functors that have 0 or 1 arguments are questionable, too).</p>

<h1 id="patternmatching">Pattern Matching</h1>

<p>The latest crop of FP (functional programming) skins use pattern matching.</p>

<p>This technology was invented and explored in the 1960&#8217;s under the name of parsers.</p>

<p>Is FP the modern manifestation of pattern matching?</p>

<p>To use FP, you have to expunge time.</p>

<p>That&#8217;s a big hit.</p>

<p>FP, also, is based on a very old skin called mathematics. Mathematics was invented when all that we had was paper (and pencils and pens). We can build 2D skins using computers. We can build 3D skins using 3D printers (we can model 3D skins using CAD software).</p>

<p>IMO, PEG is the modern manifestation of pattern matching.</p>

<p>You can keep f(t) using parsers and PEG.</p>

<p>In fact, S/SL showed how to build f(t) processors.</p>

<p>(One can use pipelines to chain FP beads together into f(t) handlers).</p>

<h1 id="isolation-encapsulationisnotenough">Isolation - Encapsulation is Not Enough</h1>

<p>We (the royal we) invented isolation in the form of UNIX® processes and pipelines.</p>

<p>Then, we threw such isolation away and settled for encapsulation in the form of OO, etc.</p>

<p>We now know that encapsulation is not enough — we cannot bolt programs together in a care-free manner using only encapsulation.</p>

<p>We want to build-and-forget programs. We need to expunge inter-program dependencies. In other words, we want isolation.</p>

<p>Worse, yet, our present-day hardware creates dynamic dependency chains under-the-hood.</p>

<p>Our hardware just about forces us to produce CALL/RETURN Spaghetti.</p>

<p>Relational programming (and FP) gives us a way to talk about solutions that create no dependency chains.</p>

<p>Is that enough? No. But it&#8217;s a start.</p>

<p>Do we already have all of the pieces and Atoms that we need to propel programming into the future? Maybe.</p>

<h1 id="scns-onelanguagedoesnotfitall">SCNs - One Language Does Not Fit All</h1>

<p>Languages are skins.</p>

<p>I have a cavalier attitude towards languages, because I know that we can build notations (languages) in only a few hours.</p>

<p>I view notations like a bowl of candy sprinkles. Sprinkle several notations on every problem, to make the solution simpler to express, and, to program.</p>

<h1 id="humanreadabilityvs.machinereadability">Human Readability vs. Machine Readability</h1>

<p>The key to writing code that writes code is to cleave &#8220;Programming Languages&#8221; into two camps (maybe more, recursively):</p>

<ol>
<li>Programming Languages for Humans</li>
<li>Programming Languages for Machines.</li>
</ol>

<p>Programming Languages for Machines can lead to code that writes code, to projectional editing, etc.</p>

<p>A lot of techniques for writing code that writes code were explored in the early days of computing, under the name of compiler technologies.</p>

<p>Lisp macros are another manifestation of such technology.</p>

<p>[The problem with Lisp macros is that we tried to include compiler technology into the skins. This raised the (accidental) complexity of the problem. Combining technologies — flattening them — is almost always a bad idea.]</p>

<h1 id="thegoalofprogramming">The Goal of Programming</h1>

<p>The point of programming is to automate processes, using a computer.</p>

<p>All technologies for programming should strive to answer the question of how to automate a process using a computer.</p>

<h1 id="completenesstheoreticalapproachesprogramming">Completeness, Theoretical Approaches, Programming</h1>

<p>Many programmers feel that the &#8220;best&#8221; way to automate processes is to delve into all of the details in excruciating detail, in a non-hierarchical (flat) manner.</p>

<p>Language theories and skins for &#8220;proving&#8221; language designs.</p>

<p>We have seen progress on this front, but, it is obvious that this does not result in programming skins that are accessible to mortal programmers.</p>

<p>Language theory provides a solid description of the universe of programming languages, but, tends not to address the problems of finding expressible versions of skins that are &#8220;walks&#8221; through the universe.</p>

<p><img src="WalkingtheUniverse-Page-1.png" alt="" id="walkingtheuniverse-page-1" width="200" height="219" />
Fig. 1 Walks Through The Language Universe</p>

<p>Relational programming is (but) one manifestation of language theory.</p>

<p>Making something simpler is usually begun by starting out simple instead of by adding complexity.<a href="#fn:4" id="fnref:4" title="see footnote" class="footnote"><sup>4</sup></a></p>

<h1 id="throwingstuffout">Throwing Stuff Out</h1>

<p>To make language theory, and relational programming, useful to mortal programmers, we (the royal we) need to throw stuff out.</p>

<p>I suggest that we remove just about everything from relational programming, and leave only triples.</p>

<h1 id="denotationalsemantics-realisticcompilergeneration">Denotational Semantics - Realistic Compiler Generation</h1>

<p>Peter Lee&#8217;s book &#8220;Realistic Compiler Generation&#8221; shows how he managed an overtly complex technology — Denotational Semantics — by chopping it up into pieces, and pipelining the pieces.</p>

<p>Further work on this idea was performed by Uwe Pleban.</p>

<p>There is no need to devolve all of computing to the expression of Natural Numbers. Except in theoretical expressions of the Universe of Programming.</p>

<p>The goal of creating useful skins is to build a Component using hierarchies of isolated components and finding notations for the input and the output of each subdivision.</p>

<p>&#8220;Realistic Compiler Generation&#8221; shows but one set of possible skins for expressing denotational semantics in a useful form.</p>

<h1 id="engineering">Engineering</h1>

<p>Engineering is not coding.</p>

<p>Implementation is coding.</p>

<p>Engineering is the process of defining the details that lie between the Architecture and the Implementation.</p>

<p>As such, relational programming might lead to a skin(s) for expressing engineering concerns (in a hierarchical — divide-and-conquer — manner, composing isolated components together into a solution).</p>

<h1 id="noneedtowaitforcompleterigour">No Need To Wait For Complete Rigour</h1>

<p>Complete Rigour is certainly something to strive for, but, complete rigor is not necessary for delivering product.</p>

<p>In fact, if we&#8217;d waited for theoretically complete rigour, we would not have an electronics industry.<a href="#fn:5" id="fnref:5" title="see footnote" class="footnote"><sup>5</sup></a></p>

<p>Re-using what we&#8217;ve learned from various forms of Engineering — Civil, Structural, etc. Engineering — we see that we can deliver products without having an overall rigorous theory for the given domain.</p>

<p>My first full-time job was as a Software Test Engineer with Mitel Corp.</p>

<p>Mitel is a Telecom company (like Bell and NorTel, etc.). At the time, all Telecoms professed the four-nines principle — 99.99% uptime. People would telephone each other during power failures and not even notice that the telephone networks were still working, although the power grid had failed.</p>

<p>All of this was done with early computing technologies, and with software written in assembler and early programming languages — long before the advent of FP, Haskell, etc.</p>

<p>Testing. Most theorists look down on testing, but, testing can be used to create useful, and, saleable, and, guarantee-able products. To deliver products using only testing instead of rigorous theories, one needs to apply many layers of testing. CI/CD is only one form of testing (regression testing). Mitel used, at least, automated testing, analogue testing, back-to-back testing, trace analysis testing, etc., etc.</p>

<p>For Telecoms, and for current companies, rigorous theories can only serve to cost-reduce products by reducing testing costs (while increasing development costs and narrowing the kinds of programmers that can perform development tasks).</p>

<p>Can theories provide order-of-magnitude benefits, like PEG vs. YACC? Maybe, but, we are still waiting.</p>

<h1 id="das-diagramsassyntax">DaS - Diagrams as Syntax</h1>

<p>Relations make parsing diagrams &#8220;easy&#8221;.</p>

<p>Parsing a diagram consists of:</p>

<ul>
<li>normalizing the elements of a diagram (e.g. rectangles, ellipses, lines, text — in other words SVG simplified (see Throwing Stuff Out))</li>
<li>pattern-matching the elements</li>
<li>formatting output code.</li>
</ul>

<p>For example, a rectangle can be described as:</p>

<ul>
<li>a declaration of a unique ID</li>
<li>4 lines</li>
<li>x for each line</li>
<li>y for each line</li>
<li>width for each line</li>
<li>height for each line.</li>
</ul>

<p>To do this, we need:</p>

<ol>
<li>an editor — a simple<a href="#fn:6" id="fnref:6" title="see footnote" class="footnote"><sup>6</sup></a> diagram editor that allows creation rectangles, ellipses, lines (straight, curvy, arrow-headed), text</li>
<li>a transpiler that normalizes the output of the editor</li>
<li>a pattern matcher</li>
<li>an output code formatter.</li>
</ol>

<p>Step (2) converts the editor output into relational triples — a factbase.</p>

<p>Step (3) uses relational programming — e.g. PROLOG or miniKanren — to infer information about the diagram and the programming conventions.</p>

<p>Using modern-day computers, we can expend CPU power to perform step (3) at runtime, saving head-scratching during design- and compile- times.</p>

<p>[Q: Why do I champion triples instead of structured forms? A: Triples are more easily machine-readable than more elaborate data structures.]<a href="#fn:7" id="fnref:7" title="see footnote" class="footnote"><sup>7</sup></a></p>

<h1 id="appendix-everythingisafractal">Appendix - Everything is a Fractal</h1>

<p>https://guitarvydas.github.io/2021/03/23/Everything-is-a-Fractal.html</p>

<h1 id="appendix-prologprogrammingforprogrammers">Appendix - PROLOG Programming for Programmers</h1>

<p>https://www.youtube.com/channel/UC2bdO9l84VWGlRdeNy50fIg</p>

<h1 id="appendix-factbases">Appendix - Factbases</h1>

<p>https://guitarvydas.github.io/2021/01/17/Factbases.html</p>

<h1 id="appendix-triples">Appendix - Triples</h1>

<p>https://guitarvydas.github.io/2021/03/16/Triples.html</p>

<h1 id="appendix-languagesareskins">Appendix - Languages Are Skins</h1>

<p>https://guitarvydas.github.io/2020/12/09/Programming-Languages-Are-Skins.html</p>

<h1 id="appendix-scns-solutioncentricnotations">Appendix - SCNs - Solution Centric Notations</h1>

<p>https://guitarvydas.github.io/2021/04/10/SCN.html</p>

<p>https://guitarvydas.github.io/2020/12/09/DSL-Manifesto.html</p>

<h1 id="appendix-rtl">Appendix - RTL</h1>

<p>https://www.researchgate.net/publication/220404697_The_Design_and_Application_of_a_Retargetable_Peephole_Optimizer</p>

<h1 id="appendix-peg">Appendix - PEG</h1>

<p>https://guitarvydas.github.io/2020/12/27/PEG.html</p>

<p>https://guitarvydas.github.io/2021/03/17/PEG-vs.-Other-Pattern-Matchers.html</p>

<p>https://guitarvydas.github.io/2021/03/24/REGEX-vs-PEG.html</p>

<p>https://guitarvydas.github.io/2021/04/02/PEG-Cheat-Sheet.html</p>

<p>Ohm-JS (PEG for Javascript):</p>

<p>https://guitarvydas.github.io/2020/12/09/OhmInSmallSteps.html</p>

<p>https://github.com/harc/ohm</p>

<p>PEG for Lisp:
https://guitarvydas.github.io/2021/03/19/Racket-PEG.html</p>

<p>https://scymtym.github.io/esrap/</p>

<p>PEG for JS:
https://pegjs.org/</p>

<p>Thesis, etc.:</p>

<p>https://bford.info/packrat/</p>

<p>Note: I believe that the Ohm Editor is a breakthrough tool: https://ohmlang.github.io/editor/</p>

<p>[The Ohm Editor is an IDE for rapidly debugging PEG pattern-matching specs (aka grammars)]</p>

<p>What I do with Ohm-JS:</p>

<ul>
<li>Glue Tool (a PEG to help writing PEGs):

<ul>
<li>https://guitarvydas.github.io/2021/04/11/Glue-Tool.html</li>
</ul></li>
<li>Recursive Design

<ul>
<li>https://guitarvydas.github.io/2021/04/12/Recursive-Iterative-Design-By-Example.html</li>
<li>https://guitarvydas.github.io/2021/04/20/Recursive-Design,-Iterative-Design-By-Example-(2).html</li>
</ul></li>
<li>ASON parser (most of one):

<ul>
<li>https://guitarvydas.github.io/2021/04/10/ASON-Notation-Pipeline.html</li>
</ul></li>
<li>GRASEM Tool

<ul>
<li>https://guitarvydas.github.io/2021/04/11/Grasem.html</li>
</ul></li>
<li>etc.</li>
</ul>

<h1 id="appendix-ocg">Appendix - OCG</h1>

<p>https://books.google.ca/books?id=X0OaMQEACAAJ&amp;dq=bibliogroup:%22University+of+Toronto+Computer+Systems+Research+Institute+Technical+Report+CSRI%22&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwig1Legm8bqAhWvlHIEHYzzBYEQ6AEwBHoECAEQAQs</p>

<h1 id="appendix-ssl">Appendix - S/SL</h1>

<p>https://research.cs.queensu.ca/home/cordy/pub/downloads/ssl/</p>

<h1 id="appendix-datadescriptors">Appendix - Data Descriptors</h1>

<p>https://dl.acm.org/doi/abs/10.1145/24039.24051</p>

<h1 id="appendix-minikanren">Appendix - MiniKanren</h1>

<p>http://minikanren.org/</p>

<p>(must see, if you haven&#8217;t already heard about Barliman: https://www.youtube.com/watch?v=er_lLvkklsk (https://github.com/webyrd/Barliman))</p>

<h1 id="appendix-prolog">Appendix - PROLOG</h1>

<p>https://www.youtube.com/watch?v=QOYAHoLiyg0&amp;t=199s</p>

<p>modern PROLOG:
https://www.swi-prolog.org/</p>

<p>(gprolog uses WAM: http://www.gprolog.org/)</p>

<p>(beginnings of a WAM: https://github.com/guitarvydas/wam)</p>

<p>(WAM tutorial: http://wambook.sourceforge.net/)</p>

<h1 id="appendix-parsingdiagrams">Appendix - Parsing Diagrams</h1>

<p>https://guitarvydas.github.io/2021/04/11/Compiling-Diagrams.html</p>

<p>https://guitarvydas.github.io/2021/01/16/Transpiling-Diagrams-to-Code-101.html</p>

<p>https://guitarvydas.github.io/2021/01/24/Compiling-Diagrams-2.html</p>

<p>https://guitarvydas.github.io/2021/03/16/component-diagrams.html</p>

<p>https://guitarvydas.github.io/2021/01/12/Transpiling-Diagrams-to-Code-101.html</p>

<p>https://guitarvydas.github.io/2021/01/10/Transpiling-Diagrams-Overview.html</p>

<p>https://guitarvydas.github.io/2020/12/09/Parsing-and-Compiling-Diagrams.html</p>

<p>https://guitarvydas.github.io/2020/12/09/Diagram-Based-Languages.html</p>

<p>https://guitarvydas.github.io/2020/12/09/Editor-for-Gratoms.html</p>

<h1 id="appendix-toolboxlanguages">Appendix - Toolbox Languages</h1>

<p>https://guitarvydas.github.io/2021/03/16/Toolbox-Languages.html</p>

<h1 id="appendix-txl">Appendix - TXL</h1>

<p>https://www.txl.ca/</p>

<h1 id="appendix-rebolason">Appendix - Rebol, ASON</h1>

<p>https://en.wikipedia.org/wiki/Rebol</p>

<p>http://www.rebol.com/</p>

<p>https://github.com/rebol/rebol</p>

<p>https://github.com/red/red/blob/master/README.md#red-programming-language</p>

<p>ASON
https://altscript.com/</p>

<h1 id="appendix-detailskill">Appendix - Details Kill</h1>

<p>https://guitarvydas.github.io/2021/03/17/Details-Kill.html</p>

<h1 id="appendix-isolation">Appendix - Isolation</h1>

<p>https://guitarvydas.github.io/2020/12/09/Isolation.html</p>

<p>https://guitarvydas.github.io/2020/12/09/Scalability.html</p>

<p>https://guitarvydas.github.io/2020/12/09/Scalability-II.html</p>

<h1 id="appendix-thestack">Appendix - The Stack</h1>

<p>ALGOL Bottleneck:
https://www.youtube.com/watch?v=NTdA4OljwVE</p>

<p>https://guitarvydas.github.io/2020/12/25/The-ALGOL-Bottleneck.html</p>

<p>The Stack:
https://guitarvydas.github.io/2020/12/27/The-Stack-2.html</p>

<p>https://guitarvydas.github.io/2020/12/25/The-Stack.html</p>

<p>https://guitarvydas.github.io/2021/02/25/The-Stack-is-a-Global-Variable-(again).html</p>

<p>https://guitarvydas.github.io/2020/12/24/The-Stack-is-a-List.html</p>

<p>https://guitarvydas.github.io/2020/12/09/Type-Stacks.html</p>

<p>https://guitarvydas.github.io/2020/12/09/Two-Stacks-For-Every-Type.html</p>

<h1 id="appendix-realisticcompilergeneration">Appendix - Realistic Compiler Generation</h1>

<p>https://www.amazon.ca/Realistic-Compiler-Generation-Peter-Lee/dp/0262121417</p>

<h1 id="appendix-visualprogramming">Appendix - Visual Programming</h1>

<p>https://www.youtube.com/watch?v=2uw2W0w5oU8</p>

<h1 id="appendix-continuumbetweencompile-timeandrun-time">Appendix - Continuum Between Compile-time and Run-time</h1>

<p>https://guitarvydas.github.io/2020/12/09/Efficiency.html</p>

<h1 id="appendix-codethatwritescode">Appendix - Code That Writes Code</h1>

<p>[essay to come, for now see examples]</p>

<p>https://guitarvydas.github.io/2021/04/11/Glue-Tool.html</p>

<h1 id="appendix-toolboxlanguages">Appendix - Toolbox Languages</h1>

<p>https://guitarvydas.github.io/2021/03/16/Toolbox-Languages.html</p>

<h1 id="appendix-callreturnspaghetti">Appendix - Call Return Spaghetti</h1>

<p>https://guitarvydas.github.io/2020/12/09/CALL-RETURN-Spaghetti.html</p>

<h1 id="appendix-fdd-failuredrivendevelopment">Appendix - FDD - Failure Driven Development</h1>

<p>see the essay &#8220;Failure Driven Development&#8221; on https://guitarvydas.github.io/</p>

<h1 id="appendix-prologcontrolin6slides">Appendix - Prolog Control in 6 Slides</h1>

<p>https://www.t3x.org/bits/prolog6.html</p>

<h1 id="appendix-otherreferences">Appendix - Other References</h1>

<p>https://www.youtube.com/channel/UC2bdO9l84VWGlRdeNy50fIg</p>

<p>https://guitarvydas.github.io/2020/12/09/References.html</p>

<p>FBP (Flow-Based Programming, concurrency, diagrams)</p>

<ul>
<li>https://jpaulm.github.io/fbp/</li>
</ul>

<p>noFlo</p>

<ul>
<li>https://noflojs.org/</li>
</ul>

<ol>
<li>(experimental code, many branches)</li>
</ol>

<ul>
<li>https://github.com/bmfbp/bmfbp</li>
</ul>

<h1 id="appendix-everythingbutthekitchensink">Appendix - Everything but the Kitchen Sink</h1>

<p>https://www.theidioms.com/everything-but-the-kitchen-sink/</p>

<div class="footnotes">
<hr />
<ol>

<li id="fn:1">
<p>Until the pieces are so small that they can be implemented in only a few hours. (Two weeks is too long &#8211; and indicates that more subdivision is necessary). <a href="#fnref:1" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:2">
<p>I believe that SCNs are orders&#8211;of&#8211;magnitude cheaper to build than DSLs and PLs (Domain&#8211;Specific Languages and Programming Languages, resp.). I discuss this elsewhere (see appendix). <a href="#fnref:2" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:3">
<p>But, then, Lisp was beat into the ground with complexity&#8211;hammers and became Common Lisp. <a href="#fnref:3" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:4">
<p>Although simplication is a factor https://en.wikipedia.org/wiki/William<em>Bushnell</em>Stout#:~:text=published%20in%201951.&#8211;,Legacy,Colin%20Chapman%20of%20Lotus%20Cars.
Computers are &#8220;complex&#8221; to begin with. They need to be skinned to allow access to them by mere mortals. Simplication. Likewise, CPUs are complex and are simplicated (from various kinds of rust to ICs by electronics chip manufacturers) for use by programmers. <a href="#fnref:4" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:5">
<p>Aside: Scientists like to talk about a TOE (a Theory of Everything), but, this will not be possible until Science can explain consciousness (among other factors) without hand&#8211;waving arguments like &#8220;emergent properties&#8221;. <a href="#fnref:5" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:6">
<p>Most existing diagram editors are much too complex. Details kill. <a href="#fnref:6" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:7">
<p>Machines can structure data for us, at runtime. I think of a continuum between compile&#8211;time and run&#8211;time. In fact, all software is interpreted, anyway (a CPU is an interpreter). The only question is &#8220;when does the interpretation happen?&#8221; <a href="#fnref:7" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

</ol>
</div>

</body>
</html>

