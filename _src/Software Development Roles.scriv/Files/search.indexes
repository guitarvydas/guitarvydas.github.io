<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="96012CEE-EE3C-4770-8289-B0ADE0577617">
            <Title>Software Development Roles (2)</Title>
            <Text>I break down Software Development down into, roughly, three main roles:

Software Architecture
Software Engineering
Software Implementation

Each role breaks down into sub-roles (see section Roles).

I fashion this breakdown by observing the breakdown in traditional engineering - e.g. structural.



Coding is done only by Software Implementors.  Software Architects produce the initial design, Software Engineers look after details and Software Implementors write the actual code.



Testing requires someone to think deeply about what it means to test the product, and creating procedures for testing.

Thinking about testing means, at least:

thinking about how to test bought-in code, e.g. libraries, code from GitHub
thinking about white box testing
thinking about black box testing
thinking about system testing
thinking about Q/A - quality assurance
thinking about certification (where applicable).

Traditionally, all of the above work has been done by implementors, often called engineers (a mis-nomer).

Conflating work is a sure way to lengthen deadlines.

Some people are good at thinking about libraries (and knowing what exists and what to avoid), some people are good at black box testing, etc.  Forcing one person, or one group, to deal with all of the issues produces uneven results and scheduling problems.



Architect







abc	def ghi
jkl	mno	pqr





Software Development Roles
Software Development Roles</Text>
        </Document>
        <Document ID="D29DE8D4-12C8-44B0-9C74-32D9DFFF069E">
            <Title>Software Development Roles</Title>
            <Text>Role Sub-role
Sheet1
Technologies
   Software Architecting
 multiple paradigms
     whiteboards
 diagrams
 code snippets
 pseudo code
 DSLs
  Drakon
StateCharts
UML
indirection
  UX Architect
 UX design is a divide-and- conquer activity
     Humane Interface (Jef Raskin)
 Engineering
 Realization Engineering
  Correctness Engineering
 proofs, etc.
 UX Engineer
    Error Handler Engineer
 Throw / catch Signals Events
A.O.C. (Aspect Oriented Pro- gramming)
 Maintenance Engineer
Page 1

 Optimization Engineer
Sheet1
Refactoring D.R.Y.
Profiling
Incoming Test
Black Box Testing White Box Testing Q/A
Scripting Back-to-back testing Sikuli
CD Dashboards CI
Hardware production test used HP Trace Analyzers that would generate a GUID for every test (including sequen- cing over time) for a “golden unit” (known to be good), when GUID didn’t match in production unit, then further testing was used to determine where the fault was (kind of a Canary CI, replacing Unit test with faster/cheaper tests which signalled Go/no-go
 Security Engineering Test Engineer
 Release Engineer
 Implementation
 Q/A Maintenance Testing
Teaching Software to only) Children
  different set of concerns than providing tools to Pro- fessionals
Rhetorical Question: would you drive across a bridge de- signed by a gifted child?
 Software for Business
 Word
Rhetorical Question: would you drive across a bridge de- signed by a Professional who isn’t an Engineer? E.g. a Dentist?
Page 2

Sheet1
 Excel Visio Scapple Scrivener
 Software for Domain Experts (not Pro- grammers)
HyperCard VisiCalc
people with expertise who see a need and want to learn “just enough” pro- gramming to fill that need
transitional (only)
desktop
filing cabinet typewriter
TV schedule magazine articles typewriter keyboard house phone
retail
libraries
expensive all-in-1 com- puters
desk calculator
piano
recording soundboard (e.g. mimiced by GarageBand, ProTools)
audio
whiteboard office house
automobile
e.g. accounting software
absolute addressing grid layout (VisiCalc) fixed layout (HyperCard) few options
“obvious”
will be supplanted by designs based on computing-driven Paradigms
 Software Designs Based on Existing Paradigms
Page 3

comments
not a single paradigm purveyor
Sheet1
    generalist
        shows ability to view problem from many angles
 http://drakon-editor.sourceforge.net/
    design a rudimentary piece of the UX
 test it (for UX-ness, not for robustness) before proceeding
 final design will be a composition of the various pieces
 once designed, Engineering makes it practical and robust
    define first-cut of realized architecture
iterate design with Architect until realizable and all I’s dotted and T’s crossed
    define parameters &amp; timing for responsiveness
 usability testing
 feedback to UX architect
 analyze testability of product ( &amp; suggest
 changes)
create procedures / scripts for Q/A
 Page 4

 remove Architectural indirection if appropriate
Sheet1
        Page 5

   New paradigm: Netflix
New paradigm: blogs
New paradigm: tablet, phone
New paradigm: iPhone
New paradigm: Amazon
New paradigm: internet
New paradigm: what is the new O/S? Do we need an O/S?
New paradigm: IoT
loops
new paradigm: video+audio, YouTube New paradigm: ?
New paradigm: WFH
New paradigm: condo
New paradigm: bicycle, fat bike, ebike, public transit
Sheet1
Page 6

Sheet1
    counter e.g. everything is Haskell – no
c.e.g. everything is an Object – no
 c.e.g. everything is &lt;xxx&gt; - no
             earliest drafts tested by Architect and Engineers ; later drafts tested by Customer (Stakeholder)
               Page 7

  test suitability of all bought-in technologies (e.g. code from GitHub)
devise ways to break product
large systems can feed inputs to same kinds of systems
Sheet1
       Page 8
</Text>
        </Document>
        <Document ID="11E22C4A-BA40-411B-AEAB-D8AD21F5D5E9">
            <Title>wip</Title>
        </Document>
        <Document ID="E97065B0-D91E-4DBE-B2E6-581206E9B29F">
            <Title>Roles</Title>
            <Text>
Role
Sub-role
technologies
comments
Software Architecting





multiple paradigms




generalist



must understand multiple paradigms



c.e.g. (counter e.g.) everything is Haskell – no



c.e.g. everything is an Object – no



c.e.g. everything is &lt;xxx&gt; - no






whiteboards



diagrams



code snippets



pseudo code



SCLs
like DSLs, except more focussed



shows ability to view problem from many angles


Drakon
http://drakon-editor.sourceforge.net/


StateCharts



UML



indirection


UX Architect




UX design is a divide-and-conquer activity




design a rudimentary piece of the UX



test it (for UX-ness, not for robustness) before proceeding



(earliest drafts tested by Architect and Engineers ; later drafts tested by Customer (Stakeholder)



once designed, Engineering makes it practical and robust


Humane Interface 
Jef Raskin


The Design of Everyday Things
Donald Norman
Engineering




Realization Engineering





define first-cut of realized architecture



iterate design with Architect until realizable and all I’s dotted and T’s crossed

Correctness Engineering




proofs, etc.


UX Engineer





define parameters &amp; timing for responsiveness



usability testing



feedback to UX architect

Error Handler Engineer





analyze testability of product ( &amp; suggest changes)



create procedures / scripts for Q/A


Throw / catch



Signals



Events



A.O.C. (Aspect Oriented Programming)


Maintenance Engineer




Refactoring



D.R.Y.


Optimization Engineer




Profiling




remove Architectural indirection if appropriate

Security Engineering



Test Engineer




Incoming Test
test suitability of all bought-in technologies (e.g. code from GitHub)


Black Box Testing



White Box Testing



Q/A
devise ways to break product


Scripting



Back-to-back testing
large systems can feed inputs to same kinds of systems


Sikuli


Release Engineer




CD



Dashboards



CI

Implementation




Q/A



Maintenance



Testing




Hardware production test used HP Trace Analyzers that would generate a GUID for every test (including sequencing over time) for a “golden unit” (known to be good), when GUID didn’t match in production unit, then further testing was used to determine  where the fault was (kind of a Canary CI, replacing Unit test with faster/cheaper tests which signalled Go/no-go only)
Teaching Software to Children





different set of concerns than providing tools to Professionals



Rhetorical Question: would you drive across a bridge designed by a gifted child?
Software for Business &amp; non-programmers





Rhetorical Question: would you drive across a bridge designed by a Professional who isn’t an Engineer?  E.g. a Dentist?

Word



Excel



Visio



Scapple



Scrivener


Software for Domain Experts (not  Programmers)




people with expertise who see a need and want to learn “just enough” programming to fill that need

e.g. accounting software


HyperCard



VisiCalc



absolute addressing



grid layout (VisiCalc)



fixed layout (HyperCard)



few options



“obvious”





Software Designs Based on Existing Paradigms

 
 
 

transitional (only)


will be supplanted by designs based on computing-driven paradigms


desktop



filing cabinet



typewriter



Netflix
old, but similar paradigm: TV


blogs

old: magazine articles


tablet, phone
old: typewriter keyboard


cell phone
old: home phone


Amazon
old: retail


internet
old: libraries



old: do we need an O/S?


IoT
old: expensive all-in-one computers



old: desk calculator


loops
old: piano



old: recording soundboard (e.g. mimicked by GarageBand, ProTools)


video+audio, YouTube
old: audio



old: whiteboard


WFH
old: office

 
condo
old: house


bicycle, fat bike, ebike, public transit
old: automobile
</Text>
        </Document>
        <Document ID="084AAB17-EA57-4480-9649-8376A3EBD447">
            <Title>Testing</Title>
            <Text>Testing requires someone to think deeply about what it means to test the product, and creating procedures for testing.

Thinking about testing means, at least:

	•	thinking about how to test bought-in code, e.g. libraries, code from GitHub
	•	thinking about white box testing
	•	thinking about black box testing
	•	thinking about system testing
	•	thinking about Q/A - quality assurance
	•	thinking about certification (where applicable)
	•	thinking about security.

Traditionally, all of the above work has been done by implementors, often called engineers (a mis-nomer).

Conflating work is a sure way to lengthen deadlines.

Some people are good at thinking about libraries (and knowing what exists and what to avoid), some people are good at black box testing, etc.  Forcing one person, or one group, to deal with all of the issues produces uneven results and scheduling problems.
</Text>
        </Document>
        <Document ID="3EBE5272-4893-4C5A-890F-0D1EAF929887">
            <Title>Coding</Title>
            <Text>Coding is done only by Software Implementors.  Software Architects produce the initial design, Software Engineers look after details and Software Implementors write the actual code.

</Text>
        </Document>
        <Document ID="40EABBBD-3BA0-44BB-B2BD-5EABCF5F8FC4">
            <Title>Introduction</Title>
            <Text>I break down Software Development down into, roughly, three main roles:

	1.	Software Architecture
	2.	Software Engineering
	3.	Software Implementation

Each role breaks down into sub-roles (see section Roles).

I fashion this breakdown by observing the breakdown in traditional engineering - e.g. structural architecture/engineering/construction.

</Text>
        </Document>
        <Document ID="4AC93B09-74E7-4376-B678-99CF21B0E569">
            <Title>Software Development Roles</Title>
            <Text>Role Sub-role
Sheet1
Technologies
   Software Architecting
 multiple paradigms
     whiteboards
 diagrams
 code snippets
 pseudo code
 DSLs
  Drakon
StateCharts
UML
indirection
  UX Architect
 UX design is a divide-and- conquer activity
     Humane Interface (Jef Raskin)
 Engineering
 Realization Engineering
  Correctness Engineering
 proofs, etc.
 UX Engineer
    Error Handler Engineer
 Throw / catch Signals Events
A.O.C. (Aspect Oriented Pro- gramming)
 Maintenance Engineer
Page 1

 Optimization Engineer
Sheet1
Refactoring D.R.Y.
Profiling
Incoming Test
Black Box Testing White Box Testing Q/A
Scripting Back-to-back testing Sikuli
CD Dashboards CI
Hardware production test used HP Trace Analyzers that would generate a GUID for every test (including sequen- cing over time) for a “golden unit” (known to be good), when GUID didn’t match in production unit, then further testing was used to determine where the fault was (kind of a Canary CI, replacing Unit test with faster/cheaper tests which signalled Go/no-go
 Security Engineering Test Engineer
 Release Engineer
 Implementation
 Q/A Maintenance Testing
Teaching Software to only) Children
  different set of concerns than providing tools to Pro- fessionals
Rhetorical Question: would you drive across a bridge de- signed by a gifted child?
 Software for Business
 Word
Rhetorical Question: would you drive across a bridge de- signed by a Professional who isn’t an Engineer? E.g. a Dentist?
Page 2

Sheet1
 Excel Visio Scapple Scrivener
 Software for Domain Experts (not Pro- grammers)
HyperCard VisiCalc
people with expertise who see a need and want to learn “just enough” pro- gramming to fill that need
transitional (only)
desktop
filing cabinet typewriter
TV schedule magazine articles typewriter keyboard house phone
retail
libraries
expensive all-in-1 com- puters
desk calculator
piano
recording soundboard (e.g. mimiced by GarageBand, ProTools)
audio
whiteboard office house
automobile
e.g. accounting software
absolute addressing grid layout (VisiCalc) fixed layout (HyperCard) few options
“obvious”
will be supplanted by designs based on computing-driven Paradigms
 Software Designs Based on Existing Paradigms
Page 3

comments
not a single paradigm purveyor
Sheet1
    generalist
        shows ability to view problem from many angles
 http://drakon-editor.sourceforge.net/
    design a rudimentary piece of the UX
 test it (for UX-ness, not for robustness) before proceeding
 final design will be a composition of the various pieces
 once designed, Engineering makes it practical and robust
    define first-cut of realized architecture
iterate design with Architect until realizable and all I’s dotted and T’s crossed
    define parameters &amp; timing for responsiveness
 usability testing
 feedback to UX architect
 analyze testability of product ( &amp; suggest
 changes)
create procedures / scripts for Q/A
 Page 4

 remove Architectural indirection if appropriate
Sheet1
        Page 5

   New paradigm: Netflix
New paradigm: blogs
New paradigm: tablet, phone
New paradigm: iPhone
New paradigm: Amazon
New paradigm: internet
New paradigm: what is the new O/S? Do we need an O/S?
New paradigm: IoT
loops
new paradigm: video+audio, YouTube New paradigm: ?
New paradigm: WFH
New paradigm: condo
New paradigm: bicycle, fat bike, ebike, public transit
Sheet1
Page 6

Sheet1
    counter e.g. everything is Haskell – no
c.e.g. everything is an Object – no
 c.e.g. everything is &lt;xxx&gt; - no
             earliest drafts tested by Architect and Engineers ; later drafts tested by Customer (Stakeholder)
               Page 7

  test suitability of all bought-in technologies (e.g. code from GitHub)
devise ways to break product
large systems can feed inputs to same kinds of systems
Sheet1
       Page 8
</Text>
        </Document>
        <Document ID="D66F039B-7EDB-4983-9AAD-8B8D5485BB72">
            <Title>Software Development Roles</Title>
            <Text>Role Sub-role
Sheet1
Technologies
comments
    Software Architecting
 multiple paradigms
 generalist
not a single paradigm purveyor
    whiteboards
 diagrams
 code snippets
 pseudo code
 DSLs
 shows ability to view problem from many angles
 Drakon http://drakon-editor.sourceforge.net/
StateCharts
UML
indirection
  UX Architect
 UX design is a divide-and- conquer activity
 design a rudimentary piece of the UX
 test it (for UX-ness, not for robustness) before proceeding
 final design will be a composition of the various pieces
 once designed, Engineering makes it practical and robust
 Humane Interface (Jef Raskin)
 Engineering
 Realization Engineering
 define first-cut of realized architecture
iterate design with Architect until realizable and all I’s dotted and T’s crossed
 Correctness Engineering
Page 1

Sheet1
 proofs, etc.
 UX Engineer
 define parameters &amp; timing for responsiveness
 usability testing
 Error Handler Engineer
analyze testability of product ( &amp; suggest
Throw / catch Signals Events
A.O.C. (Aspect Oriented Pro- gramming)
feedback to UX architect
  changes)
create procedures / scripts for Q/A
  Maintenance Engineer
 Optimization Engineer
Refactoring D.R.Y.
Profiling
Incoming Test
 Security Engineering Test Engineer
Black Box Testing White Box Testing Q/A
Scripting Back-to-back testing Sikuli
remove Architectural indirection if appropriate
 Release Engineer
CD Dashboards CI
 Implementation
 Q/A
Page 2

Sheet1
Hardware production test used HP Trace Analyzers that would generate a GUID for every test (including sequen- cing over time) for a “golden unit” (known to be good), when GUID didn’t match in production unit, then further testing was used to determine where the fault was (kind of a Canary CI, replacing Unit test with faster/cheaper tests which signalled Go/no-go
 Maintenance Testing
Teaching Software to only) Children
  different set of concerns than providing tools to Pro- fessionals
Rhetorical Question: would you drive across a bridge de- signed by a gifted child?
 Software for Business
 Word Excel Visio Scapple Scrivener
Rhetorical Question: would you drive across a bridge de- signed by a Professional who isn’t an Engineer? E.g. a Dentist?
 Software for Domain Experts (not Pro- grammers)
Page 3

HyperCard VisiCalc
people with expertise who see a need and want to learn “just enough” pro- gramming to fill that need
Sheet1
e.g. accounting software
absolute addressing grid layout (VisiCalc) fixed layout (HyperCard) few options
“obvious”
will be supplanted by designs based on computing-driven Paradigms
 Software Designs Based on Existing Paradigms
transitional (only)
desktop
filing cabinet typewriter
TV schedule magazine articles typewriter keyboard house phone
retail
libraries
expensive all-in-1 com- puters
desk calculator
piano
recording soundboard (e.g. mimiced by GarageBand, ProTools)
New paradigm: Netflix
New paradigm: blogs
New paradigm: tablet, phone
New paradigm: iPhone
New paradigm: Amazon
New paradigm: internet
New paradigm: what is the new O/S? Do we need an O/S?
New paradigm: IoT
loops
Page 4

audio whiteboard office house
automobile
new paradigm: video+audio, YouTube New paradigm: ?
New paradigm: WFH
New paradigm: condo
New paradigm: bicycle, fat bike, ebike, public transit
Sheet1
Page 5

   counter e.g. everything is Haskell – no
c.e.g. everything is an Object – no
Sheet1
  c.e.g. everything is &lt;xxx&gt; - no
             earliest drafts tested by Architect and Engineers ; later drafts tested by Customer (Stakeholder)
       Page 6

          test suitability of all bought-in technologies (e.g. code from GitHub)
devise ways to break product
large systems can feed inputs to same kinds of systems
Sheet1
   Page 7
</Text>
        </Document>
    </Documents>
</SearchIndexes>