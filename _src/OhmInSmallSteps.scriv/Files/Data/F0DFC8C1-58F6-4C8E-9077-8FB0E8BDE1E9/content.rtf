{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Palatino-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 As it stands, prolog6 prints every answer (a successful match) in the function print-frame.\
\
I want to collect the answers into a list and return it, instead of printing it.\
\
I have a number of choices in how to do this.\
\
The first choice is whether the return will be a Cons() list or something more amenable to  JS - an array, for example.  The code generated by the transpiler will be used in JS programs.  The better choice seems to be that of returning a JS Array.\
The PROLOG code creates a Cons() list, though.  Returning a Cons() list will be easier.  Easy wins - I can always write a toArray method for Cons() - later.\
\
The next choice is how to accumulate the result.  The most obvious answer is to accumulate the result in some sort of global variable.  Alternately, I can accumulate the result in an accumulator list that is passed to prove6 and everything it calls.\
Again, "easy" wins out - I will choose to use a global variable.\
Rhetorical question, for discussion - when is it OK to use a global instead of using an accumulator parameter?  For discussion: \
\pard\tx220\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\li720\fi-720\sl264\slmult1\pardirnatural\partightenfactor0
\ls1\ilvl0\cf0 {\listtext	\uc0\u8226 	}using parameters instead of globals evolved as a protectionist strategy when text-only code was used.  \
{\listtext	\uc0\u8226 	}Further: using parameters instead of globals evolved as a protectionist strategy when code "freezing" was not possible - e.g. when the programmer doesn't know how the code will be used.  \
{\listtext	\uc0\u8226 	}Further: using parameters instead of globals evolved in an environment where the only tools & languages available could cause subtle changes to behaviour.  \
{\listtext	\uc0\u8226 	}Further: the use of parameters instead of globals converts globals into scoped parameters, to reduce the "problem" - the "problem" being that globals don't necessarily fit in an eye-full, whereas it is hoped that parameters do fit in an eye-full ; global variables are removed from the global scope and are moved into local scope.  The concept of modules solved this problem by wrapping "global variables" into modules.  OO was, essentially, a riff on this theme - modules became objects that could be instantiated at runtime.  \
{\listtext	\uc0\u8226 	}Further: isn't the real problem one of freezing known-to-be-working code instead of a problem of scoping?\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0
\cf0 \
Divide & conquer - I choose to ignore the issue and proceed using the "least change" principal - i.e. the design is working, change as little code as possible.  Let Maintenance Engineering worry about this issue.  Can CI tools help us detect future problems?  (That is the claim :-).\
\
Next choice - do I make the change in JS or in Scheme?  I am treating Scheme as my meta-language.  Every change I make in Scheme will be reflected in the transpiled code, even when it is transpiled to something other than JS.  If I make the change in JS, then only the JS version has the fix and I will need to make the change in every target language.  This is the same issue that HLLs solved - one could write code in a meta-language (e.g. C) and have it be compiled to many various assembly languages.  Over time, we learned how to "standardize" languages so that they were more portable across target architectures.  An example of a successful standard is the Common Lisp standard - Cltl2.  An example of an evolving standard is the ECMAscript standards for JavaScript.\
\
So, my immediate goals are:\
\pard\tx220\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\li720\fi-720\sl264\slmult1\pardirnatural\partightenfactor0
\ls2\ilvl0\cf0 {\listtext	\uc0\u8226 	}collect answers in a Cons() list\
{\listtext	\uc0\u8226 	}use a global variable as the top-level accumulator of a list of answers\
{\listtext	\uc0\u8226 	}do all of this in Scheme - in prolog-6a.scm.  \
\pard\tx560\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\sl264\slmult1\pardirnatural\partightenfactor0
\cf0 \
The only remaining question is whether I need to make copies of the Cons() list answers.  I will defer this issue until I see good or broken results ; I have used Cons() lists in Lisp without needing to make copies, and I expect this to be the case here.\
}