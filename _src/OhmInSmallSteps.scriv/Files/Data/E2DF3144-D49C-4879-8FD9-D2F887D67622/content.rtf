{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\froman\fcharset0 Palatino-Italic;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 Append is missing.  I will write one in Scheme, called AppendInefficient, and replace all calls to Append by this - in the Scheme code.\
\
N.B. I am now 
\f1\i using
\f0\i0  the Scheme to JS transpiler.  I will write AppendInefficient in Scheme and let the transpiler convert it to JS.  There are some interesting trade-offs to be had when the transpiler begins to work (even hobbling).  Should I write Append() in JS or in Scheme?  Or, should I rewrite it in PROLOG?  I'm not worried about efficiency (yet), and I am very comfortable writing Scheme.  Writing it in Scheme will allow me to debug the implementation in a working compiler - MIT-Scheme.  \
\
Instead of dealing with varargs, I wrote AppendInefficient3 which is defined using AppendInefficient. \
\
In a sense, I'm using Scheme as a meta-language\'85\
\
}