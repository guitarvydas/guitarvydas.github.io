{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\deftab709
\pard\pardeftab709\sb240\sa120\qc\partightenfactor0

\f0\b\fs56 \cf0 Divide & Conquer is Recursive Design\
\pard\pardeftab709\partightenfactor0

\f1\b0\fs24 \cf0 Recursion is the process of \'93looping\'94 where the problem becomes simpler every time through the \'93loop\'94 and where there is a terminating case (something that stops the loop).\
\
Designing an application using divide & conquer is recursion.  The design is successively broken down into (1) a simple problem to be solved and, (2) the rest of the problem.\
\
The terminating case for divide & conquer is the decision that (2) is \'93so simple\'94 that it can be solved without further division.\
\
When we (my consulting company) built credit terminal applications, we used diagrams and a terminating case.\
\
The diagrams gave us a way to visualize divisions in divide and conquer.  Each sub-problem \'96 (1) \'96 became a box (literally, on a whiteboard, then on a diagram) containing a simple problem that could be solved.\
\
Our terminating case was: whether everyone in the room (e.g. 5-10 developers) agreed that all sub-problems could be coded up and solved in about 1/2 day.  That included alpha-testing, etc.\
\
In my opinion, a grain-size of 3 weeks for a \'93sprint\'94 in Agile methodology is too large.  The grain-size should be reduced to about 1/2 day (that is 3 weeks = 21 days * 2 = 42 chunks * number of developers).  Obviously, the customer cannot be consulted for every completed chunk (every grain, every terminating condition, every box).  This is where Agile does not use 
\i enough
\i0  divide and conquer and recursion.  A \'93sprint\'94 presented to a customer, should consist of many smaller chunks (grains, boxes).  Intermediate chunks can be \'93reviewed\'94 by the developer, every group of chunks can be reviewed by the team about once every few days, every group of group-of-chunks can be reviewed by technical management every week (or so) and every group of groups-of-groups-of-chunks can be reviewed by the product owner every couple of weeks. \
\
Programmers and technical leads and CTO\'92s already do something like this, implicitly.  They draw out their \'93design\'94 on a whiteboard in a meeting.  No one sits in a meeting longer than one hour.  The whiteboard represents the chunks \'96 the grains \'96 developers and tech leads in the meeting \'93approve\'94 of the chunks as being implementable in a finite amount of time, etc.  \
\
One hour is usually not enough to subdivide a problem into enough pieces.  The \'93terminating case\'94 is fuzzy and further subdivision is left up to the programmers.  In other words, the programmers do not just write code, but they, also finish designing the solution.  Some are better at this than {\field{\*\fldinst{HYPERLINK "scrivcmt://613B6C85-7878-4B23-BC76-427C2C58F8AD"}}{\fldrslt others.}}}