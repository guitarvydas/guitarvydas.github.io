{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid102\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid103\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid302\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid303\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid4}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}}
\deftab709
\pard\pardeftab709\sb240\sa120\qc\partightenfactor0

\f0\b\fs56 \cf0 Diagram Based Languages\
\pard\pardeftab709\sb140\sa120\partightenfactor0
\ls1\ilvl2
\f1\b0\fs24 \cf0 	
\f0\b\fs28 DaS\
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0

\f1\b0\fs24 \cf0 It is often believed that programming languages come in only 2 forms: (1) textual and (2) visual.\
Visual Programming has become to mean pixel-based image processing.\
I have implemented an intermediate form of programming.  Something between (1) textual and (2) pixel-based image {\field{\*\fldinst{HYPERLINK "scrivcmt://0078AA70-E4BA-43F0-8054-C446ED02E8E0"}}{\fldrslt processing.}}\
I call it DaS \'96 Diagram as Syntax.  It is 
\i diagrammatic programming
\i0 .  I used to call this \'93visual programming\'94, but that phrase has come to mean something else, something much harder to implement.\
\pard\pardeftab709\sb140\sa120\partightenfactor0
\ls2\ilvl2\cf0 	
\f0\b\fs28 aha\
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0

\f1\b0\fs24 \cf0 I backed into a number of design principles.  I will do my best to summarize them below...\
\pard\pardeftab709\li720\fi-360\sl276\slmult1\sa140\partightenfactor0
\ls3\ilvl0
\f0 \cf0 \'95	
\f1 Most programming languages and compilers are based on glyphs.  A 
\i character 
\i0 is a small bitmap.  A 
\i character 
\i0 is a 
\i glyph.  
\i0 Programming languages are based on grids of non-overlapping glyphs.  Language design has been driven by programming-editor capabilities, e.g. emacs, Vim, VisualStudio.  Fixed-font programming editors determine the shape of programming languages (not the other way around).  Programming editors are frozen in the 1950\'92s, whereas non-programming editors (e.g. Word) have advanced to include variable-sized fonts, diagrams, images, etc.\
\ls3\ilvl0
\f0 \'95	
\f1 Modern hardware is not constrained to editing non-overlapping glyphs in a grid.\
\pard\pardeftab709\li1287\fi-360\ri-765\sa283\partightenfactor0
\ls3\ilvl0
\f0 \cf0 \'95	
\f1 It is OK to mix text and diagrams.  A diagrammatic language does not need to be 100% diagrams.  Some concepts, e.g. concepts like \'93a = b + c\'94, are better expressed as text.\
\pard\pardeftab709\li720\fi-360\sl276\slmult1\sa140\partightenfactor0
\ls3\ilvl0
\f0 \cf0 \'95	
\f1 Diagrams for concurrency need only a few overlapping {\field{\*\fldinst{HYPERLINK "scrivcmt://848EEDB4-CF63-4823-B8EE-6B26E454FC54"}}{\fldrslt glyphs}} \'96 (1) boxes, (2) arrows, (3) text.  \
\ls3\ilvl0
\f0 \'95	
\f1 Diagrams for StateCharts need only a few overlapping glyphs \'96 (1) ellipses (or rounded boxes), (2) curved lines, (3) text\
\ls3\ilvl0
\f0 \'95	
\f1 Backtracking is OK.\
\ls3\ilvl0
\f0 \'95	
\f1 PROLOG can be used as a parser.\
\ls3\ilvl0
\f0 \'95	
\f1 A single app can use more than one paradigm, e.g. if PROLOG backtracking is used for parsing, the rest of the app is not constrained to use only PROLOG\
\ls3\ilvl0
\f0 \'95	
\f1 DSLs everywhere \'96 multiple DSLs can ({\field{\*\fldinst{HYPERLINK "scrivcmt://AC0BCA9B-0147-481F-8C20-E384E510A692"}}{\fldrslt should)}} be used in one project.  It is OK to build source-to-source converters that let the base language do the heavy lifting \'96 this makes building DSLs much less onerous.\
\ls3\ilvl0
\f0 \'95	
\f1 Hierarchical composition \'96 makes Software Architecture, {\field{\*\fldinst{HYPERLINK "scrivcmt://24888C34-48FB-46B6-A7A8-EBFD171BE503"}}{\fldrslt DI}} easier and, more expressive, and promotes 
\i divide & {\field{\*\fldinst{HYPERLINK "scrivcmt://930A2948-0DF2-460A-87C8-06FDE07152AF"}}{\fldrslt conquer}}
\i0 \
\ls3\ilvl0
\f0 \'95	
\f1 I want to derive interesting information about a diagram (code).  For example, I want to know the (x,y) for a box, I want to know (x,y) for the start-point of a line, I want to know (x,y) for the end-point of a line.  I can used backtracking pattern matching to derive some of this information.  \
\ls3\ilvl0
\f0 \'95	
\f1 Current PLs (programming languages) are based on the concept that, in (x,y),\'93x\'94 is a character position and \'93y\'94 is a line number.  Characters are strictly non-overlapping and sequential.  I would say that characters are not 2D, but something less, like 1.5D.  Current hardware can do better \'96 (x,y), 
\i can
\i0  be represented as pixel coordinates and full 2D glyphs can overlap.\
\ls3\ilvl0
\f0 \'95	
\f1 I need to ensure that my \'93editor\'94 gives me enough information.  The requirements for a diagrammatic programming editor are different from the requirements for a business editor (like Word, VISIO, Draw.io, etc.).\
\ls3\ilvl0
\f0 \'95	
\f1 SVG and XML based editors and diagram editors produce diagrams that contain much of this needed information, but they also contain lots of noise (aka syntactic sugar).  It might be better to build one\'92s own diagram-programming editor, but in the meantime, Draw.io, yEd, etc., might suffice.\
\ls3\ilvl0
\f0 \'95	
\f1 I am more concerned with DI than with Maintenance Engineering, Efficiency Engineering, Test Engineering, etc., etc.  From this perspective \'96 i.e. DI - I don\'92t care about the efficiency of parsers that employ backtracking, as long as it doesn\'92t keep me waiting, on my computer.\
\ls3\ilvl0
\f0 \'95	
\f1 Hierarchical composition \'96 keeps things small.  O(3) doesn\'92t matter when things are small.  O(3) still runs \'93fast enough\'94.\
\pard\pardeftab709\sb140\sa120\partightenfactor0
\ls4\ilvl2\cf0 	
\f0\b\fs28 Box-And-Arrow Diagrams and Concurrency\
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0

\f1\b0\fs24 \cf0 The canonical form of \'93visual programming\'94 - which I call DaS \'96 is the box-and-arrow diagram.  It is a network diagram wherein nodes are functions instead of full-blown computers.\
Most attempts at implementing box-and-arrow diagrams have failed (as far as I know).  Most attempts at \'93visual programming\'94 have failed (as far as I know \'96 visual programming can produce pretty pictures, but do not address PLs).\
I have been successfully using box-and-arrow diagrams in production since the mid-1990\'92s.  {\field{\*\fldinst{HYPERLINK "scrivcmt://B92DE598-687B-4A55-A23F-70E618144A45"}}{\fldrslt FBP}} has been using box-and-arrow diagrams since the 1960\'92s.  UNIX\'ae pipelines are a degenerate form of box-and-arrow-diagrams.\
Why have most attempts at box-and-arrow diagrams failed?\
{\field{\*\fldinst{HYPERLINK "scrivcmt://0F5971B3-4BAF-4342-A7EE-5FE0245C3C5F"}}{\fldrslt Concurrency.}}\
Box-and-arrow diagrams do not work well in the sequential paradigm.\
All of the working instances of box-and-arrow diagrams \'96 that I know of \'96 treat boxes as being concurrent components and treat arrows as pipelines of concurrent messages between (concurrent) components.\
UNIX\'ae pipelines and existing implementations of FBP use heavy-weight 
\i threads
\i0  to implement concurrency.  I implemented the concurrent paradigm without using 
\i threads
\i0 .  I used something like closures.}