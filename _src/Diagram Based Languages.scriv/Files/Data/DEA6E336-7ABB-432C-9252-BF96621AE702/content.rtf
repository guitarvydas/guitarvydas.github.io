{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\deftab709
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0

\f0\fs24 \cf0 I backed into a number of design principles.  I will do my best to summarize them below...\
\pard\pardeftab709\li720\fi-360\sl276\slmult1\sa140\partightenfactor0
\ls1\ilvl0
\f1 \cf0 \'95	
\f0 Most programming languages and compilers are based on glyphs.  A 
\i character 
\i0 is a small bitmap.  A 
\i character 
\i0 is a 
\i glyph.  
\i0 Programming languages are based on grids of non-overlapping glyphs.  Language design has been driven by programming-editor capabilities, e.g. emacs, Vim, VisualStudio.  Fixed-font programming editors determine the shape of programming languages (not the other way around).  Programming editors are frozen in the 1950\'92s, whereas non-programming editors (e.g. Word) have advanced to include variable-sized fonts, diagrams, images, etc.\
\ls1\ilvl0
\f1 \'95	
\f0 Modern hardware is not constrained to editing non-overlapping glyphs in a grid.\
\pard\pardeftab709\li1287\fi-360\ri-765\sa283\partightenfactor0
\ls1\ilvl0
\f1 \cf0 \'95	
\f0 It is OK to mix text and diagrams.  A diagrammatic language does not need to be 100% diagrams.  Some concepts, e.g. concepts like \'93a = b + c\'94, are better expressed as text.\
\pard\pardeftab709\li720\fi-360\sl276\slmult1\sa140\partightenfactor0
\ls1\ilvl0
\f1 \cf0 \'95	
\f0 Diagrams for concurrency need only a few overlapping {\field{\*\fldinst{HYPERLINK "scrivcmt://5ACA9FC4-ED0E-4C12-AA2D-A6884882754D"}}{\fldrslt glyphs}} \'96 (1) boxes, (2) arrows, (3) text.  \
\ls1\ilvl0
\f1 \'95	
\f0 Diagrams for StateCharts need only a few overlapping glyphs \'96 (1) ellipses (or rounded boxes), (2) curved lines, (3) text\
\ls1\ilvl0
\f1 \'95	
\f0 Backtracking is OK.\
\ls1\ilvl0
\f1 \'95	
\f0 PROLOG can be used as a parser.\
\ls1\ilvl0
\f1 \'95	
\f0 A single app can use more than one paradigm, e.g. if PROLOG backtracking is used for parsing, the rest of the app is not constrained to use only PROLOG\
\ls1\ilvl0
\f1 \'95	
\f0 DSLs everywhere \'96 multiple DSLs can ({\field{\*\fldinst{HYPERLINK "scrivcmt://80CE3CF2-2AF0-4010-96C1-12D786125B6D"}}{\fldrslt should)}} be used in one project.  It is OK to build source-to-source converters that let the base language do the heavy lifting \'96 this makes building DSLs much less onerous.\
\ls1\ilvl0
\f1 \'95	
\f0 Hierarchical composition \'96 makes Software Architecture, {\field{\*\fldinst{HYPERLINK "scrivcmt://82099959-7C9F-4A89-B16E-C32759FD5EF5"}}{\fldrslt DI}} easier and, more expressive, and promotes 
\i divide & {\field{\*\fldinst{HYPERLINK "scrivcmt://961E530B-E3C0-40FF-89EA-91BC37C165D2"}}{\fldrslt conquer}}
\i0 \
\ls1\ilvl0
\f1 \'95	
\f0 I want to derive interesting information about a diagram (code).  For example, I want to know the (x,y) for a box, I want to know (x,y) for the start-point of a line, I want to know (x,y) for the end-point of a line.  I can used backtracking pattern matching to derive some of this information.  \
\ls1\ilvl0
\f1 \'95	
\f0 Current PLs (programming languages) are based on the concept that, in (x,y),\'93x\'94 is a character position and \'93y\'94 is a line number.  Characters are strictly non-overlapping and sequential.  I would say that characters are not 2D, but something less, like 1.5D.  Current hardware can do better \'96 (x,y), 
\i can
\i0  be represented as pixel coordinates and full 2D glyphs can overlap.\
\ls1\ilvl0
\f1 \'95	
\f0 I need to ensure that my \'93editor\'94 gives me enough information.  The requirements for a diagrammatic programming editor are different from the requirements for a business editor (like Word, VISIO, Draw.io, etc.).\
\ls1\ilvl0
\f1 \'95	
\f0 SVG and XML based editors and diagram editors produce diagrams that contain much of this needed information, but they also contain lots of noise (aka syntactic sugar).  It might be better to build one\'92s own diagram-programming editor, but in the meantime, Draw.io, yEd, etc., might suffice.\
\ls1\ilvl0
\f1 \'95	
\f0 I am more concerned with DI than with Maintenance Engineering, Efficiency Engineering, Test Engineering, etc., etc.  From this perspective \'96 i.e. DI - I don\'92t care about the efficiency of parsers that employ backtracking, as long as it doesn\'92t keep me waiting, on my computer.\
\ls1\ilvl0
\f1 \'95	
\f0 Hierarchical composition \'96 keeps things small.  O(3) doesn\'92t matter when things are small.  O(3) still runs \'93fast enough\'94.}