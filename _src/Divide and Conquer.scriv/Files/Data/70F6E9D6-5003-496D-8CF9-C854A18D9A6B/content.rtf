{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\deftab709
\pard\pardeftab709\partightenfactor0

\f0\fs24 \cf0 When a problem looks to be complicated, a strategy for attacking the problem is \'93divide & conquer\'94.   \
\
Most programmers know about Divide & Conquer.\
\
What problems look to be complicated?\
\
For one \'96 multi-tasking is considered \'93hard\'94 by many programmers.  Multi-tasking is actually simple, but needs to be further divided (and conquered).  For example, multi-tasking, as it is know today consists of several sub-problems:\
\
\pard\pardeftab709\li720\fi-360\partightenfactor0
\ls1\ilvl0
\f1 \cf0 \'95	
\f0 time-sharing\
\ls1\ilvl0
\f1 \'95	
\f0 memory sharing\
\ls1\ilvl0
\f1 \'95	
\f0 networking, IPC, communication\
\ls1\ilvl0
\f1 \'95	
\f0 concurrency.\
\pard\pardeftab709\partightenfactor0
\cf0 \
Let\'92s apply Divide & Conquer to the multi-tasking.  (1) Time-sharing is needed only by operating systems, such as Linux, Windows, MacOS, etc.  Let\'92s throw time-sharing aside.  Gnarly problems, like priority inversion go out the window.\
\
Memory sharing was an issue when memory was expensive.  Memory is no longer expensive.  Let\'92s throw memory-sharing aside.  Thread-safety, etc., go out the window.\
\
We are left with networking and concurrency.\
\
Networking is easily reduced to it most basic form \'96 a wire.\
\
Concurrency, at its most basic form is 2 apps communicating across a wire.\
\
We know how to write the two apps \'96say, using Python, JS, etc., etc..  \
\
Yet, we don\'92t have a \'93language\'94 for app-to-app communication.  There is no popular Python-for-comms language.  There are budding attempts at this kind of language, the most common being UNIX\'ae 
\i bash
\i0 , but 
\i bash
\i0  is tangled up in complexity \'96 time-sharing and memory sharing and variables and, etc., etc. ...   {\field{\*\fldinst{HYPERLINK "scrivcmt://5BB59AEF-A2A5-4691-9BCF-1EA045196AB5"}}{\fldrslt FBP}} is a not-popular-enough attempt as this kind of language, but it tends to be tangled up with multi-tasking libraries which are tangled up with time-sharing and memory-sharing.  The FBP site references Linda.  {\field{\*\fldinst{HYPERLINK "scrivcmt://6AF79C9B-4315-4D0E-92B4-4EB288062F62"}}{\fldrslt CPS}} and {\field{\*\fldinst{HYPERLINK "scrivcmt://57F7BF8B-E4E5-4F4A-8922-E12BA12E3525"}}{\fldrslt CSP}} are text-only attempts to tackle this problem \'96 they simply demonstrate that the text-only mentality does not extend well to concurrent applications.  TC;DU (Too Complicated ; Didn\'92t Use).\
\
An acquaintance of mine builds products that measure the health of race horses.  His app uses some 37 processors.  He uses a language called {\field{\*\fldinst{HYPERLINK "scrivcmt://104D1126-F74D-4040-8E76-BC4022E2C986"}}{\fldrslt MicroPython.}}  He has no problem with multi-tasking.  One processor, one thread.  Node.js?  Why bother?  Processors are cheap.   Linux?  Why bother?  Processors are cheap.  When he wants to get 
\i really
\i0  complicated, he creates an event loop on a processor, that checks for incoming events and does some work in the background.\
\
We need a lean language for coordinating a hierarchy of {\field{\*\fldinst{HYPERLINK "scrivcmt://CFA0B7B3-A990-4530-AC7C-0655C5A9E8AA"}}{\fldrslt processors}}  \
\
We need to apply divide & conquer \'96 throw out operating systems, throw out heavy-weight thread libraries, throw out memory sharing, etc.\
}