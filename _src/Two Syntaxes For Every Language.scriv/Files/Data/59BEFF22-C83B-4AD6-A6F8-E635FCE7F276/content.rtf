{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fswiss\fcharset0 Helvetica-Bold;\f2\froman\fcharset0 Times-Italic;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid302\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid402\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid601\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid7}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}}
\deftab709
\pard\pardeftab709\sb240\sa120\partightenfactor0
\ls1\ilvl0
\f0\fs24 \cf0 	
\f1\b\fs36 The Problem\
\pard\pardeftab709\partightenfactor0

\f0\b0\fs24 \cf0 \
There is a class of error that is well understood and can be detected by automation.\
\
This class of errors is known as \'93syntax errors\'94.\
\
For this to {\field{\*\fldinst{HYPERLINK "scrivcmt://63CF1EF8-6609-442F-AF6C-08A44C717D8D"}}{\fldrslt work,}} the input language must contain 
\f2\i syntax 
\f0\i0 in the form of 
\f2\i syntactic sugar
\f0\i0 .\
\
There are, at least, two kinds of syntax errors:\
\
\pard\pardeftab709\li720\fi-360\partightenfactor0
\ls2\ilvl0\cf0  1.	simple typos\
 2.	deeply nested constructs with incorrect nestings.\
\pard\pardeftab709\partightenfactor0
\cf0 \
There are, at least, two kinds of programming languages:\
\
\pard\pardeftab709\li720\fi-360\partightenfactor0
\ls3\ilvl0\cf0  a)	Those that provide syntactic sugar that allows syntax errors to be detected\
 b)	Those that eschew syntactic sugar and do not provide (much, if any) syntactic sugar.\
\pard\pardeftab709\partightenfactor0
\cf0 \
Languages in class (a) typically come from the Algol (Pascal) lineage where most structured constructs are clearly delimited by end phrases.  For example, languages that provide \'93if ... end if\'94 fall into what I call class (a).\
\
Languages like Common Lisp and C fall into what I call class (b).  In C, an \'93if\'94 statement ends with a single character \'93\}\'94 and constructs like \'93for\'94 end with the same symbol \'93\}\'94.  In Common Lisp, all constructs end with the character \'93)\'94.  It is impossible to know what \'93\}\'94 and \'93)\'94 pertain to, except by scanning backwards to find the beginning of the corresponding construct.  This is harder if the construct is deeply nested and if the beginning of the construct is off-screen (or outside of the window). \
\
Shallow solutions to this symptom (b) have included attempts to make pretty printers and to embed them into code editors.  \
\
With the advent of better and better code optimizations (including functional alpha and beta substitution), the editor-debugger combination cannot easily display, correctly, the various constructs.\
\
\pard\pardeftab709\sb200\sa120\partightenfactor0
\ls4\ilvl1\cf0 	
\f1\b\fs32 When is Syntax Checking Important?\
\pard\pardeftab709\partightenfactor0

\f0\b0\fs24 \cf0 \
Syntactic correctness is important when the code is freshly minted (newly written, alpha-level, not tested yet).\
\
In such cases, automation, in the form of syntax checking, can help weed out this class of errors.\
\
In later stages of coding, syntax checking becomes less important.  \
\
At later stages, a programmer becomes less concerned with syntactic correctness of the code (since it has already been checked) and more concerned with expression of the algorithms being used.  \
\
In even later stages, programmers new to the code (e.g. Msaintenance Engineers) explore the (already-working) code and try to understand it.\
\
Those who favour languages in class (b) tend to be programmers who place more importance on the later stages of coding and maintenance.\
\
\pard\pardeftab709\sb200\sa120\partightenfactor0
\ls5\ilvl1\cf0 	
\f1\b\fs32 Programming Language Design\
\pard\pardeftab709\partightenfactor0

\f0\b0\fs24 \cf0 It was believed that designing programming languages was a hard problem.  \
\
This is no longer the case.\
\
It was believed that processing time was valuable.  This affected programming language design \'96 all languages were created with a 
\f2\i single
\f0\i0  syntax.\
\
\pard\pardeftab709\sb240\sa120\partightenfactor0
\ls6\ilvl0\cf0 	
\f1\b\fs36 Proposed Solution: The Best of Both Worlds\
\pard\pardeftab709\partightenfactor0

\f0\b0\fs24 \cf0 \
A solution to the apparent dichotomy of syntax checking via syntactic sugar vs. deeper understanding is to provide two (2) syntaxes for every language \'96 a 
\f2\i writing syntax
\f0\i0  and a 
\f2\i reading syntax
\f0\i0 .\
\
The 
\f2\i writing syntax
\f0\i0  would contain syntactic sugar such as \'93end if\'94.\
\
The 
\f2\i reading syntax
\f0\i0  would contain no syntactic sugar and would conserve screen real-estate to allow for easier understanding of details.\
\
In some cases, syntactic sugar could help maintainers understand the structure of unfamiliar code.  Programming editor(s) could assist the human reader (developer, maintainer) by switching between 
\f2\i writing 
\f0\i0 and 
\f2\i reading
\f0\i0  syntaxes on command.\
\
DSLs could be used to restructure programmers\'92 workflows, e.g. a front-end DSL could perform syntax checking and generate syntactic-sugar-free source code for later understanding and processing.\
\

\f2\i Divide and conquer
\f0\i0  means that once some aspect of a problem is understood, that aspect should be chopped off and isolated, leaving a \'93simpler\'94 problem to be solved.  When it comes to language design, we can apply 
\f2\i divide & conquer.
\f0\i0 \

\f2\i \
\pard\pardeftab709\li720\fi-360\partightenfactor0
\ls7\ilvl0
\f0\i0 \cf0  1.	We already know how to detect one class of problems in a language.  It is well-understood how to create syntax and parsers for a reasonable set of programming languages, and \
 2.	The rest of language processing remains a \'93hard\'94 problem.   [In fact, the problem of generating good, portable code was explored and is also well-understood.  What\'92s left?  Maybe we already know how to make semantic sense of a program (e.g. Denotational Semantics)?  Most previous attempts tried to solve the 
\f2\i whole
\f0\i0  problem in a 
\f2\i single
\f0\i0  notation.  Peter {\field{\*\fldinst{HYPERLINK "scrivcmt://A80BBD48-C880-41CA-AFE6-3E876016AE4C"}}{\fldrslt Lee}} and Uwe Pleban made interesting progress on these fronts, but tried to define all passes using a single tool instead of using multiple tools and multiple paradigms.]}