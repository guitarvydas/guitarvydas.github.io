{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\froman\fcharset0 Times-Italic;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\deftab709
\pard\pardeftab709\partightenfactor0

\f0\fs24 \cf0 A solution to the apparent dichotomy of syntax checking via syntactic sugar vs. deeper understanding is to provide two (2) syntaxes for every language \'96 a 
\f1\i writing syntax
\f0\i0  and a 
\f1\i reading syntax
\f0\i0 .\
\
The 
\f1\i writing syntax
\f0\i0  would contain syntactic sugar such as \'93end if\'94.\
\
The 
\f1\i reading syntax
\f0\i0  would contain no syntactic sugar and would conserve screen real-estate to allow for easier understanding of details.\
\
In some cases, syntactic sugar could help maintainers understand the structure of unfamiliar code.  Programming editor(s) could assist the human reader (developer, maintainer) by switching between 
\f1\i writing 
\f0\i0 and 
\f1\i reading
\f0\i0  syntaxes on command.\
\
DSLs could be used to restructure programmers\'92 workflows, e.g. a front-end DSL could perform syntax checking and generate syntactic-sugar-free source code for later understanding and processing.\
\

\f1\i Divide and conquer
\f0\i0  means that once some aspect of a problem is understood, that aspect should be chopped off and isolated, leaving a \'93simpler\'94 problem to be solved.  When it comes to language design, we can apply 
\f1\i divide & conquer.
\f0\i0 \

\f1\i \
\pard\pardeftab709\li720\fi-360\partightenfactor0
\ls1\ilvl0
\f0\i0 \cf0  1.	We already know how to detect one class of problems in a language.  It is well-understood how to create syntax and parsers for a reasonable set of programming languages, and \
 2.	The rest of language processing remains a \'93hard\'94 problem.   [In fact, the problem of generating good, portable code was explored and is also well-understood.  What\'92s left?  Maybe we already know how to make semantic sense of a program (e.g. Denotational Semantics)?  Most previous attempts tried to solve the 
\f1\i whole
\f0\i0  problem in a 
\f1\i single
\f0\i0  notation.  Peter {\field{\*\fldinst{HYPERLINK "scrivcmt://11CC1CF1-1C14-4539-99C4-19AA970702CB"}}{\fldrslt Lee}} and Uwe Pleban made interesting progress on these fronts, but tried to define all passes using a single tool instead of using multiple tools and multiple paradigms.]}