{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\deftab709
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0

\f0\fs24 \cf0 I used to conflate parallelism and concurrency until I watched Rob Pike\'92s talk.\
I used to try to convince people that they could write concurrent programs using something \'93better\'94 than Processes (Threads).  What I didn\'92t realize was that I was trying to explain the difference between the \ul \ulc0 paradigm\ulnone  called \'93concurrency\'94 and the application \ul problem\ulnone  called \'93parallelism\'94.\
A parallel program 
\i must
\i0  run on multiple processors.\
A program designed using the concurrent paradigm can run on a 
\i single
\i0  Processor or on multiple processors.  \
The advantages of using the concurrent paradigm can be seen even on a single processor system.\
One can write concurrent software that uses only a single Processor.  One cannot write parallel software that uses a single Processor.  One can 
\i simulate
\i0  parallel software on a single processor, but this is not necessary (although it might help debugging, while hindering debugging).  \
Multi-tasking \'96 as we know it today \'96 is a 
\i simulation
\i0  of parallelism.  Multi-tasking, as we know it today, tries valiantly to solve too many problems at once \'96 e.g. memory sharing, bandwidth optimization, time-sharing, etc.  Multi-tasking as we know it today, is a simulation of parallelism that attempts to optimize concurrency using multiple stacks (a form of memory sharing optimization + processor optimization and sharing).\
}