{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\deftab709
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0

\f0\fs24 \cf0 A concurrent system is composed of a number of 
\i closures
\i0 .  There is a single distinguished routine, called the Dispatcher().  The Distpacher() invokes closures, at random.\
That\'92s all there is.\
It is simple \'96 almost too simple \'96 to implement concurrency in any language that supports 
\i closures
\i0 .  It is possible to implement the concurrent paradigm in C or assembler, too, one just needs to pay more attention to details.\
As simple as this sounds, the concurrent paradigm forces one to program in a completely different manner.  The program cannot rely on synchrony.  The program \'96 composed of many communicating closures \'96 must be written in a way that acknowledges that 
\i any
\i0  closure might be awakened at 
\i any 
\i0 time (by the Dispatcher()).\
This seemingly simple requirement causes programmers to re-evaluate control-flow coupling.\
Operating system Processes and threading libraries are heavy-handed approaches to creating closures and a Dispatcher().  In some, 
\i but not most
\i0 , cases it is necessary to use hardware to protect one program from another (e.g. MMUs).  In some, 
\i but not most
\i0 , cases it is necessary to optimize memory usage using memory-sharing and stacks (stacks are just an optimized form of linked lists).  In some, 
\i but not most
\i0 , cases it is necessary to use time-sharing.  When you strip these features out of threading libraries, you get multi-tasking that is easy.  Closures have been around for a long time, and they don\'92t require MMUs, memory sharing, stacks and time-sharing.\
Closures are like GOTOs \'96 they 
\i can
\i0  be misused.  Organizing closures in a hierarchical manner (see my other essays on this subject) is one way to tame their use.  We have found that we need \'93languages\'94 that encourage certain usage patterns \'96 e.g. C vs. assembler programming (C encourages Structured control flow, through if-then-else statements, etc.) - e.g. OO encourages data encapsulation (but leaves control-flow encapsulation wide open, if not worse off).\
GOTOs are assembler-level details.  GOTOs must exist.  GOTOs must be tamed.  Likewise, Closures exist and must be tamed.\
Message-passing is another GOTO-like atomic element.  It must be tamed.  Message-passing enables the concurrent paradigm.  A component can send another component a message, but the receiving component is not constrained as to when it deals with the message.  Message-passing defeats rendezvous.  Message-passing allows asynchrony.  The concurrent paradigm requires asynchrony.   \
Backus asked \'93Can Programming Be Liberated From The von Neumann Style?\'94.  The question is a good one.  The answer that Backus proposed was insufficient, though.  Mathematics, as we know it today, implies synchronous evaluation.  We need to think of mathematics and synchrony being 
\i isolated
\i0  on asynchronous 
\i islands
\i0 .\
Computers are parallel by default.  Forcing synchrony onto every part of computing is contrary to the manner in which computers work.  For example, multi-tasking is considered to be a \'93hard\'94 problem mostly because multi-tasking is being solved using only one paradigm \'96 a paradigm that is not the best choice for every problem in a particular solution.  It is like trying to emulate C-like 
\i format
\i0  statements in PROLOG.  It can be done, but results in accidental complexity. \
\'93Yes\'94 to synchronous operations floating on asynchronous islands.\
\'93No\'94 to synchronous 
\i everything
\i0 .\
It is OK to use more than one paradigm at a time.  For example, again, PROLOG leads the way towards thinking in relational terms, but casting 
\i everything 
\i0 as a relation brings unnecessary difficulty.\
Paradigms are DSLs draped over full-featured {\field{\*\fldinst{HYPERLINK "scrivcmt://BB2F4535-C297-4496-869F-09CE41437619"}}{\fldrslt assemblers.}}\
}