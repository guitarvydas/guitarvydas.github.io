{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\froman\fcharset0 Times-Italic;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\deftab709
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0

\f0\fs24 \cf0 PEG is not the first tool to process and create top-down grammars.  S/SL is another such tool.  S/SL was invented in the 1980\'92{\field{\*\fldinst{HYPERLINK "scrivcmt://12ED64DE-01EF-4E0B-82E2-E6C3386D12A6"}}{\fldrslt s.}}  \
S/SL has the advantage that it works with 
\f1\i tokens, 
\f0\i0 whereas Ohm-JS works only with character streams.\
S/SL has the advantage that it is pass-based.  Ohm-JS does not default to this behaviour, but could be twisted to conform to {\field{\*\fldinst{HYPERLINK "scrivcmt://3860A933-422A-44E0-9961-BC2DDF96EA93"}}{\fldrslt passes.}}  Since Ohm-JS accepts only characters as input, it discourages pass-based and token-based approaches.\
S/SL has the disadvantage that it tends not to subsume scanning and parsing.  PT {\field{\*\fldinst{HYPERLINK "scrivcmt://2D74DCDF-9240-4B56-882E-D63B8D1CEC2B"}}{\fldrslt Pascal,}} though, uses a scanner created in S/SL.\
}