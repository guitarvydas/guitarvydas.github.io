<?xml version="1.0" encoding="UTF-8"?>
<Comments>
    <Comment ID="081294F6-D80C-45DA-A2B1-92C27E6E1184" Footnote="Yes" Color="0.949769 0.949769 0.949769"><![CDATA[{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\froman\fcharset0 Times-Italic;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs20 \cf0 This used to be very important for efficiency.  Wasting processor time in re-scanning character strings caused noticeable slow-downs in processing (and ate memory).  Modern hardware processes character strings much more quickly, but the notion of 
\f1\i tokenizing
\f0\i0  remains.  On faster hardware, the act of creating tokens is not (necessarily) about speed, but does help with \'93divide & conquer\'94.  A scanner recognizes low-level strings, subsequent passes recognize patterns of increasing complexity \'96 the 
\f1\i semantics
\f0\i0 .  Untangling scanning from semantics-recognition is easier to reason about when a scanner \'93gets the low-level details out of the way\'94.  See my other essays for more discussion about layers of pattern matchers.}]]></Comment>
    <Comment ID="65665512-EDB1-47EF-A18D-827E4B2063ED" Footnote="Yes" Color="0.949769 0.949769 0.949769"><![CDATA[{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\froman\fcharset0 Times-Italic;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs20 \cf0 Separator characters, such as \'93)\'94, \'93(\'93, etc..  For example, 
\f1\i ids 
\f0\i0 are terminated when a separator character is seen, e.g. when the next character is not an alphanumeric.}]]></Comment>
</Comments>