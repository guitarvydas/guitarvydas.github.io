{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid2\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid3\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid102\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid103\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid202\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid203\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid302\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid303\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid402\'02\'01.;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid403\'02\'02.;}{\levelnumbers\'01;}\fi-360\li2160\lin2160 }{\listname ;}\listid5}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}}
\deftab709
\pard\pardeftab709\sb240\sa120\qc\partightenfactor0

\f0\b\fs56 \cf0 Scanning and Parsing Overview\
\pard\pardeftab709\partightenfactor0

\f1\b0\fs24 \cf0 \
\
\
A DSL is best built as a hierarchy.\
\
At the \'93leaf nodes\'94 of the hierarchy are characters (or better yet, {\field{\*\fldinst{HYPERLINK "scrivcmt://BAF50D0C-48E1-4A7E-A911-ADA335AC513C"}}{\fldrslt glyphs).}}\
\
Leaf nodes are collected into composite structures, called 
\i tokens
\i0 .\
\
A language (and a DSL) is composed of layers.  At each layer, a certain set of tokens is parsed and transpiled into another set of tokens.\
\
An 
\i unparser
\i0  is a layer processor.  It takes a set of tokens and emits them as a simpler set of tokens.  For example, we might construct a tree representing a Scheme program, then unparse it into a JavaScript program.\
\
\pard\pardeftab709\sb140\sa120\partightenfactor0
\ls1\ilvl2\cf0 	
\f0\b\fs28 Scanner\
\pard\pardeftab709\partightenfactor0

\f1\b0\fs24 \cf0 \
The first layer of a DSL is the 
\i scanner.
\i0   It reads input data, e.g. characters, and converts the data into 
\i tokens
\i0 .  A 
\i token
\i0  might contain file and position information.  \
\
The scanner might compress runs of similar characters into single tokens.  For example a run of whitespace \'96 spaces, tabs, etc. - might be compressed into a single 
\i whitespace
\i0  
\i token
\i0 .  These are semantically uninteresting, but 
\i whitespace tokens
\i0  can act as delimiters between other tokens.\
\
More importantly, the scanner compresses semantically interesting runs of related characters.  For example, an identifier, 
\i id
\i0 , in a language is usually composed of a single alpha character followed by 0 or more alphanumeric characters.  The scanner groups such identifier characters together and assigns a single token (e.g. a token code plus a string hashcode) to such runs.  Compressing such runs of characters into single tokens relieves subsequent passes from having to re-scan the input character by {\field{\*\fldinst{HYPERLINK "scrivcmt://5BF5459B-7E2D-4053-88F6-579DDCB63D3E"}}{\fldrslt character.}} The scanner also worries about the low-level details of {\field{\*\fldinst{HYPERLINK "scrivcmt://5BB9E695-0F20-4060-A587-E4473DFEB5A5"}}{\fldrslt delimiter}} characters. In languages where indentation is significant (e.g. Python), the scanner might keep track of indentation levels and attach these to 
\i tokens
\i0  or, might create special indentation 
\i tokens
\i0 .\
Scanners are, fundamentally, pattern matchers.\
\
Scanners often use REGEX libraries to specify string matching.  \
\
A tool that build scanners from declarative specifications is LEX.\
\
PEG technology obsoletes the use of LEX.  See below.\
\
\pard\pardeftab709\sb140\sa120\partightenfactor0
\ls2\ilvl2\cf0 	
\f0\b\fs28 Parser\
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0

\f1\b0\fs24 \cf0 A 
\i parser
\i0  inputs a sequential stream of 
\i tokens
\i0 , and checks that the tokens form valid phrases \'96 in sequence \'96 for the language being processed (compiled, transpiled, etc.).\
Parsers are pattern matchers, albeit more elaborate than the pattern matchers in scanners.\
Parsing is typically specified as a set of rules (patterns) that describe parts of the language being processed.  \
Parsing typically uses subroutines (stack based) to do pattern matching.  As such, parser pattern matchers cannot use REGEX directly, since REGEX does not provide stack-based routines.\
Parsers can match patterns across line boundaries, whereas REGEX cannot.\
Parsers can match structured code (phrases), whereas REGEX cannot.\
A tool that builds parsers from declarative specifications is YACC.\
Parser fall, broadly, into two categories \'96 top-down and bottom-up.  Top-down parsers are typically implemented as recursive descent routines.  Bottom-up parsers match phrases, then bubble such matches upwards to recognize a full program.  Bottom-up parsers have been formalized (see the Dragon Book).  \
One such formalization is the set of languages called LR.  A very common subset of LR is called LALR(1).  YACC builds LALR(1) parsers, as state machines, from declarative specifications.  Languages that fit the LALR(1) mould are a subset of LR languages.  LR languages are a subset of more general languages.  The restrictions of LR and LALR(1) languages are tolerated because they can be formalized.  LALR(1) is popular because of the YACC tool.\
Top-down languages are less restrictive than LR languages, but, top down parsers were not easily formalized.  \
LALR(1) (through YACC) was \'93first to market\'94 and has gained most of the mind-share in this problem space.\
Bryan {\field{\*\fldinst{HYPERLINK "scrivcmt://270FAC71-0D29-4690-87EB-A3A068B2C54F"}}{\fldrslt Ford,}} in the early 2000\'92s, invented the PEG parsing technology, which creates top-down pattern-matchers (parsers) using a syntax similar to that of REGEX.  PEG also uses backtracking in some cases.\
The class of languages that PEG can recognize is larger than the LR class of languages.  PEG can match some patterns that LR cannot match, and vice versa.  \
In my opinion, top-down parsing (e.g. PEG) matches languages that are easier to create than the class of LR languages.  \
In top-down pattern matching, order matters \'96 the programmer can specify which patterns to match first.  In LR, it is possible to create ambiguities which are, in my opinion, \'93not obvious\'94.  Such LR ambiguities need to be dealt with by rearranging the grammars or by using exception-processing rules.  Typically, a LALR(1) grammar programmer waits for the tool to detect and declare ambiguities, instead of intuiting them.\
PEG subsumes scanning and parsing into a single notation.\
\
In my opinion, PEG is a break-through, which makes building DSLs very simple.  I expect that simple {\field{\*\fldinst{HYPERLINK "scrivcmt://C4A391DF-8DD6-4D74-8A49-1C1AAD9D4F82"}}{\fldrslt DSLs}} will over-take language design.  It is now possible to design and use multiple DSLs in a single {\field{\*\fldinst{HYPERLINK "scrivcmt://D3FC304E-DBC8-4BC3-B5E9-5BC891A0F9E3"}}{\fldrslt project.}}\
Tools such as OMetaII and Ohm-JS are based on PEG technology.\
PEG libraries exist for many common languages, e.g. Ohm-JS for JavaScript, ESRAP for Common Lisp, etc.\
\pard\pardeftab709\sb140\sa120\partightenfactor0
\ls3\ilvl2\cf0 	
\f0\b\fs28 S/SL\
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0

\f1\b0\fs24 \cf0 PEG is not the first tool to process and create top-down grammars.  S/SL is another such tool.  S/SL was invented in the 1980\'92{\field{\*\fldinst{HYPERLINK "scrivcmt://330EB3F0-0F85-4F61-8C4C-5075328D84AA"}}{\fldrslt s.}}  \
S/SL has the advantage that it works with 
\i tokens, 
\i0 whereas Ohm-JS works only with character streams.\
S/SL has the advantage that it is pass-based.  Ohm-JS does not default to this behaviour, but could be twisted to conform to {\field{\*\fldinst{HYPERLINK "scrivcmt://82053786-341B-4743-9218-CEF5B6DF0ADA"}}{\fldrslt passes.}}  Since Ohm-JS accepts only characters as input, it discourages pass-based and token-based approaches.\
S/SL has the disadvantage that it tends not to subsume scanning and parsing.  PT {\field{\*\fldinst{HYPERLINK "scrivcmt://21B08ACD-9536-49FB-937A-DD9374B36898"}}{\fldrslt Pascal,}} though, uses a scanner created in S/SL.\
\pard\pardeftab709\sb140\sa120\partightenfactor0
\ls4\ilvl2\cf0 	
\f0\b\fs28 TXL\
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0
{\field{\*\fldinst{HYPERLINK "scrivcmt://6B291D23-A603-4BCC-BF0A-81A8243AACA3"}}{\fldrslt 
\f1\b0\fs24 \cf0 TXL}}
\f1\b0\fs24  is a source-to-source technology, based on backtracking, ostensibly used for experimental language design.\
\pard\pardeftab709\sb140\sa120\partightenfactor0
\ls5\ilvl2\cf0 	
\f0\b\fs28 PROLOG\
\pard\pardeftab709\sl276\slmult1\sa140\partightenfactor0

\f1\b0\fs24 \cf0 PROLOG is a language that expresses exhaustive pattern-matching using backtracking.\
As such, PROLOG should be ideal for building parsers (and, maybe, scanners).\
The early wisdom stated that backtracking was not a viable strategy for building parsers.  Early attempts to use backtracking in parsers was quashed after Early\'92s (a researcher\'92s name) Parsing technology.\
Now, with much faster computers, and almost-unlimited memory, this \'93wisdom\'94 could be re-investigated.  To my knowledge, this has not been done.\
PEG parsers use a limited form of backtracking.\
Searches for parsers built in PROLOG tend to turn up experimental research into natural language parsing (a superset of PEG based languages and LR languages).\
\pard\pardeftab709\partightenfactor0
\cf0 	}