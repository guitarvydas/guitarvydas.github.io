{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\froman\fcharset0 Palatino-Italic;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 In the concurrent paradigm, we imagine that every 
\f1\i part
\f0\i0  has its own CPU.\
\
The "rules" for combining 
\f1\i parts
\f0\i0  can be easily inferred from the physical nature of separate CPUs.\
\
Imagine that we can have as many rPi's as needed, and none of them runs Linux (or any other Operating System).\
\
We don't need threads.  Each piece of software runs on its own CPU.\
\

\f1\i Parts
\f0\i0  are connected by thin wires.  We can't share memory.  The wires don't have enough bandwidth.\
\

\f1\i Parts 
\f0\i0 don't need time-sharing operating systems.  Why bother?  Every 
\f1\i part
\f0\i0  has its own CPU.\
\
Some 
\f1\i parts
\f0\i0  control I/O devices.  Most 
\f1\i parts 
\f0\i0 just receive and send messages and don't directly control any I/O devices.\
\
We arrange the parts in a hierarchical {\field{\*\fldinst{HYPERLINK "scrivcmt://82431C5E-3A7F-4131-B8DC-DBDB1A590285"}}{\fldrslt nature}}}