{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\froman\fcharset0 Palatino-Italic;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 We might prefer something that is more efficient than full-blown Operating Systems, to implement filters.  Ideally, we want filters to be at least as efficient as function calls.\
\
The concept of {\field{\*\fldinst{HYPERLINK "scrivcmt://92E43865-4631-4715-8540-B22D8DD074C2"}}{\fldrslt 
\f1\i closures}} is prevalent in modern languages.\
\
I argue that 
\f1\i closures 
\f0\i0 \ul are\ulnone  threads.\
\
Operating system-level processes (threads) are threads that include provisions for time-sharing, full-preemption, memory sharing, etc.  Most of these features are {\field{\*\fldinst{HYPERLINK "scrivcmt://FE5ED31A-ED97-45F1-B08F-A8D557431CF8"}}{\fldrslt unnecessary}} in most uses of threads.  Most problems in multi-tasking can be ascribed to these, mostly unnecessary features.  These complications are needed only by {\field{\*\fldinst{HYPERLINK "scrivcmt://C6BB3F7B-9CC4-4F4F-B437-9A535AB2B431"}}{\fldrslt programs}} such as Linux, Windows, MacOS, etc.\
\
I argue that operating-system threads are ad-hoc closures, implemented in assembler.}