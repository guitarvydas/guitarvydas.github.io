<html>

<head>
<title>Composition</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<!-- NOTE: margin property = top-right-bottom-left -->
<style type="text/css">

	body {background-color: #e2e2e2}
    
    p.topLevelItemTitle {
    	margin: 30px 0px 5px 0px;
    	font-family: Times, Times New Roman, Palatino, Cochin, Serif;
    	font-size: 30px;
    	}
    	
    p.folderTitle {
    	margin: 30px 0px 5px 0px;
    	font-family: Times, Times New Roman, Palatino, Cochin, Serif;
    	font-size: 18px;
    	}
    
    p.itemTitle {
    	margin: 30px 0px 5px 0px;
    	font-family: Helvetica, Arial, Sans-Serif;
    	font-size: 12px;
    	font-weight: bold;
    	}
    	
    p.itemText {
    	margin: 0px 0px 10px 0px;
    	font-family: Helvetica, Arial, Sans-Serif;
    	font-size: 12px;
    	}
    	
    p.itemTextStart {
    	margin: 30px 0px 10px 0px;
    	font-family: Helvetica, Arial, Sans-Serif;
    	font-size: 12px;
    	}
    
    .page {border: 1px solid #c0c0c0; background: #fff}
    
    hr {
        border: none;
        height: 1px;
        color: #d4d4d4;
        background-color: #d4d4d4;
      	}
      	
    hr.afterTitle {
    	margin-top: -3px;
    }
      	
    hr.afterText {
    	margin-top: 30px;
    }
      	
    ul {
      	list-style-type: none;
      	padding-left: 30px;
      	}
      	
</style>

</head>

<body>

<table border="0" width="100%" cellspacing="3">
<tr>
<td>

<table class="page" width="100%" cellspacing="10" cellpadding="2">

<!-- Top margin -->
<!-- Not needed, because of the padding above titles. -->
<!--<tr><td height="15px"></td></tr>-->

<tr>

<!-- 42 + 30 of list indent = 72 - one inch. -->
<!-- Actually that ends up too much, so we do 25 + 30 = 55px. -->
<td width="25px">

<td valign="top">

<ul>
<li>
<p class="topLevelItemTitle">Type stacks</p>
<p class="itemText">We can think in terms of stacks of types.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1"></p>
</li>
<li>
<p class="topLevelItemTitle">Everything Starts Out as a Bit</p>
<p class="itemText">Everything starts out as a bit.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1"></p>
</li>
<li>
<p class="topLevelItemTitle">Bits are Parsed Into Bytes</p>
<p class="itemText">#</span></p></p>
<p class="itemText"><p class="p1"><span class="s1">Fig. &lt;$n:figure:Type-statck-Bits-Parsed-to-Bytes&gt;</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">Bits can be parsed into bytes.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">The filter for such a parser is nearly trivial: collect 8 bits, emit a byte.<span class="Apple-converted-space">  </span>Emit an error if you see an EOF when you have collected fewer than 8 bits.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">Even a filter as simple as that above can have more than one implementation. <span class="Apple-converted-space"> </span></span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">Another implementation might pad 0’s onto the end of an unfinished byte, when an EOF is seen.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">Or, we might pad 0’s at the front of the byte upon EOF.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">Or, we might pad with trailin...</p>
</li>
<li>
<p class="topLevelItemTitle">Bytes Parsed into More Interesting Structures</p>
<p class="itemText">We, then, create a handful of filters.<span class="Apple-converted-space">  </span>Some low-level filters are shown in Fig. &lt;$n:figure:lowLevelFilters&gt;</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">#</span></p></p>
<p class="itemText"><p class="p1"><span class="s1">Fig. &lt;$n:figure:lowLevelFilters&gt; Low Level Filters</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">(Filters can further be chained together to recognize more interesting, more complicated, types).</span></p></p>
<p class="itemText"><p class="p1"><span class="s1"></p>
</li>
<li>
<p class="topLevelItemTitle">Composition</p>
<p class="itemText">Note that it is hard(er) to implement filters as shown in Fig. &lt;$n:figure:lowLevelFilters&gt; using only functions.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">The boxes emit two kinds of objects (good output and errors), but could emit many different kinds of objects.<span class="Apple-converted-space">  </span>Functions return only one object.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">These boxes emit objects at various times.<span class="Apple-converted-space">  </span>For example, the UNIX Line filter might need to wait for 80 bytes before seeing a line-feed.<span class="Apple-converted-space">  </span>It emits a full line only after it has seen all bytes that belong to that line.<span class="Apple-converted-space">  </span>It waits and SENDs no...</p>
</li>
<li>
<p class="topLevelItemTitle">RATFOR, Software Tools</p>
<p class="itemText">RATFOR built line filters using Procedures and Functions.<span class="Apple-converted-space">  </span>It used the Operating System to preempt filters.</p>
</li>
<li>
<p class="topLevelItemTitle">Efficiency</p>
<p class="itemText">We might prefer something that is more efficient than full-blown Operating Systems, to implement filters.<span class="Apple-converted-space">  </span>Ideally, we want filters to be at least as efficient as function calls.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">The concept of closures is prevalent in modern languages.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">I argue that closures are threads.</span></p></p>
<p class="itemText"><p class="p2"><span class="s1"></span><br></p></p>
<p class="itemText"><p class="p1"><span class="s1">Operating system-level processes (threads) are threads that include provisions for time-sharing, full-preemption, memory sharing, etc.<span class="Apple-converted-space">  </span>Most of these features are unnecessary in most uses of threads.<span class="Apple-converted-space">  </span>Most problems in multi-t...</p>
</li>
</ul>

</td>
<td width="55px">
</td>
</tr>

<!-- Bottom margin -->
<tr><td height="15px"></td></tr>

</table>

</td>
</tr>
</table>

</body>
</html>
