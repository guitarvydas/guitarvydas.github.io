{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
\f3\froman\fcharset0 Palatino-Italic;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 What can we do if two parameters have the same type?\
\
Presently, we use variables and assign a type to each.\
\
Another solution might be to allow type synonyms, where each parameter gets a unique name, but the name is synonymed to be of a given type.\
\
E.G.\
\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f2\fs22 fn(a : int, b : int)\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::0>
\f0\fs26 \
becomes\
\
\pard\tx720\tx1080\tx1440\tx1800\tx2160\li720\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <$Scr_Ps::0>
\f2\fs22 fn(a,b)\
a = int\
b = int\
\
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\fs24 \cf0 <!$Scr_Ps::0>
\f0\fs26 The fact that 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 a
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26  (and 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 b
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 ) is an 
\f1\fs24 <$Scr_Cs::1>
\f2\fs22 int
\f1\fs24 <!$Scr_Cs::1>
\f0\fs26 , is an implementation detail, and should not appear in the Architecture.  The fact that we want to use automation to check such details implies that the semantic (i.e. architecture-related) and implementation details might need to appear in the same body of code.  A trade-off is to separate implementation details from architectural details, as above.  This allows the Architect to describe an architecture at the architectural level while pushing implementation details to more innocuous places (like the bottom of the file).  The Engineer(s) and Implementor(s) can later add such details without affecting the readability of the original {\field{\*\fldinst{HYPERLINK "scrivcmt://77F618F2-D5FA-4553-9315-5A42B7F67CB3"}}{\fldrslt architecture}}.  \
\
At the architectural level, parameters to functions are not variables.  Variables and their types are implementation details.  The above arrangement suggests that we can expunge variables from parameter lists completely.  \
\
The current style of assigning types to parameters in a function signature conflates two issues (1) architectural readability and, (2) implementation details.\
\
In the above, every parameter, at the {\field{\*\fldinst{HYPERLINK "scrivcmt://3B451E21-EB54-441A-AA11-4464F940BE16"}}{\fldrslt DI}} level, is a type. \
\
I have found that treating parameters as types to be defined later, reduces syntactic noise.  Code is shorter and not cluttered with detail.\
\

\f3\i [The notion of types associated with parameters was based on premature optimization - making it less expensive in memory and CPU time to define parameters and their implementations.  With "infinite" CPU power and "infinite" memory, there is no need to conflate types with their implementations in function signatures.  Types can be defined in a scoped manner - defined in terms of other types and, ultimately, as consisting of a small number of opaque types.  So-called 
\f0\i0 system
\f3\i  languages are concerned with implementation details.  Even programs written in such languages have distinct DI and implementation aspects.]\
\

\f0\i0 In the above notation, implementation of types is the exception, not the rule.}