I like to cleave "programming languages" into 2 categories (1) human readable and (2) machine readable.

The task of developing programming languages boils down to figuring out how to map (1) to (2).

I think that the best language for (2) machine readability is Lisp syntax (not necessarily Lisp semantics, which is a different issue).  I think that the best language for (1) human readability is a hybrid of box-and-arrow diagrams mixed with text.  Currently, I am writing programs in `draw.io` and compiling them to executable Odin code (thanks to Zac Nowicki).  I am using this, also, as a visual shell (VSH) to plumb together Ohm-JS and '.RWR' ("rewrite" nano-DSL) specifications to form transpilers (e.g. Scheme->JS).

I firmly believe in what I learned in Physics - invent multiple notations suited to expressing the task(s) using "simplifying assumptions" and bolt them all together to form solutions using divide-and-conquer mentality.

## Example
The code works, at least at a beta level.  The documentation is a work-in-progress and updated daily...

https://github.com/guitarvydas/transpiler

## See Also
### Blogs
https://publish.obsidian.md/programmingsimplicity (see blogs that begin with a date 202x-xx-xx-)

https://guitarvydas.github.io/
### Videos
https://www.youtube.com/@programmingsimplicity2980
### Books
leanpub'ed (disclaimer: leanpub encourages publishing books before they are finalized)
https://leanpub.com/u/paul-tarvydas
### Discord
https://discord.gg/Jjx62ypR  ("programming simplicity") all welcome, I invite more discussion of these topics
### Twitter
@paul_tarvydas
### Mastodon
(tbd, advice needed re. most appropriate server(s))

<script src="https://utteranc.es/client.js" 
        repo="guitarvydas/guitarvydas.github.io" 
        issue-term="pathname" 
        theme="github-light" 
        crossorigin="anonymous" 
        async> 
</script> 
