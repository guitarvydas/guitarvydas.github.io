<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Relational Programming and the Kitchen Sink</title>
	<meta name="author" content=""/>
</head>
<body>

<h1 id="everythingbutthekitchensink">Everything But The Kitchen Sink</h1>

<p>I use the phrase &#8220;everything but the kitchen sink&#8221; as an analogy.</p>

<p>In my words, the phrase means trying to do everything at once instead of partitioning the work.</p>

<p>Emacs is everything but the kitchen sink.</p>

<p>Most PLs are everything but the kitchen sinks.</p>

<p>IMO, everything is a fractal. Everything can be subdivided into smaller pieces.</p>

<p>IMO, programming tasks should be subdivided into smaller pieces.<a href="#fn:1" id="fnref:1" title="see footnote" class="footnote"><sup>1</sup></a></p>

<h1 id="relationalprogramming">Relational Programming</h1>

<p>I argue that we can strip <em>relational programming</em> down to its basics and that this will help us create code that creates code that &#8230;</p>

<p>The basics of <em>relational programming</em> are:</p>

<ol>
<li>exhaustive search</li>
<li>triples.</li>
</ol>

<p>Everything else is unnecessary complexity.</p>

<p>We already know how to express both basics: (a) as loops of loops (but, the syntax is horrible) and (b) functions of exactly two arguments (not 0, not 1, not more than 2).</p>

<p>PROLOG, also, suggests a concise, human-readable, syntax for exhaustive search.</p>

<p>The easiest introduction to PROLOG that I have encountered is Nils Holm&#8217;s &#8220;Prolog Control in Six Slides&#8221;.</p>

<p>[<em>In &#8220;Ohm in Small Steps&#8221;, I show one way to transpile Holm&#8217;s Scheme code to Javascript. The transpiler should port easily to other output languages that support anonymous functions.</em>]</p>

<h1 id="thesoftwareatom">The Software ATOM</h1>

<p>In &#8220;Everything is a Fractal&#8221;, I mention <em>relational programming</em>.</p>

<p>My interest is in finding the <em>atom</em> of software.</p>

<p>Many languages have been invented, and each one purports to be The Answer (to software development).</p>

<p>Projectional editing consists of research into creating different views on code.</p>

<p>I believe that if we had an <em>atom</em> of software, we could create multiple views on the code (and the data) and we could create multiple languages for the same code and data. We could re-skin code at will.</p>

<p>I call such <em>skins</em> &#8220;SCNs&#8221; - Solution Centric Notations.<a href="#fn:2" id="fnref:2" title="see footnote" class="footnote"><sup>2</sup></a></p>

<h2 id="theatomofsoftware">The ATOM of Software</h2>

<p>I &#8212; currently &#8212; believe that <em>triples</em> are the <em>ATOM</em> of code and that <em>relational programming</em> shows us how to write low-level code and data in triple format.</p>

<p>In my words, an <em>Atom</em> is the smallest indivisible sub-part of a system.</p>

<p>In my view, everything is a fractal, so I believe that <em>Atoms</em> can be further subdivided.</p>

<p>From this perspective, an <em>Atom</em> is only meaningful in terms of a <em>solution</em>. An <em>Atom</em> is a point where the Architect / Engineer chose (<em>v: to choose</em>) to quit subdividing a sub-problem and chose to implement the solution to the sub-problem.</p>

<p>[<em>Corollary: Different Architects might choose different sets of Atoms</em>.]</p>

<h2 id="assembleratoms-isthereahigherlevel">Assembler ATOMS - Is There a Higher Level?</h2>

<p>Assembler is a triple-based language.</p>

<p>For example</p>

<p>MOV R1, R0</p>

<p>is a triple (!).</p>

<p>Techniques have been devised to write code that writes code, given assembler. Such techniques have been buried in <em>compiler technology</em> literature. I think that such tools and techniques need to be brought out and made available to all programmers, not just compiler-writers.</p>

<p>It is <em>much</em> easier to write code that writes code when the input has been normalized to triple form.</p>

<p>Some compiler technologies have leaked out to mortal programmers &#8212; e.g. REGEX.</p>

<p>Most compiler technology, though, remains shrouded in mystery.</p>

<p>Most programmers recognize and use the technology called <em>gcc</em>, but few know that it is based on early compiler peepholing techniques explored by Fraser and Davidson. That technology is called RTL.</p>

<p>Technologies, that look similarly useful, include Cordy&#8217;s <em>OCG</em> and Holt&#8217;s <em>Data Descriptors</em>. Holt&#8217;s/Cordy&#8217;s/Wortman&#8217;s <em>S/SL</em> is a forerunner of PEG-like technologies. Cordy&#8217;s TXL uses backtracking to parse programming languages.</p>

<p>I believe that compiler parsing technologies<a href="#fn:3" id="fnref:3" title="see footnote" class="footnote"><sup>3</sup></a> are ripe for picking making available to mortal programmers. Such technology needs to be REGEX&#8217;ed.</p>

<p>Since inventing assembler, we (the royal we) have found utility in inventing 1<sup>st</sup>-class functions, and, garbage collection, and, relational programming, and, &#8230;</p>

<p>Is there a triple-like notation that employs 1<sup>st</sup>-class functions and garbage collection? Early Lisp<a href="#fn:4" id="fnref:4" title="see footnote" class="footnote"><sup>4</sup></a> was an early form of this kind of thing. Relational Programming might give us some clues. OO and FP might give us clues. Closures and anonymous functions (found in Lisp, and more recent languages like JavaScript and Python) give us clues. Hierarchical filesystems might give us a clue.</p>

<p>Of course, assembler can do any of the above, but it needs to be skinned for human readability and complexity management.</p>

<p>I favour the use of <em>toolbox languages</em> for building skins. Are there a toolbox languages that make building skins &#8212; SCNs &#8212; easier than using assembler?</p>

<p>We (the royal we) have spent a great deal of effort developing language skins aimed at human readability, and we have not spent much effort on developing languages for machine readability (Rebol and TXL are different takes on this subject).</p>

<h1 id="codethatwritescode">Code That Writes Code</h1>

<p>Note that I do not believe that the discovering the <em>software atom</em> will result in human-readable code.</p>

<p>I want to write code that writes code.</p>

<p>Machine-readable code is better than human-readable code, if one is trying to write code that writes code.</p>

<p>The <em>software atom</em> will result in advances in machine-readable code.</p>

<h1 id="fdd-failuredrivendesign">FDD - Failure Driven Design</h1>

<p>In another essay, I discuss FDD &#8212; Failure Driven Design.</p>

<p>When software works, we abandon it (&#8220;release&#8221; it).</p>

<p>When software doesn&#8217;t work, we work on it.</p>

<p>Most of the time, we work on failed code (design, code, etc.).</p>

<p><em>Relational programming</em> ties in with FDD as one of the possible technologies for writing code that writes code.</p>

<h1 id="whatsmissingwhattothrowout">What&#8217;s Missing? What to Throw Out?</h1>

<p>The current forms of relational programming &#8212; PROLOG and miniKanren &#8212; have <em>nothing</em> missing.</p>

<p>I believe that current relational programming languages encourage the use of <em>too much</em> detail.</p>

<p>Details kill.</p>

<p>A programming language, to be useful, needs to elide details (but not ignore them).</p>

<p>No language can be The One Language to Rule Them All.</p>

<p>We need multiple skins &#8212; SCLs &#8212; that help us elide details in a problem-specific way.</p>

<p>The <em>good part</em> of relational programming is the notion that pattern-matching can be done automatically and under-the-hood.</p>

<p>The <em>bad parts</em> of relational programming are everything else.</p>

<p>For example, I would rather use <em>printf</em> to format output strings than trying to fit formatting into the relational paradigm (it is <em>possible</em>, but it is not pretty).</p>

<p>Relational programming should stick to triples only. Functors that have more than 2 arguments should not be used. (In fact, functors that have 0 or 1 arguments are questionable, too. Machines like repetitive code. No edge-cases. Everything in the form of <em>relation(subject,object)</em>).</p>

<h1 id="patternmatching">Pattern Matching</h1>

<p>The latest crop of FP (functional programming) skins use <em>pattern matching</em>.</p>

<p>This technology was invented and explored in the 1960&#8217;s under the name of <em>parsers</em>.</p>

<p>Is FP the modern manifestation of pattern matching?</p>

<p>To use FP, you have to expunge <em>time</em>.</p>

<p>That&#8217;s a big hit.</p>

<p>FP, also, is based on a very old skin called <em>mathematics</em>. Mathematics was invented when all that we had was paper (and pencils and pens). We can build 2D skins using computers. We can build 3D skins using 3D printers (we can <em>model</em> 3D skins using CAD software).</p>

<p>IMO, PEG is the modern manifestation of pattern matching.</p>

<p>You can keep <em>f(t)</em> using parsers and PEG.</p>

<p>In fact, S/SL showed how to build <em>f(t)</em> processors.</p>

<p>(One can use pipelines to chain FP beads together into <em>f(t)</em> handlers).</p>

<h1 id="isolation-encapsulationisnotenough">Isolation - Encapsulation is Not Enough</h1>

<p>We (the royal we) invented <em>isolation</em> in the form of UNIXÂ® processes and pipelines.</p>

<p>Then, we threw such <em>isolation</em> away and settled for <em>encapsulation</em> in the form of OO, etc.</p>

<p>We now know that <em>encapsulation</em> is not enough &#8212; we cannot bolt programs together in a care-free manner using only <em>encapsulation</em>.</p>

<p>We want to <em>build-and-forget</em> programs. We need to expunge inter-program dependencies. In other words, we want <em>isolation</em>.</p>

<p>Worse, yet, our present-day hardware creates dynamic dependency chains under-the-hood.</p>

<p>Our hardware just about forces us to produce CALL/RETURN Spaghetti.</p>

<p>Relational programming (and FP) gives us a way to talk about solutions that create no dependency chains.</p>

<p>Is that enough? No. But it&#8217;s a start.</p>

<p>Do we already have all of the pieces and Atoms that we need to propel programming into the future? Maybe.</p>

<h1 id="concurrency">Concurrency</h1>

<p>To be able to bolt software components together, we must make use concurrent software components.</p>

<p>CALL /RETURN Spaghetti encourages edge-cases and thwarts attempts at <em>easy</em> machine-readability.</p>

<p>We (the royal we) have been dealing with concurrency in the wrong manner &#8212; optimizing for memory sharing and time-sharing. This approach has generated a multitude of accidental complexities.</p>

<p>We (the royal we) don&#8217;t need memory sharing and time-sharing built into <em>every</em> app. Only a few apps need these features (e.g. operating systems,<a href="#fn:5" id="fnref:5" title="see footnote" class="footnote"><sup>5</sup></a> like Linux, Window and MacOS). Making apps that include concurrency (but don&#8217;t really use it) is asking for trouble.</p>

<h1 id="scns-onelanguagedoesnotfitall">SCNs - One Language Does Not Fit All</h1>

<p>Languages are skins.</p>

<p>I have a cavalier attitude towards languages, because I know that we can build notations (languages) in only a few hours.</p>

<p>I view notations like a bowl of candy sprinkles. Sprinkle several notations on every problem, to make the solution simpler to express, and, to program.</p>

<h1 id="humanreadabilityvs.machinereadability">Human Readability vs. Machine Readability</h1>

<p>The <em>key</em> to writing code that writes code is to cleave &#8220;Programming Languages&#8221; into two camps (maybe more, recursively):</p>

<ol>
<li>Programming Languages for Humans</li>
<li>Programming Languages for Machines.</li>
</ol>

<p>Programming Languages for Machines can lead to code that writes code, to projectional editing, etc.</p>

<p>A lot of techniques for writing code that writes code were explored in the early days of computing, under the name of <em>compiler technologies</em>.</p>

<p>Lisp <em>macros</em> are another manifestation of such technology.</p>

<p>[<em>The problem with Lisp macros is that we tried to include compiler technology into the skins. This raised the (accidental) complexity of the problem. Combining technologies &#8212; flattening them &#8212; is almost always a bad idea.</em>]</p>

<h1 id="thegoalofprogramming">The Goal of Programming</h1>

<p>The point of programming is to automate processes, using a computer.</p>

<p>All technologies for programming should strive to answer the question of how to automate a process using a computer.</p>

<h1 id="completenesstheoreticalapproachesprogramming">Completeness, Theoretical Approaches, Programming</h1>

<p>Many programmers feel that the &#8220;best&#8221; way to automate processes is to delve into all of the details in excruciating detail, in a non-hierarchical (flat) manner. I.E. language theories and skins for &#8220;proving&#8221; language designs.</p>

<p>We have seen progress on this front, but, it is obvious that this does not result in programming skins that are accessible to mortal programmers.</p>

<p>Language theory provides a solid description of the <em>universe</em> of programming languages, but, tends not to address the problems of finding expressible versions of skins that are &#8220;walks&#8221; through the <em>universe</em>.</p>

<figure>
<img src="/assets/2021-04-23-18-38-46-Images/WalkingtheUniverse-Page-1.png" alt="" id="walkingtheuniverse-page-1" width="200" height="219" />
<figcaption></figcaption>
</figure>

<p>Fig. 1 Walks Through The Language Universe</p>

<p>Relational programming is (but) one manifestation of language theory.</p>

<p>Making something simpler is usually begun by starting out simple instead of by adding complexity.<a href="#fn:6" id="fnref:6" title="see footnote" class="footnote"><sup>6</sup></a></p>

<h1 id="throwingstuffout">Throwing Stuff Out</h1>

<p>To make language theory, and relational programming, <em>useful</em> to mortal programmers, we (the royal we) need to <em>throw stuff out</em>.</p>

<p>I suggest that we remove just about <em>everything</em> from relational programming, and leave only <em>triples</em> and exhaustive search.</p>

<h1 id="denotationalsemantics-realisticcompilergeneration">Denotational Semantics - Realistic Compiler Generation</h1>

<p>Peter Lee&#8217;s book &#8220;Realistic Compiler Generation&#8221; shows how he managed an overtly complex technology &#8212; Denotational Semantics &#8212; by chopping it up into pieces, and pipelining the pieces.</p>

<p>Further work on this idea was performed by Uwe Pleban.</p>

<p>There is no need to devolve all of computing to the expression of Natural Numbers. Except in theoretical expressions of the Universe of Programming.</p>

<p>The <em>goal</em> of creating <em>useful</em> skins is to build a Component using hierarchies of isolated components and finding notations for the <em>input</em> and the <em>output</em> of each subdivision.</p>

<p>&#8220;Realistic Compiler Generation&#8221; shows but one kind of possible skin for expressing denotational semantics in a <em>useful</em> form.</p>

<h1 id="engineering">Engineering</h1>

<p>Engineering is not coding.</p>

<p>Implementation is coding.</p>

<p>Engineering is the process of defining the details that lie between the Architecture and the Implementation.</p>

<p>As such, relational programming might lead to a skin(s) for expressing <em>engineering</em> concerns (in a hierarchical &#8212; divide-and-conquer &#8212; manner, composing isolated components together into a solution).</p>

<h1 id="noneedtowaitforcompleterigour">No Need To Wait For Complete Rigour</h1>

<p>Complete Rigour is certainly something to strive for, but, complete rigor is not necessary for delivering product.</p>

<p>In fact, if we&#8217;d waited for theoretically complete rigour, we would not have an electronics industry.<a href="#fn:7" id="fnref:7" title="see footnote" class="footnote"><sup>7</sup></a></p>

<p>Re-using what we&#8217;ve learned from various forms of Engineering &#8212; Civil, Structural, etc. Engineering &#8212; we see that we <em>can</em> deliver products without having an overall rigorous theory for the given domain.</p>

<p>My first full-time job was as a Software Test Engineer with Mitel Corp.</p>

<p>Mitel is a Telecom company (like Bell and NorTel, etc.). At the time, all Telecoms professed the four-nines principle &#8212; 99.99% uptime. People would telephone each other during power failures and not even notice that the telephone networks were still working, although the power grid had failed.</p>

<p>All of this was done with early computing technologies, and with software written in assembler and early programming languages &#8212; long before the advent of FP, Haskell, etc.</p>

<p>Testing. Most theorists look down on testing, but, testing <em>can</em> be used to create useful, and, saleable, and, guarantee-able products. To deliver products using only testing instead of rigorous theories, one needs to apply many layers of testing. CI/CD is only <em>one</em> form of testing (regression testing). Mitel used, at least, automated testing, analogue testing, back-to-back testing, trace analysis testing, etc., etc.</p>

<p>For Telecoms, and for current companies, rigorous theories can only serve to cost-reduce products by reducing testing costs (while increasing development costs and narrowing the kinds of programmers that can perform development tasks).</p>

<p>Can theories provide order-of-magnitude benefits, like PEG vs. YACC? Maybe, but, we are still waiting.</p>

<h1 id="das-diagramsassyntax">DaS - Diagrams as Syntax</h1>

<p>Relations make parsing diagrams &#8220;easy&#8221;.</p>

<p>Parsing a diagram consists of:</p>

<ul>
<li>normalizing the elements of a diagram (e.g. rectangles, ellipses, lines, text &#8212; in other words SVG simplified (see <a href="#throwingstuffout">Throwing Stuff Out</a>))</li>
<li>pattern-matching the elements</li>
<li>formatting output code.</li>
</ul>

<p>For example, a rectangle can be described as:</p>

<ul>
<li>a declaration of a unique ID</li>
<li>4 lines</li>
<li>x for each line</li>
<li>y for each line</li>
<li>width for each line</li>
<li>height for each line.</li>
</ul>

<p>To do this, we need:</p>

<ol>
<li>an editor &#8212; a <em>simple</em><a href="#fn:8" id="fnref:8" title="see footnote" class="footnote"><sup>8</sup></a> diagram editor that allows creation rectangles, ellipses, lines (straight, curvy, arrow-headed), text</li>
<li>a transpiler that normalizes the output of the editor</li>
<li>a pattern matcher</li>
<li>an output code formatter.</li>
</ol>

<p>Step (2) converts the editor output into relational triples &#8212; a <em>factbase</em>.</p>

<p>Step (3) uses relational programming &#8212; e.g. PROLOG or miniKanren &#8212; to infer information about the diagram and the programming conventions.</p>

<p>Using modern-day computers, we can expend CPU power to perform step (3) at runtime, saving head-scratching during design- and compile- times.</p>

<p>[<em>Q: Why do I champion triples instead of structured forms? A: Triples are more easily machine-readable than more elaborate data structures.</em>]<a href="#fn:9" id="fnref:9" title="see footnote" class="footnote"><sup>9</sup></a></p>

<h1 id="appendix-everythingisafractal">Appendix - Everything is a Fractal</h1>

<p><a href="https://guitarvydas.github.io/2021/03/23/Everything-is-a-Fractal.html">https://guitarvydas.github.io/2021/03/23/Everything-is-a-Fractal.html</a></p>

<h1 id="appendix-prologprogrammingforprogrammers">Appendix - PROLOG Programming for Programmers</h1>

<p><a href="https://www.youtube.com/channel/UC2bdO9l84VWGlRdeNy50fIg">https://www.youtube.com/channel/UC2bdO9l84VWGlRdeNy50fIg</a></p>

<h1 id="appendix-factbases">Appendix - Factbases</h1>

<p><a href="https://guitarvydas.github.io/2021/01/17/Factbases.html">https://guitarvydas.github.io/2021/01/17/Factbases.html</a></p>

<h1 id="appendix-triples">Appendix - Triples</h1>

<p><a href="https://guitarvydas.github.io/2021/03/16/Triples.html">https://guitarvydas.github.io/2021/03/16/Triples.html</a></p>

<h1 id="appendix-languagesareskins">Appendix - Languages Are Skins</h1>

<p><a href="https://guitarvydas.github.io/2020/12/09/Programming-Languages-Are-Skins.html">https://guitarvydas.github.io/2020/12/09/Programming-Languages-Are-Skins.html</a></p>

<h1 id="appendix-scns-solutioncentricnotations">Appendix - SCNs - Solution Centric Notations</h1>

<p><a href="https://guitarvydas.github.io/2021/04/10/SCN.html">https://guitarvydas.github.io/2021/04/10/SCN.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/DSL-Manifesto.html">https://guitarvydas.github.io/2020/12/09/DSL-Manifesto.html</a></p>

<h1 id="appendix-rtl">Appendix - RTL</h1>

<p><a href="https://www.researchgate.net/publication/220404697_The_Design_and_Application_of_a_Retargetable_Peephole_Optimizer">https://www.researchgate.net/publication/220404697_The_Design_and_Application_of_a_Retargetable_Peephole_Optimizer</a></p>

<h1 id="appendix-peg">Appendix - PEG</h1>

<p><a href="https://guitarvydas.github.io/2020/12/27/PEG.html">https://guitarvydas.github.io/2020/12/27/PEG.html</a></p>

<p><a href="https://guitarvydas.github.io/2021/03/17/PEG-vs.-Other-Pattern-Matchers.html">https://guitarvydas.github.io/2021/03/17/PEG-vs.-Other-Pattern-Matchers.html</a></p>

<p><a href="https://guitarvydas.github.io/2021/03/24/REGEX-vs-PEG.html">https://guitarvydas.github.io/2021/03/24/REGEX-vs-PEG.html</a></p>

<p><a href="https://guitarvydas.github.io/2021/04/02/PEG-Cheat-Sheet.html">https://guitarvydas.github.io/2021/04/02/PEG-Cheat-Sheet.html</a></p>

<p>Ohm-JS (PEG for Javascript):</p>

<p><a href="https://guitarvydas.github.io/2020/12/09/OhmInSmallSteps.html">https://guitarvydas.github.io/2020/12/09/OhmInSmallSteps.html</a></p>

<p><a href="https://github.com/harc/ohm">https://github.com/harc/ohm</a></p>

<p>PEG for Lisp:</p>

<p><a href="https://guitarvydas.github.io/2021/03/19/Racket-PEG.html">https://guitarvydas.github.io/2021/03/19/Racket-PEG.html</a></p>

<p><a href="https://scymtym.github.io/esrap/">https://scymtym.github.io/esrap/</a></p>

<p>PEG for JS:</p>

<p><a href="https://pegjs.org/">https://pegjs.org/</a></p>

<p>Thesis, etc.:</p>

<p><a href="https://bford.info/packrat/">https://bford.info/packrat/</a></p>

<p>Note: I believe that the Ohm Editor is a breakthrough tool: <a href="https://ohmlang.github.io/editor/">https://ohmlang.github.io/editor/</a></p>

<p>[<em>The Ohm Editor is an IDE for rapidly debugging PEG pattern-matching specs (aka grammars)</em>]</p>

<p>What I do with Ohm-JS:</p>

<ul>
<li>Glue Tool (a PEG to help writing PEGs):

<ul>
<li>https://guitarvydas.github.io/2021/04/11/Glue-Tool.html</li>
</ul></li>
<li>Recursive Design

<ul>
<li><a href="https://guitarvydas.github.io/2021/04/12/Recursive-Iterative-Design-By-Example.html">https://guitarvydas.github.io/2021/04/12/Recursive-Iterative-Design-By-Example.html</a></li>
<li><a href="https://guitarvydas.github.io/2021/04/20/Recursive-Design,-Iterative-Design-By-Example-(2).html">https://guitarvydas.github.io/2021/04/20/Recursive-Design,-Iterative-Design-By-Example-(2).html</a></li>
</ul></li>
<li>ASON parser (most of one):

<ul>
<li>https://guitarvydas.github.io/2021/04/10/ASON-Notation-Pipeline.html</li>
</ul></li>
<li>GRASEM Tool

<ul>
<li><a href="https://guitarvydas.github.io/2021/04/11/Grasem.html">https://guitarvydas.github.io/2021/04/11/Grasem.html</a></li>
</ul></li>
<li>etc.</li>
</ul>

<h1 id="appendix-ocg">Appendix - OCG</h1>

<p><a href="https://books.google.ca/books?id=X0OaMQEACAAJ&amp;dq=bibliogroup:%22University+of+Toronto+Computer+Systems+Research+Institute+Technical+Report+CSRI%22&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwig1Legm8bqAhWvlHIEHYzzBYEQ6AEwBHoECAEQAQs">https://books.google.ca/books?id=X0OaMQEACAAJ&amp;dq=bibliogroup:%22University+of+Toronto+Computer+Systems+Research+Institute+Technical+Report+CSRI%22&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwig1Legm8bqAhWvlHIEHYzzBYEQ6AEwBHoECAEQAQs</a></p>

<h1 id="appendix-ssl">Appendix - S/SL</h1>

<p><a href="https://research.cs.queensu.ca/home/cordy/pub/downloads/ssl/">https://research.cs.queensu.ca/home/cordy/pub/downloads/ssl/</a></p>

<h1 id="appendix-datadescriptors">Appendix - Data Descriptors</h1>

<p><a href="https://dl.acm.org/doi/abs/10.1145/24039.24051">https://dl.acm.org/doi/abs/10.1145/24039.24051</a></p>

<h1 id="appendix-minikanren">Appendix - MiniKanren</h1>

<p><a href="http://minikanren.org/">http://minikanren.org/</a></p>

<p>(must see, if you haven&#8217;t already heard about Barliman: <a href="https://www.youtube.com/watch?v=er_lLvkklsk">https://www.youtube.com/watch?v=er_lLvkklsk</a> (<a href="https://github.com/webyrd/Barliman">https://github.com/webyrd/Barliman</a>))</p>

<h1 id="appendix-prolog">Appendix - PROLOG</h1>

<p><a href="https://www.youtube.com/watch?v=QOYAHoLiyg0&amp;t=199s">https://www.youtube.com/watch?v=QOYAHoLiyg0&amp;t=199s</a></p>

<p>modern PROLOG:</p>

<p><a href="https://www.swi-prolog.org/">https://www.swi-prolog.org/</a></p>

<p>(gprolog uses WAM: <a href="http://www.gprolog.org/">http://www.gprolog.org/</a>)</p>

<p>(beginnings of a WAM: <a href="https://github.com/guitarvydas/wam">https://github.com/guitarvydas/wam</a>)</p>

<p>(WAM tutorial: <a href="http://wambook.sourceforge.net/">http://wambook.sourceforge.net/</a>)</p>

<h1 id="appendix-parsingdiagrams">Appendix - Parsing Diagrams</h1>

<p><a href="https://guitarvydas.github.io/2021/04/11/Compiling-Diagrams.html">https://guitarvydas.github.io/2021/04/11/Compiling-Diagrams.html</a></p>

<p><a href="https://guitarvydas.github.io/2021/01/16/Transpiling-Diagrams-to-Code-101.html">https://guitarvydas.github.io/2021/01/16/Transpiling-Diagrams-to-Code-101.html</a></p>

<p><a href="https://guitarvydas.github.io/2021/01/24/Compiling-Diagrams-2.html">https://guitarvydas.github.io/2021/01/24/Compiling-Diagrams-2.html</a></p>

<p><a href="https://guitarvydas.github.io/2021/03/16/component-diagrams.html">https://guitarvydas.github.io/2021/03/16/component-diagrams.html</a></p>

<p><a href="https://guitarvydas.github.io/2021/01/12/Transpiling-Diagrams-to-Code-101.html">https://guitarvydas.github.io/2021/01/12/Transpiling-Diagrams-to-Code-101.html</a></p>

<p><a href="https://guitarvydas.github.io/2021/01/10/Transpiling-Diagrams-Overview.html">https://guitarvydas.github.io/2021/01/10/Transpiling-Diagrams-Overview.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/Parsing-and-Compiling-Diagrams.html">https://guitarvydas.github.io/2020/12/09/Parsing-and-Compiling-Diagrams.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/Diagram-Based-Languages.html">https://guitarvydas.github.io/2020/12/09/Diagram-Based-Languages.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/Editor-for-Gratoms.html">https://guitarvydas.github.io/2020/12/09/Editor-for-Gratoms.html</a></p>

<h1 id="appendix-toolboxlanguages">Appendix - Toolbox Languages</h1>

<p><a href="https://guitarvydas.github.io/2021/03/16/Toolbox-Languages.html">https://guitarvydas.github.io/2021/03/16/Toolbox-Languages.html</a></p>

<h1 id="appendix-txl">Appendix - TXL</h1>

<p><a href="https://www.txl.ca/">https://www.txl.ca/</a></p>

<h1 id="appendix-rebolason">Appendix - Rebol, ASON</h1>

<p><a href="https://en.wikipedia.org/wiki/Rebol">https://en.wikipedia.org/wiki/Rebol</a></p>

<p><a href="http://www.rebol.com/">http://www.rebol.com/</a></p>

<p><a href="https://github.com/rebol/rebol">https://github.com/rebol/rebol</a></p>

<p><a href="https://github.com/red/red/blob/master/README.md#red-programming-language">https://github.com/red/red/blob/master/README.md#red-programming-language</a></p>

<p>ASON</p>

<p><a href="https://altscript.com/">https://altscript.com/</a></p>

<h1 id="appendix-detailskill">Appendix - Details Kill</h1>

<p><a href="https://guitarvydas.github.io/2021/03/17/Details-Kill.html">https://guitarvydas.github.io/2021/03/17/Details-Kill.html</a></p>

<h1 id="appendix-isolation">Appendix - Isolation</h1>

<p><a href="https://guitarvydas.github.io/2020/12/09/Isolation.html">https://guitarvydas.github.io/2020/12/09/Isolation.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/Scalability.html">https://guitarvydas.github.io/2020/12/09/Scalability.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/Scalability-II.html">https://guitarvydas.github.io/2020/12/09/Scalability-II.html</a></p>

<h1 id="appendix-thestack">Appendix - The Stack</h1>

<p>ALGOL Bottleneck:</p>

<p>https://www.youtube.com/watch?v=NTdA4OljwVE</p>

<p><a href="https://guitarvydas.github.io/2020/12/25/The-ALGOL-Bottleneck.html">https://guitarvydas.github.io/2020/12/25/The-ALGOL-Bottleneck.html</a></p>

<p>The Stack:</p>

<p><a href="https://guitarvydas.github.io/2020/12/27/The-Stack-2.html">https://guitarvydas.github.io/2020/12/27/The-Stack-2.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/25/The-Stack.html">https://guitarvydas.github.io/2020/12/25/The-Stack.html</a></p>

<p><a href="https://guitarvydas.github.io/2021/02/25/The-Stack-is-a-Global-Variable-(again).html">https://guitarvydas.github.io/2021/02/25/The-Stack-is-a-Global-Variable-(again).html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/24/The-Stack-is-a-List.html">https://guitarvydas.github.io/2020/12/24/The-Stack-is-a-List.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/Type-Stacks.html">https://guitarvydas.github.io/2020/12/09/Type-Stacks.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/Two-Stacks-For-Every-Type.html">https://guitarvydas.github.io/2020/12/09/Two-Stacks-For-Every-Type.html</a></p>

<h1 id="appendix-realisticcompilergeneration">Appendix - Realistic Compiler Generation</h1>

<p><a href="https://www.amazon.ca/Realistic-Compiler-Generation-Peter-Lee/dp/0262121417">https://www.amazon.ca/Realistic-Compiler-Generation-Peter-Lee/dp/0262121417</a></p>

<h1 id="appendix-continuumbetweencompile-timeandrun-time">Appendix - Continuum Between Compile-time and Run-time</h1>

<p><a href="https://guitarvydas.github.io/2020/12/09/Efficiency.html">https://guitarvydas.github.io/2020/12/09/Efficiency.html</a></p>

<h1 id="appendix-codethatwritescode">Appendix - Code That Writes Code</h1>

<p>[<em>essay to come, for now see examples</em>]</p>

<p><a href="https://guitarvydas.github.io/2021/04/11/Glue-Tool.html">https://guitarvydas.github.io/2021/04/11/Glue-Tool.html</a></p>

<h1 id="ref1">Appendix - Toolbox Languages</h1>

<p><a href="https://guitarvydas.github.io/2021/03/16/Toolbox-Languages.html">https://guitarvydas.github.io/2021/03/16/Toolbox-Languages.html</a></p>

<h1 id="appendix-callreturnspaghetti">Appendix - Call Return Spaghetti</h1>

<p><a href="https://guitarvydas.github.io/2020/12/09/CALL-RETURN-Spaghetti.html">https://guitarvydas.github.io/2020/12/09/CALL-RETURN-Spaghetti.html</a></p>

<h1 id="appendix-fdd-failuredrivendevelopment">Appendix - FDD - Failure Driven Development</h1>

<p><a href="https://guitarvydas.github.io/2021/04/23/Failure-Driven-Design.html">https://guitarvydas.github.io/2021/04/23/Failure-Driven-Design.html</a></p>

<h1 id="appendix-prologcontrolin6slides">Appendix - Prolog Control in 6 Slides</h1>

<p><a href="https://www.t3x.org/bits/prolog6.html">https://www.t3x.org/bits/prolog6.html</a></p>

<h1 id="appendix-concurrency">Appendix - Concurrency</h1>

<p><a href="https://guitarvydas.github.io/2020/12/09/Concurrency-is-a-Paradigm.html">https://guitarvydas.github.io/2020/12/09/Concurrency-is-a-Paradigm.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/Computing-Then-and-Now.html">https://guitarvydas.github.io/2020/12/09/Computing-Then-and-Now.html</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/Concurrency-is-not-Parallelism.html">https://guitarvydas.github.io/2020/12/09/Concurrency-is-not-Parallelism.html</a></p>

<h1 id="appendix-diagram-basedvisualprogramming">Appendix - Diagram-Based Visual Programming</h1>

<p><a href="https://guitarvydas.github.io/2020/12/09/Diagram-Based-Languages.html">https://guitarvydas.github.io/2020/12/09/Diagram-Based-Languages.html</a></p>

<p><a href="https://www.youtube.com/watch?v=2uw2W0w5oU8">https://www.youtube.com/watch?v=2uw2W0w5oU8</a></p>

<h1 id="appendix-otherreferences">Appendix - Other References</h1>

<p><a href="https://www.youtube.com/channel/UC2bdO9l84VWGlRdeNy50fIg">https://www.youtube.com/channel/UC2bdO9l84VWGlRdeNy50fIg</a></p>

<p><a href="https://guitarvydas.github.io/2020/12/09/References.html">https://guitarvydas.github.io/2020/12/09/References.html</a></p>

<p>FBP (Flow-Based Programming, concurrency, diagrams)</p>

<ul>
<li><a href="https://jpaulm.github.io/fbp/">https://jpaulm.github.io/fbp/</a></li>
</ul>

<p>noFlo</p>

<ul>
<li><a href="https://noflojs.org/">https://noflojs.org/</a></li>
</ul>

<ol>
<li>(experimental code, many branches)
<a href="https://github.com/bmfbp/bmfbp">https://github.com/bmfbp/bmfbp</a></li>
</ol>

<p>Arrowgrams (experimental code, many branches)</p>

<ul>
<li><a href="https://github.com/bmfbp/bmfbp">https://github.com/bmfbp/bmfbp</a></li>
<li><a href="https://github.com/guitarvydas/vsh">https://github.com/guitarvydas/vsh</a></li>
</ul>

<h1 id="appendix-everythingbutthekitchensink">Appendix - Everything but the Kitchen Sink</h1>

<p><a href="https://www.theidioms.com/everything-but-the-kitchen-sink/">https://www.theidioms.com/everything-but-the-kitchen-sink/</a></p>

<div class="footnotes">
<hr />
<ol>

<li id="fn:1">
<p>Until the pieces are so small that they can be implemented in only a few hours. (Two weeks is too long &#8211; and indicates that more subdivision is necessary). <a href="#fnref:1" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:2">
<p>I believe that SCNs are orders&#8211;of&#8211;magnitude cheaper to build than DSLs and PLs (Domain&#8211;Specific Languages and Programming Languages, resp.). I discuss this elsewhere (see appendix). <a href="#fnref:2" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:3">
<p>I argue that we need PEG with backtracking and tokenizing. <a href="#fnref:3" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:4">
<p>But, then, Lisp was beat into the ground with complexity&#8211;hammers and became Common Lisp. <a href="#fnref:4" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:5">
<p>In fact, we don't even need operating systems. Operating systems are just code libraries. <a href="#fnref:5" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:6">
<p>Although simplication is a factor https://en.wikipedia.org/wiki/William_Bushnell_Stout#:~:text=published%20in%201951.&#8211;,Legacy,Colin%20Chapman%20of%20Lotus%20Cars.</p>

<p>Computers are &#8220;complex&#8221; to begin with. They need to be skinned to allow access to them by mere mortals. Simplication. Likewise, CPUs are complex and are simplicated (from various kinds of rust to ICs by electronics chip manufacturers) for use by programmers. <a href="#fnref:6" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:7">
<p>Aside: Scientists like to talk about a TOE (a Theory of Everything), but, this will not be possible until Science can explain consciousness (among other factors) without hand&#8211;waving arguments like &#8220;emergent properties&#8221;. <a href="#fnref:7" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:8">
<p>Most existing diagram editors are much too complex. Details kill. <a href="#fnref:8" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:9">
<p>Machines can structure data for us, at runtime. I think of a continuum between compile&#8211;time and run&#8211;time. In fact, all software is interpreted, anyway (a CPU is an interpreter). The only question is &#8220;when does the interpretation happen?&#8221; <a href="#fnref:9" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

</ol>
</div>

<script src="https://utteranc.es/client.js" 
        repo="guitarvydas/guitarvydas.github.io" 
        issue-term="pathname" 
        theme="github-light" 
        crossorigin="anonymous" 
        async> 
</script> 
</body>
</html>

