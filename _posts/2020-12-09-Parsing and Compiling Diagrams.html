<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>Parsing and Compiling Diagrams</title>
  <meta name="Author" content="Paul Tarvydas">
  <meta name="CreationTime" content="2020-12-09T15:13:37Z">
  <meta name="ModificationTime" content="2020-12-09T15:13:37Z">
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.6">
  <style type="text/css">
    p.p1 {margin: 13.0px 0.0px 0.0px 0.0px; font: 28.0px Palatino}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 28.0px Palatino; min-height: 37.0px}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino}
    p.p7 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo}
    p.p8 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo; min-height: 13.0px}
    p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; color: #000000}
    p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino}
    p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; -webkit-text-stroke: #0000e9}
    p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; -webkit-text-stroke: #0000e9; min-height: 18.0px}
    p.p14 {margin: 0.0px 0.0px 0.0px 36.0px; text-indent: -36.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; -webkit-text-stroke: #0000e9}
    p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; -webkit-text-stroke: #0000e9; min-height: 18.0px}
    p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 11.0px Menlo}
    p.p22 {margin: 0.0px 0.0px 0.0px 36.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p23 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p24 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p25 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; -webkit-text-stroke: #0000e9}
    li.li10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino}
    li.li11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; min-height: 18.0px}
    span.s1 {color: #000000}
    span.s2 {font: 12.0px Times; text-decoration: underline ; font-kerning: none; color: #0000e9}
    span.s3 {font: 12.0px Times; font-kerning: none; color: #0000e9}
    span.s4 {font-kerning: none}
    span.s5 {-webkit-text-stroke: 0px #000000}
    span.s6 {font: 12.0px Times; text-decoration: underline ; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s7 {-webkit-text-stroke: 0px #0000e9}
    span.s8 {font: 13.0px Palatino; color: #000000}
    span.s9 {font: 12.0px Times; text-decoration: underline ; font-kerning: none}
    span.s10 {font: 9.0px Palatino}
    span.s11 {text-decoration: underline}
    span.s12 {text-decoration: underline ; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s13 {font: 13.0px Palatino}
    span.s14 {font: 12.0px Helvetica}
    span.s15 {font: 12.0px Helvetica; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s16 {font: 13.0px Palatino; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s17 {font: 13.0px Palatino; text-decoration: underline ; font-kerning: none}
    span.Apple-tab-span {white-space:pre}
    ol.ol1 {list-style-type: decimal}
    ul.ul1 {list-style-type: disc}
    ul.ul2 {list-style-type: circle}
  </style>
</head>
<body>
<div style="width: 600px; margin: 0 auto">

<p class="p1">On Compiling Diagrams to Code</p>
<p class="p2"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Disclaimer</b></h2>
<p class="p4"><br></p>
<p class="p5">This essay is not meant to be an academic work. <span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">It contains my opinions from 30+ years of experience in the Software field, running a software consultancy.</p>
<p class="p4"><br></p>
<p class="p5">As such, references, when included, refer to inspiration and may not be thoroughly researched.</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<h1 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 18.0px Palatino"><b>Introduction</b></h1>
<p class="p4"><br></p>
<p class="p5">This essay discusses a simple compiler that compiles diagrams to executable code.</p>
<p class="p4"><br></p>
<p class="p5">I believe that diagrams can express certain design elements more easily than textual code.<span class="Apple-converted-space">  </span>For example, many people draw box &amp; arrow pictures of a desired system on a whiteboard.<span class="Apple-converted-space">  </span>Such diagrams form a “syntax” for system design.<span class="Apple-converted-space">  </span>This “syntax” can be made more concrete and can be automatically compiled to code (the old idea of “executable specification” becomes a reality).<span class="Apple-converted-space">  </span>To make this transition, one needs to “think like a compiler builder” and ask oneself “can I imagine compiling these graphics to code?”.<span class="Apple-converted-space">  </span>For example, diagrams of stick people and clouds probably cannot be compiled.<span class="Apple-converted-space">  </span>Diagrams of boxes and arrows can be compiled to executable code, when one creates and follows certain conventions.</p>
<p class="p4"><br></p>
<p class="p5">In my opinion, diagrams are most useful in the hands of professionals, not children.<span class="Apple-converted-space">  </span>Most real-world Engineering professions use diagrams, e.g. EE’s use schematics, Civil Engineers use blueprints, etc.</p>
<p class="p4"><br></p>
<p class="p5">In my opinion, diagrams should <i>not</i> be used to express ideas that are already, sufficiently expressed in textual code, for example</p>
<p class="p4"><br></p>
<p class="p7">a = b + c;</p>
<p class="p8"><br></p>
<p class="p5">should not be drawn as a diagram.<span class="Apple-converted-space">  </span>Such statements communicate perfectly well when written in text form.</p>
<p class="p4"><br></p>
<p class="p5">Text cannot express - conveniently - a network diagram, for example.<span class="Apple-converted-space">  </span>A network as text, is a list of components and a detailed “wiring list” between such components and does not communicate the layout of the network to other human readers.<span class="Apple-converted-space">  </span>For such cases, diagrams excel.</p>
<p class="p4"><br></p>
<p class="p5">In fact, I believe that a single language cannot express all of the nuances of Software Design.<span class="Apple-converted-space">  </span>I believe that multiple languages need to be used, e.g. diagrams for software architecture, text code for implementation details, etc.<span class="Apple-converted-space">  </span>Already, we see many different languages being used in the software creation / distribution pipelines, e.g. bash, npm, gradle, HTTP, CSS, yaml, Docker, etc.</p>
<p class="p4"><br></p>
<p class="p5">In this essay, I show how to create compilable conventions for drawing such a network diagram<span class="Apple-converted-space">  </span>and how to compile it to executable code. <span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">The diagrams discussed here are <i>hybrids</i> - diagrams with text annotations.<span class="Apple-converted-space">  </span>A diagram does not <i>need</i> to express every possible operation.<span class="Apple-converted-space">  </span>A diagram needs only to express operations that are not conveniently written as text.</p>
<p class="p4"><br></p>
<p class="p5">Most diagram editors do not make good code editors (DaS - diagrams as syntax).<span class="Apple-converted-space">  </span>The creation of better DaS editors is discussed in another essay.<span class="Apple-converted-space">  </span>[Programmers use all 10 fingers, not just a single mouse].</p>
<p class="p4"><br></p>
<p class="p9"><span class="s1">For now, we will use a free editor called Draw.IO (<a href="https://www.draw.io/"><span class="s2">https://www.draw.io/</span></a></span><span class="s2">).</span><span class="s3"> </span><span class="s4">Draw.IO exhibits the drawbacks of known diagram editors - e.g. one often needs to use a mouse. Draw.IO makes assumptions about the drawing (it begins automagically drawing lines between graphical atoms).<span class="Apple-converted-space">  </span>Yet, Draw.IO exists, is free and can produce SVG files.</span></p>
<p class="p4"><br></p>
<p class="p5">The kinds of diagrams we are concerned with are the kinds of diagrams that Engineers use (e.g. Electrical Engineers (schematics), Civil Engineers (blueprints), etc.).</p>
<p class="p4"><br></p>
<p class="p5">These diagrams are not meant to make software design easier for novices.<span class="Apple-converted-space">  </span>They are meant to add further meaning to software designs. <span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">These are<i> technical diagrams.</i></p>
<p class="p4"><br></p>
<p class="p5">I believe that technical diagrams for software design have been overlooked due to a bias that assumes that “diagrams are for kids”.<span class="Apple-converted-space">  </span>In fact, many technical diagrams for software design do exist - on whiteboards in just about every software house.<span class="Apple-converted-space">  </span>Whiteboard diagrams are, typically, not rigorous enough to be compiled to executable code.<span class="Apple-converted-space">  </span>I hope to show that compilable technical diagrams are possible and that they do add information to a software project that cannot be easily expressed as text.</p>
<p class="p4"><br></p>
<p class="p5">The main goal of this essay is to show how modern tools and technologies can be used to implement diagram compilers. We will not emphasise, here, the reasoning behind use of such technical diagrams.</p>
<p class="p4"><br></p>
<p class="p5">If you already know how a compiler works, you can skip the following section.<span class="Apple-converted-space">  </span>Note that, I use the “pass” model for compilers instead of the “tree” model.<span class="Apple-converted-space">  </span>These models are essentially the same, except that the “pass” model uses a pipeline for the compiler and data in the pipeline moves, strictly, from left to right.<span class="Apple-converted-space">  </span>In the “tree”model of compilation, the tree is traversed downward (top down) then upward (bottom up) - if one is more familiar with the tree model, it might help to imagine that the tree has been flattened and passed from left to right. <span class="Apple-converted-space">  </span>I find that the pipeline model “keeps things simple” - each pass does exactly one job instead of folding all compiler work into a single textual script based on tree traversal.<span class="Apple-converted-space">  </span>A major point of simplification is to decompose a problem (in this case a compiler) into subsequent passes (like a bash pipeline) instead of as a data structure.</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<h1 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 18.0px Palatino"><b>Classical Compiler Technology</b></h1>
<p class="p4"><br></p>
<p class="p5">Classical compiler technology splits a text compiler into about four phases, described below.</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10">Scanner</li>
  <li class="li10">Parser</li>
  <li class="li10">Semantic Pass</li>
  <li class="li10">Coder</li>
</ul>
<p class="p11"><br></p>
<p class="p10">Note that this kind of technology is based on “old” ideas, such as : computers are not fast enough to base compilers on backtracking, computers represent <i>text</i> (characters) on the screen, but are too slow and inflexible to represent other glyphs and diagrams on the screen.</p>
<p class="p11"><br></p>
<p class="p10">The above assumptions led to a great deal of research into textual languages and how to restrict languages to allow for compilation without backtracking.</p>
<p class="p11"><br></p>
<p class="p12"><span class="s5">Efforts such as PEG [Bryan Ford, </span><span class="s2">http://bford.info/pub/lang/peg.pdf</span>], TXL [Cordy, <a href="https://www.txl.ca/"><span class="s2">https://www.txl.ca/</span></a>] show that the above assumptions no longer hold true.</p>
<p class="p13"><br></p>
<p class="p13"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Scanner</b></h2>
<p class="p4"><br></p>
<p class="p5">The <i>scanner</i> takes in a stream of characters and outputs a stream of <i>tokens</i>.</p>
<p class="p4"><br></p>
<p class="p5">The main job of a scanner is to ensure that downstream compiler passes do not need to perform string compares.</p>
<p class="p4"><br></p>
<p class="p5">The <i>scanner</i> performs string matching to determine whether a string of characters in a program match with keywords and operators in the language, or whether<span class="Apple-converted-space">  </span>strings of characters fall into the class of user-defined identifiers.</p>
<p class="p4"><br></p>
<p class="p5">Once a match has been recognised, the <i>scanner</i> replaces the matched string with a <i>token</i> that is known to all downstream passes.<span class="Apple-converted-space">  </span>The main feature of a <i>token</i> is that it can be recognised by downstream passes by a simple numeric or symbolic comparison, instead of a full string comparison.</p>
<p class="p4"><br></p>
<p class="p5">Depending on the design intent of the compiler-writer, a token may also include information about the token and the matched string.<span class="Apple-converted-space">  </span>For example, an ID (identifier) token may be a simple integer coupled with a reference to a table entry that contains the actual string of characters, the ID’s type information (updated in later passes), etc.</p>
<p class="p4"><br></p>
<p class="p5">Early compilers did not contain a scanner pass nor tokens, and they relied solely on <b>streq()</b> operations everywhere.<span class="Apple-converted-space">  </span>Such compilers ran more slowly.</p>
<p class="p4"><br></p>
<p class="p5">Early tools, such as <i>Lex</i> […] ,<span class="Apple-converted-space">  </span>read descriptions of strings and converted them into state machines to improve speed, much like the familiar <i>regex().<span class="Apple-converted-space">  </span></i>The techniques of compiling string matchers into state machines are covered in the <i>Dragon Book</i> […].</p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Parser</b></h2>
<p class="p4"><br></p>
<p class="p5">The job of a parser is to check that tokens are correctly placed / sequenced to fit the particular language being compiled and to signal errors if the tokens do not form well-formed phrases in the language.</p>
<p class="p4"><br></p>
<p class="p5">For example in C, the string “(x ==y)”,<span class="Apple-converted-space">  </span>might be represented by the sequence of tokens (represented by symbolic names):</p>
<p class="p4"><br></p>
<p class="p5"><span class="Apple-converted-space">    </span>tokLPar</p>
<p class="p5"><span class="Apple-converted-space">    </span>tokIdent {ref. to table entry for ident “x”}</p>
<p class="p5"><span class="Apple-converted-space">    </span>tokEqualsEquals</p>
<p class="p5"><span class="Apple-converted-space">    </span>tokIdent {ref. to table entry for ident “y”}</p>
<p class="p5"><span class="Apple-converted-space">    </span>tokRPar<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">In this case, each token, <i>tokLPar</i>, tokIdent, <i>tokEqualsEquals</i> and, <i>tokRpar</i> might be represented as Integers (scalars) and the extra information, enclosed in<span class="Apple-converted-space">  </span>braces ({}) would signal that <i>tokIdent</i> has some kind of structured information following it.</p>
<p class="p4"><br></p>
<p class="p5">The string of five tokens, above, form a well-formed <i>Expression</i> in C.</p>
<p class="p4"><br></p>
<p class="p5">The parser, also, has the job of discarding syntactic sugar and replacing token phrases with shorter token phrases which contain only the information necessary in subsequent passes.<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">For example, the Parser might re-emit the tokens in an RPN stream as follows:</p>
<p class="p4"><br></p>
<p class="p5"><span class="Apple-converted-space">    </span>tokExpression</p>
<p class="p5"><span class="Apple-converted-space">    </span>tokIdent {ref. to table entry for ident “x”}</p>
<p class="p5"><span class="Apple-converted-space">    </span>tokIdent {ref. to table entry for ident “y”}</p>
<p class="p5"><span class="Apple-converted-space">    </span>tokEqualsEquals</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Semantic Pass</b></h2>
<p class="p4"><br></p>
<p class="p5">A <i>Semantic Pass</i> has the job of checking the semantics of program token phrases.<span class="Apple-converted-space">  </span>The <i>semantic pass</i> doesn’t need to check tokens or the validity of token phrases - these are verified in preceding passes (the scanner and the parser).<span class="Apple-converted-space">  </span>Checking the semantic validity of token phrases can be a complicated matter, but is simplified by information generated by the preceding passes.</p>
<p class="p4"><br></p>
<p class="p5">In general, the <i>semantic pass</i> needs to determine the scopes of all variables (subject to scoping rules of the language) and the types of all variable (subject to typing rules of the language).</p>
<p class="p4"><br></p>
<p class="p5">In declaration-before-use languages, the semantic checker can be collapsed into a single pass, whereas, in languages that do not follow the declaration-before-use rules (and possibly require transitive closures over the complete system), a semantic pass might consist of more than one actual pass.</p>
<p class="p4"><br></p>
<p class="p5">Specifying declaration-before-use semantics assists the compiler writers, but puts more onus on the users of the language (e.g. to declare objects earlier than strictly necessary).</p>
<p class="p4"><br></p>
<p class="p5">Thirty years ago, it was considered “reasonable” to off-load such considerations to language users.</p>
<p class="p4"><br></p>
<p class="p5">Today, with much faster hardware, it seems to me that encumbering the software designer with rules that make compiler-writing easier for the compiler-writer, is a false economy.<span class="Apple-converted-space">  </span>All efforts should be used to off-load mental strains from the software designers.</p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Allocation and Coding</b></h2>
<p class="p4"><br></p>
<p class="p5">After a program (a token stream) has been “certified correct” by preceding passes, the compiler-writing job consists of creating code.</p>
<p class="p4"><br></p>
<p class="p5">The act of code creation breaks down into, at least, two phases:</p>
<p class="p4"><br></p>
<ol class="ol1">
  <li class="li10">Allocation - figuring out where each variable, constant, parameter and return value is going to end up in the memory space (stack, etc.).</li>
  <li class="li10">Choosing code sequences (in the appropriate assembler) that faithfully carry out operations in the higher level language (being compiled).</li>
  <li class="li11"><br></li>
</ol>
<p class="p14"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Allocation</b></h2>
<p class="p4"><br></p>
<p class="p10">For allocation, one needs to represent data-locations in some manner.</p>
<p class="p11"><br></p>
<p class="p10">One method is to use a data structure called “data descriptors” [Holt, <span class="s6">https://dl.acm.org/citation.cfm?id=24051</span><span class="s7">].</span></p>
<p class="p13"><br></p>
<p class="p15"><span class="s8">Fraser/Davidson designed RTL [Fraser-Davidson, <a href="https://people.well.com/user/cwf/pro/Davidson%20and%20Fraser.%20The%20design%20and%20application%20of%20a%20retargetable%20peephole%20optimizer.pdf"><span class="s9">https://people.well.com/user/cwf/pro/Davidson%20and%20Fraser.20The%20design%20and%20application%20of%20a%20retargetable%20peephole%20optimizer.pdf</span></a>], the method used in gcc.</span></p>
<p class="p13"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Coder</b></h2>
<p class="p4"><br></p>
<p class="p5">A coder is the final pass in a compiler.<span class="Apple-converted-space">  </span>Coders are also called “emitters” and “back ends”.</p>
<p class="p4"><br></p>
<p class="p5">It simply walks the stream / tree and emits code (as assembler text, or binary) for a particular cpu architecture.</p>
<p class="p4"><br></p>
<p class="p5">Another aspect of coding is “optimisation”.<span class="Apple-converted-space">  </span>This pass can precede or succeed allocation and emission, depending on design constraints and implementation of various compiler data structures.</p>
<p class="p4"><br></p>
<p class="p5">Coders often rely on a library known to contain certain operations that will be included at run time ( a “run time” library).<span class="Apple-converted-space">  </span>The final emitted code is linked with this library.</p>
<p class="p4"><br></p>
<p class="p5">Coders/emitters/backends make trade-offs for speed vs. code (and data) size.</p>
<p class="p4"><br></p>
<p class="p5">Coders need to determine which cpu registers will be used.<span class="Apple-converted-space">  </span>[Note that, in a multi-process environment, each register which <i>might</i> contain data must be pushed onto a stack (to save the value(s)) during context switches)].</p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Tree-Based Coding</b></h2>
<p class="p4"><br></p>
<p class="p5">See <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools</a> .</p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Optimization</b></h2>
<p class="p4"><br></p>
<p class="p5">A very common form of optimiser is a tree-based one.<span class="Apple-converted-space">  </span>This kind of optimiser is described in [Aho,Ulmann,et al, <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools"><span class="s6">https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools</span></a> (“the dragon book”)].</p>
<p class="p4"><br></p>
<p class="p5">A tree-based optimiser can convert a tree into a DAG and can easily reuse code sequences and allocations that appear more than once.</p>
<p class="p4"><br></p>
<p class="p5">A very simple form of optimisation is “peephole” optimisation.<span class="Apple-converted-space">  </span>This method executes after the coder phase and looks at the emitted code through a “window” of some number of instructions.<span class="Apple-converted-space">  </span>It pattern-matches the windowed instruction sequence and replaces matches with “better” code (faster or less space, etc.).<span class="Apple-converted-space">  </span>Peephole optimisers can be built using very simple tools, like <i>awk</i>.</p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Run-time Library</b></h2>
<p class="p4"><br></p>
<p class="p5">In older C compilers, the run time library was called “crt0” (C Run Time zero).</p>
<p class="p4"><br></p>
<p class="p5">Run time libraries often perform startup and initialisation task, as well as providing routines for certain repetitive code sequences (e.g. floating point) that are better (space-wise) left as libraries instead of full-unrolled code sequences emitted by the coder.</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Portability</b></h2>
<p class="p4"><br></p>
<p class="p16"><span class="s5">There has been a fair amount of thought put into creating machine descriptions that reduce cognitive load for the compiler writers.<span class="Apple-converted-space">  </span>For example, OCG (orthogonal code generation [Cordy, </span><span class="s2">https://books.google.ca/books?id=X0OaMQEACAAJ&amp;dq=bibliogroup:%22Technical+report+CSRI%22&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjg4Y7a7ZbiAhUMwlkKHfzdD_MQ6AEIMzAC</span>]) allows one to declaratively specify a tree of code sequences based on cpu architecture. The tree(s) specify how to map operations, in some low-level form, into a correct sequence on instructions for a number of architectures.</p>
<p class="p17"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Backtracking</b></h2>
<p class="p4"><br></p>
<p class="p5">In the past, it was assumed that a single cpu was expensive and that it needed to be time-shared between users.</p>
<p class="p4"><br></p>
<p class="p5">In the past, machines were much slower than they are today.</p>
<p class="p4"><br></p>
<p class="p5">It was “determined” that backtracking was not practical, hence, compilers were designed to conserve speed.</p>
<p class="p4"><br></p>
<p class="p5">Compiler technology was invented to accommodate speed and determinism.<span class="Apple-converted-space">  </span><i>YACC</i> reduced the acceptable set of languages to LALR(1), so that it could implement parsers as NFDAs.</p>
<p class="p4"><br></p>
<p class="p16"><span class="s5"><i>PEG</i> [Bryan Ford, </span><span class="s2">http://bford.info/pub/lang/peg.pdf</span>], <i>TXL</i> [Cordy, <a href="https://www.txl.ca/"><span class="s2">https://www.txl.ca/</span></a>] and <i>Prolog </i>[Clocksin, Mellish, <span class="s2">https://link.springer.com/book/10.1007/978-3-642-55481-0</span>] show that backtracking is practical on modern computers.<span class="Apple-converted-space">  </span>A trend towards more flexible languages has not followed this trend in faster computers.</p>
<p class="p17"><br></p>
<p class="p17"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Drawing Conventions</b></h2>
<p class="p4"><br></p>
<p class="p5">As it stands, we do not have an off-the-shelf drawing editor.</p>
<p class="p4"><br></p>
<p class="p5">We use an existing diagram editor plus some conventions that make its output suitable for compilation.<span class="Apple-converted-space">  </span>We do not check all drawings for correctness and the compiler may fail (or produce incorrect code) if drawings contain features not specified below.</p>
<p class="p4"><br></p>
<p class="p5">For now, we will use the (free) Draw.IO drawing editor and save the drawings as .SVG files.</p>
<p class="p4"><span class="Apple-converted-space"> </span></p>
<p class="p5">For drawings made with Draw.IO, the following conventions are used:</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10">A <i>Part</i> is drawn as a Rectangle (top-left of General palette) with <i>Text</i> (3<span class="s10"><sup>rd</sup></span> item on General palette) completely inside the Rectangle.<span class="Apple-converted-space">  </span>The <i>Text</i> represents the <i>kind</i> (aka, <i>type, class</i>) of the part.<span class="Apple-converted-space">  </span>There can be multiple <i>Parts</i> with the same <i>kind</i> in a drawing.<span class="Apple-converted-space">  </span>These are recognised as multiple <i>instances</i> of the same <i>kind</i> of part.<span class="Apple-converted-space">  </span>Instances are given unique ID’s internally, that are not shown on the diagram (see <i>Figure: 1</i>).</li>
  <li class="li10">A <i>Wire </i>is drawn as a “directional connector” (line with arrowhead) (32<span class="s10"><sup>nd</sup></span> item on the General palette) from one rectangle to another.<span class="Apple-converted-space">  </span>The connection points are displayed by Draw.IO when the line is dragged near, or across, the boundary of the rectangle.</li>
  <li class="li10">A <i>Wire</i> must be a single, contiguous line.<span class="Apple-converted-space">  </span>It must not be split into multiple line segments.<span class="Apple-converted-space">  </span>Draw.IO allows one to place multiple “bend points” on a line - this is allowed, as long as the line is not split into multiple segments.</li>
  <li class="li10">The <i>beginning</i> of a wire/line is unadorned.<span class="Apple-converted-space">  </span>The <i>end </i>of a wire is marked with an arrow-head.<span class="Apple-converted-space">  </span><i>Events</i> flow from the beginning of a wire to the end.<span class="Apple-converted-space">  </span>The compiler expects the <i>beginning</i> of a wire to touch the rectangle.<span class="Apple-converted-space">  </span>On the other hand, arrowheads (<i>ends </i>of the wire(s)) can be +-20 units from the edge of a rectangle.<span class="Apple-converted-space">  </span>Draw.IO draws lines in way that the beginning <i>touches </i>a rectangle, but draws the <i>end </i>of a line so that they do not <i>touch</i> a rectangle (only the arrowhead touches the rectangle ; it was easier to add a kludge factor to the end of wires than to sort out which arrowheads correspond to which lines ; the kludge factor only applies to arrowhead portion of a line, all other matches are exact).</li>
  <li class="li10">A <i>Port</i> is a text box (3<span class="s10"><sup>rd</sup></span> item on General palette) that is not contained inside the rectangle, but is positioned “near” one end or another of the wire.<span class="Apple-converted-space">  </span>The <i>Port’s</i> name is a numeral.<span class="Apple-converted-space">  </span>The range of numerals depends on the compiler.<span class="Apple-converted-space">  </span>In this POC, <i>Port</i> names start at 0 up to 15.<span class="Apple-converted-space">  </span>The compiler measures distance from the beginning or end of a wire to unenclosed text.<span class="Apple-converted-space">  </span>The text closest to the end of a wire is taken to be the index of the <i>Port</i>. Currently, ports are “named” by a numeric index. In the future, the compiler can be changed to accept arbitrary character strings for port “names”.<span class="Apple-converted-space">  </span>This is not the case, currently (the compiler only understands numeric indices).</li>
  <li class="li10">A <i>port</i> with no arrow is an output pin.<span class="Apple-converted-space">  </span>A <i>port</i> with an arrow-head is an input pin. <br>
<br>
<img src="/assets/2020-12-09-15-13-37-Images/Ports.png" width="400px" height="300px" alt="Image"><br>
<i>Figure: 1</i><br>
<span class="Apple-tab-span">	</span></li>
  <li class="li10">Multiple wires can connect to input pins and to output pins. (“Fan out” and “fan in”, resp.).<span class="Apple-converted-space">  </span>(N.B. FBP allows “fan in” but does not allow “fan out”.<span class="Apple-converted-space">  </span>The drawings discussed here do not follow all FBP conventions and allow for “fan out”, similar to electronic schematics).<br>
<br>
<img src="/assets/2020-12-09-15-13-37-Images/MultipleWires.png" width="393px" height="315px" alt="Image"><br>
<i>Figure: 2</i><br>
</li>
  <li class="li10">Time-ordering is preserved.<span class="Apple-converted-space">  </span>An <i>event</i> that is placed on a wire arrives at all <i>inputs</i> (in the same schematic) at the same “time”.<span class="Apple-converted-space">  </span>A <i>wire </i>that is attached to multiple inputs (“fan out”) is, therefore, more “costly” than a wire that connects a single output to a single input (N.B. some care is needed when implementing multiple connection and simultaneous delivery in a preemptive (time-sliced) environment. Fan-out requires that the event be delivered to a group of wires/pins atomically.<span class="Apple-converted-space">  </span>When time-slicing and/or interrupts are being used, there might be a need for some <i>locking</i> under-the-hood to guarantee atomic delivery of events to implement fan-out) [The current PoC performs atomic delivery implicitly].<span class="Apple-converted-space">  </span>It is, also, implementation-dependant as to what happens when non-scalar events are fanned out (e.g. an implementation can refuse to support non-scalar fan-in, or it can implement under-the-hood non-scalar event copying).</li>
  <li class="li10">Inputs from the outside and outputs to the outside are drawn as ellipses with a port number fully enclosed inside the ellipse.<span class="Apple-converted-space"> </span></li>
  <li class="li10">[Dots are currently unimplemented, since they are just “syntactic sugar” for fan-in and fan-out at ports]. Dots, drawn as small black circles (Draw.IO ellipses that are round, and filled with color black).<span class="Apple-converted-space">  </span><br>
<br>
<img src="/assets/2020-12-09-15-13-37-Images/Dots.png" width="343px" height="257px" alt="Image"><br>
<i>Figure: 3</i><br>
<br>
Multiple wires can connect to a dot.<span class="Apple-converted-space">  </span>Dots are “one-way”.<span class="Apple-converted-space">  </span>A dot can have many arrow-heads pointing into it and only one wire emanating from it, or, one arrow-head pointing into it, and many wires emanating from it.<span class="Apple-converted-space">  </span>A dot must not have multiple inputs and multiple outputs.<span class="Apple-converted-space">  </span>The meaning of dots are (1) many inputs (arrow-heads) pointing in and one wire pointing out means that all of the incoming wires are compressed down into the single output (all inputs go the same place as the single output) and (2) one input and many outputs means that the input is split (copied) to all of the outputs simultaneously.</li>
  <li class="li10">Composite Parts — parts which are made up of a schematic referring to other parts — are managed manually.<span class="Apple-converted-space">  </span>A composite Part consists of a drawing (a schematic) containing boxes, arrows, ellipses and dots.<span class="Apple-converted-space">  </span>When a composite diagram is compiled and run, it is assumed that the children parts all exist (the compiler does not currently check for this).<span class="Apple-converted-space">  </span>Composite parts can be nested hierarchically, each part on its own schematic.</li>
  <li class="li10">Draw.IO must be instructed to save the drawing as an .SVG file (change the name to &lt;name&gt;.svg before saving).</li>
  <li class="li10">Hints: Draw wires first, then annotate the wires with port numbers.<span class="Apple-converted-space">  </span>When moving or re-drawing a wire, move existing port numbers far away from the rectangle and connect the wires, then move the port numbers back into position.<span class="Apple-converted-space">  </span>Draw.IO allows wires to connect to Text, but this is not what we want - wires must be connected to rectangles.<span class="Apple-converted-space">  </span>When a port number is left in place, while moving an reconnecting a wire, Draw.IO might connect the wire to the rectangle or to the port number - it remains visually unclear as to which connection is made.</li>
  <li class="li11"><br></li>
</ul>
<p class="p14"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>The Algorithm</b></h2>
<p class="p4"><br></p>
<p class="p5">To describe the algorithm for compiling 2D drawings to code, I will use the “standard” four-pass model for compiler-building from the 1D text language paradigm.<span class="Apple-converted-space">  </span>A final version of the diagram compiler might use a separation that is different from the four-pass model, but it appears that the four-pass model might make for a simpler explanation at this time.<span class="Apple-converted-space">  </span>In fact, the current compiler has about twenty “passes”, grouped into four larger (<i>composite</i>) parts.</p>
<p class="p4"><br></p>
<p class="p5">Draw.IO outputs drawings in various formats.<span class="Apple-converted-space">  </span><i>bmFBP</i> drawings use the conventions discussed earlier and are saved as .SVG files.</p>
<p class="p4"><br></p>
<p class="p5">In this algorithm, we always <i>add</i> <i>facts</i> to the <i>factbase</i>.<span class="Apple-converted-space">  </span>In principle, it is possible to remove <i>facts</i> from the <i>factbase</i>, but such action is not necessary - downstream passes match only for the facts they are “interested in”.<span class="Apple-converted-space">  </span>Superfluous <i>facts</i> are skipped over and their only effect is to slow down the pattern matching (backtracking).<span class="Apple-converted-space">  </span>In the diagrams we have compiled, slow-down is not noticeable and pruning <i>facts</i> is not necessary.</p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Scanner</b></h2>
<p class="p4"><br></p>
<p class="p5">The scanner pass simply strips and discards unused SVG information and outputs a Prolog <i>factbase</i>.</p>
<p class="p4"><br></p>
<p class="p5">Each <i>fact</i> appears on separate lines in the format</p>
<p class="p4"><br></p>
<p class="p7">relation(subject,object).</p>
<p class="p8"><br></p>
<p class="p5">Where the <i>relation</i> is some sort of relationship (declared in head.pl and tail.pl), the <i>subject </i>is a unique id and the <i>object</i> is a unique id (of some other graphic object) or a piece of data (usually an integer or floating point number).</p>
<p class="p4"><br></p>
<p class="p5">The scanner recognises and emits four kinds of graphical objects:</p>
<p class="p4"><br></p>
<ol class="ol1">
  <li class="li10">Rectangles</li>
  <li class="li10">Ellipses (with no-fill-color or black-fill-color)</li>
  <li class="li10">Text</li>
  <li class="li10">Directional lines (with arrow-heads).</li>
</ol>
<p class="p11"><br></p>
<p class="p10">As it stands, the POC compiler takes a component-name from the command line and emits a <i>fact</i></p>
<p class="p11"><i></i><br></p>
<p class="p7">component('name').</p>
<p class="p8"><br></p>
<p class="p5">(The component name should, in the future, come from the IDE, sent in through an ellipse input).</p>
<p class="p4"><br></p>
<p class="p5">For every line, we know that the line has a sink port (its beginning — where events are consumed) and a sink port (its end, where events are emitted).<span class="Apple-converted-space">  </span>“Source” means that events “come from” the port.<span class="Apple-converted-space">  </span>“Sink” means that port accepts events as input.<span class="Apple-converted-space">  </span>On children parts, “sink” ports are inputs while “source” ports are outputs.<span class="Apple-converted-space">  </span>On the parent part (the drawing itself), the input port “sources” events (from the outside) while the output ports “sink” events (emit events to the outside).<span class="Apple-converted-space">  </span>We can calculate the bounding box for each port using a fixed constant (e.g. 20) for its size in x and y.<span class="Apple-converted-space">  </span>In a later pass, we will add more bounding box for other graphical elements.<span class="Apple-converted-space">  </span>Emit a set of <i>facts </i>(where “eltype” means “graphic element type”):</p>
<p class="p8"><br></p>
<p class="p7"><span class="Apple-converted-space">  </span>line(new-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>source(line-id,begin-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>eltype(begin-id,'port').</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_left(begin-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_top(begin-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_right(begin-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_bottom(begin-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>sink(line-id,end-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>eltype(end-id,'port').</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_left(end-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_top(end-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_right(end-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_bottom(end-id,nnnn).</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p5">For every rectangle, output its ID, eltype (‘box’) and geometry x/y/width/height.</p>
<p class="p8"><br></p>
<p class="p7"><span class="Apple-converted-space">  </span>rect(rect-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>eltype(rect-id,'box').</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_x(rect-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_y(rect-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_w(rect-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_h(rect-id,nnnn).</p>
<p class="p8"><span class="Apple-converted-space">  </span></p>
<p class="p5">1For every text graphical item that contains only numerical digits, emit it’s id, the “text” as a number and its geometry.</p>
<p class="p8"><span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-converted-space">  </span>text(text-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_x(text-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_y(text-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_w(text-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_h(text-id,nnnn).</p>
<p class="p8"><span class="Apple-converted-space">  </span></p>
<p class="p5">For every text graphical item that contains any non-numerical characters, emit it’s id, the “text” as a string and its geometry.<span class="Apple-converted-space">  </span>(Currently, the compiler uses strings for part kinds and numbers for port indices. When creating the initial factbase, it is “easy” to differentiate between strings and numbers.<span class="Apple-converted-space">  </span>Prolog can easily differentiate between these two types using the <i>hint</i> that strings are quoted and numbers are not.<span class="Apple-converted-space">  </span>This differentiation helps downstream passes, by making it obvious what the text contains, since the downstream passes do not need to perform differentiation, since it is already done).</p>
<p class="p8"><span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-converted-space">  </span>text(text-id,'string').</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_x(text-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_y(text-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_w(text-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_h(text-id,nnnn).</p>
<p class="p8"><span class="Apple-converted-space">  </span></p>
<p class="p5">For every arrow-head, emit it’s id and an (x,y) pair that corresponds to the “tip” of the arrow-head.</p>
<p class="p7"><span class="Apple-converted-space">  </span>arrow(arrow-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>arrow_x(arrow-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>arrow_y(arrow-id,nnnn).</p>
<p class="p4"><br></p>
<p class="p5">(As can be seen, the scanner is relatively “simple” and does little work.<span class="Apple-converted-space">  </span>The last two passes inside the scanner - plsort and check_input - do almost “nothing”.<span class="Apple-converted-space">  </span>Plsort simply sorts the <i>factbase</i>, since Prolog requires that all rules with the same name be contiguous, and “check_input” does an incoming sanity check to check that the <i>factbase</i> is clean.<span class="Apple-converted-space">  </span>In this case, we simply rely on Prolog to signal bad rules.<span class="Apple-converted-space">  </span>“check_input” simply reads then writes out the factbase.<span class="Apple-converted-space">  </span>If prolog signals no errors then the sanity check is deemed to have succeeded.<span class="Apple-converted-space">  </span>In the future, check_input might be extended to check more details.)</p>
<p class="p8"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Parser</b></h2>
<p class="p4"><br></p>
<p class="p5">In this POC, “parser” does most of the work, consisting of 9 passes (each one fairly simple):</p>
<p class="p4"><br></p>
<ol class="ol1">
  <li class="li10">Calculate bounding boxes for Rects and Text, insert the bounding box facts for each item into the <i>factbase</i>.<span class="Apple-converted-space">  </span>This pass adds four kinds of <i>facts</i> to the <i>factbase</i>: <i>bounding_box_left</i>, <i>bounding_box_top</i>, <i>bounding_box_right</i> and <i>bounding_box_bottom</i>, each with an ID and a number.<span class="Apple-converted-space">  </span>[calc_bounds].</li>
  <li class="li10">For every rectangle, find a graphical text item that fits inside the box (its <i>kind</i> (aka <i>type </i>or <i>class</i>)).<span class="Apple-converted-space">  </span>For every such text item, mark it as “used” (simplifies searching in later passes).<span class="Apple-converted-space">  </span>The “kind” is marked with a <i>kind(id,text-id)</i> <i>fact</i> and a <i>used(id)</i> <i>fact.<span class="Apple-converted-space">  </span></i>[add_kinds].</li>
  <li class="li10">For all text items that are not marked as <i>used,</i> create an <i>unassigned</i> fact.<span class="Apple-converted-space">  </span>This is a superfluous operation, but makes downstream passes “easier” - <i>unassigned</i> means that the item is <i>text </i>and that it is not marked as being <i>used</i> (i.e. used as a <i>kind</i> name of a rectangle).<span class="Apple-converted-space">  </span>[make_unknown_port_names].</li>
  <li class="li10">Create a center (x,y) for every port and every <i>unassigned</i> text item.<span class="Apple-converted-space">  </span>[create_centers].</li>
  <li class="li10">For every <i>port</i>, calculate the distance to every <i>unassigned</i> (text) item.<span class="Apple-converted-space">  </span>We stay true to the idea of making every <i>fact</i> a triple (and only a triple).<span class="Apple-converted-space">  </span>This requires the use of an indirect <i>fact</i> called <i>join</i> which joins a port to each calculated distance for each <i>unassigned</i>.<span class="Apple-converted-space">  </span>In “normal” Prolog, we could simply list the PortID, the TextID and the Distance in a single fact (instead of using indirection via <i>join</i>).<span class="Apple-converted-space">  </span>[calculate_distances].</li>
  <li class="li10">For every Port, make a list of distances to <i>unassigned </i>text.<span class="Apple-converted-space">  </span>Choose the minimum distance in the list, then create a pair of <i>facts </i>that connect the PortID to the TextID (<i>portIndex) </i>and another fact that points “backwards” from the TextID to the PortID (<i>portIndexByID</i>).<span class="Apple-converted-space">  </span>[For the sake of future revisions, also create another pair of facts using string name (<i>portName, portNameByID</i>) - not strictly needed by this algorithm.].<span class="Apple-converted-space">  </span>[assign_portnames].</li>
  <li class="li10">Mark every port as a sink or a source, as appropriate.<span class="Apple-converted-space">  </span>[markIndexedPorts].</li>
  <li class="li10">To allow fan-out and fan-in, ports can overlap one another (see <i>figure</i> <i>1</i>.<i>3)</i>.<span class="Apple-converted-space">  </span>For every group of overlapping ports, only one port actually has an index assigned to it.<span class="Apple-converted-space">  </span>Propagate the index to all other overlapping ports.<span class="Apple-converted-space">  </span>[coincidentPorts].</li>
  <li class="li10">For every port, calculate which Part (a rectangle ‘box’) the port intersects with and insert a new <i>parent</i> fact relating the port to its parent.<span class="Apple-converted-space">  </span>[match_ports_to_components].<span class="Apple-converted-space">  </span>Clearly, the semantic pass should check that each port intersects one and only one Part.</li>
</ol>
<p class="p11"><br></p>
<p class="p10">At this point, the algorithm is almost finished - a diagram, following conventions as described earlier, has been entered into the <i>factbase</i> and the <i>factbase</i> contains sufficient information to produce code.<span class="Apple-converted-space">  </span>As can be seen, the algorithm is very simple.<span class="Apple-converted-space">  </span>A production version of this algorithm would include more semantic checks.</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Semantic Pass</b></h2>
<p class="p4"><br></p>
<p class="p5">The semantics pass checks various design rules.<span class="Apple-converted-space">  </span>If any check doesn’t pass, it should abort code generation.<span class="Apple-converted-space">  </span>At present, there are only two passes built as examples of semantic checking - sem_partsHaveSomePorts (every Part must have at least one port) and sem_allPortsHaveAnIndex (every port must have a numeric index (this index is used during code generation)).<span class="Apple-converted-space">  </span>The semantic pass could (should) have many more checks, but as can be seen, using backtracking pattern matching over the <i>factbase</i> makes piece-wise semantic checking “easy”.<span class="Apple-converted-space">  </span>In fact, the semantic checks could be spread throughout the compiler and abort compilation at its earliest convenience.<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Code Emitter</b></h2>
<p class="p4"><br></p>
<p class="p5">The code emitter walks the <i>factbase</i> and creates a file of text for a given language.<span class="Apple-converted-space">  </span>In this case, a JSON table is emitted for JavaScript.<span class="Apple-converted-space">  </span>There are currently 5 steps to doing this:</p>
<p class="p4"><br></p>
<ol class="ol1">
  <li class="li10">Create a “wire number” for every wire.<span class="Apple-converted-space">  </span>Since every wire is connected to one source and one sink, as per the diagram conventions, we arbitrarily walk the sinks and assign wire numbers.<span class="Apple-converted-space">  </span>For every sink port, match the wire(s) that it is connected to, and assign a wire number, starting with 0 and increasing by 1 monotonically.<span class="Apple-converted-space">  </span>Keep a count of the number of wires on a given diagram.<span class="Apple-converted-space">  </span>[assign_wire_numbers_to_inputs].</li>
  <li class="li10"> For every source port, match the wire(s) that connect to it, then associate the wire number with the wire(s).<span class="Apple-converted-space">  </span>Use the already-chosen wire number from step one, from the sink attached to a given wire.</li>
  <li class="li10">For every sink Port on every Part, create two facts - the <i>inputPin</i> and <i>wireIndex</i> <i>facts.</i><span class="Apple-converted-space">  </span>Do the same for every source Port on every Part (<i>outputPin </i>and <i>wireIndex</i>).<span class="Apple-converted-space">  </span>[inOutPins].<span class="Apple-converted-space"> </span></li>
  <li class="li11"><br></li>
</ol>
<p class="p14"><br></p>
<p class="p7">The algorithm for handling ports is a subset of the main algorithm.<span class="Apple-converted-space">  </span>Port handling is described below.</p>
<p class="p8"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Menlo"><b>Scanning</b></h2>
<p class="p4"><br></p>
<p class="p7">During scanning, we know that each line has a port at its beginning and a port at each end.<span class="Apple-converted-space">  </span>We don’t yet know what the port is attached to or if it is an N/C (no connection.</p>
<p class="p8"><br></p>
<p class="p7">During scanning, we attach a port to each end of the line, and, since all lines are arrows, we can also assign a “direction” (source (output) or sink (input)) during this pass.<span class="Apple-converted-space">  </span>For example, each line has the following <i>facts</i> entered into the <i>factbase</i>: an new id for the line, a source port (output port), a bounding box for the port based on (x1,y1) of the line and a sink port (input port).</p>
<p class="p8"><br></p>
<p class="p7">The bounding boxes for the ports are “invented” at scan time.<span class="Apple-converted-space">  </span>These “invented” ports are made to be 40 pixels on all sides.</p>
<p class="p8"><br></p>
<p class="p7">The <i>facts</i> appear in the <i>factbase </i>as:</p>
<p class="p8"><br></p>
<p class="p7"><span class="Apple-converted-space">  </span>line(new-id).</p>
<p class="p8"><br></p>
<p class="p7"><span class="Apple-converted-space">  </span>% port at line beginning</p>
<p class="p7"><span class="Apple-converted-space">  </span>source(line-id,begin-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>eltype(begin-id,'port').</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_left(begin-id,(x1 - 20)).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_top(begin-id,(y1 - 20)).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_right(begin-id,(x1 + 20)).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_bottom(begin-id,(y1 + 20)).</p>
<p class="p8"><br></p>
<p class="p7"><span class="Apple-converted-space">  </span>% port at line end</p>
<p class="p7"><span class="Apple-converted-space">  </span>sink(line-id,end-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>eltype(end-id,'port').</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_left(end-id,(x2 - 20)).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_top(end-id,(y2 - 20)).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_right(end-id,(x2 + 20)).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_bottom(end-id,(y2 + 20)).</p>
<p class="p8"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Parsing</b></h2>
<p class="p4"><br></p>
<p class="p5">In “make_unknown_port_names”, we find all pieces of text that have not yet been associated with any Parts (rectangles).<span class="Apple-converted-space">  </span>This includes all text that consist only of digits (i.e. port indices).<span class="Apple-converted-space">  </span>Each of these pieces of text are given an “unassigned(TextID)” <i>fact</i>.</p>
<p class="p4"><br></p>
<p class="p5">In “create_centers” we assign “center_x(ID,N)” and “center_y(ID,N)” <i>facts<span class="Apple-converted-space"> </span></i> to all unassigned pieces of text and all ports (eltype(ID,port)).</p>
<p class="p4"><br></p>
<p class="p5">In “calculate_distances” we create a distance vector from every port to every unassigned piece of text (this is inefficient but works in the POC. Maybe there is a better way).<span class="Apple-converted-space">  </span>In this particular case, I decided to create a new Object called a Join with a unique ID.<span class="Apple-converted-space">  </span>A unique “join_centerPair” is created for every Port.<span class="Apple-converted-space">  </span>Each join_centerPair has two <i>facts </i>created for it - “join_distance(Join_centerPairID, TextID)” and “distance_xy(Join_centerPairID,Distance)”.<span class="Apple-converted-space">  </span>The former connects the Port to <i>one</i> unassigned piece of text and the latter gives the distance between the Port and the <i>one</i> unassigned piece of text.<span class="Apple-converted-space">  </span>Again, there might be more efficient ways to express this connection.<br>
<br>
<img src="/assets/2020-12-09-15-13-37-Images/CenterPairs.jpg" width="100%" alt="Image"><br>
<i>Figure: 4</i></p>
<p class="p4"><br></p>
<p class="p5">In “assign_portnames” (finally), for each port, we find the unassigned piece of text that is closest to the given port and associate the port and the text via a portIndex <i>fact.<span class="Apple-converted-space">  </span></i>Furthermore, we associate the text with a back-pointer <i>fact</i> “portIndexByID”.<span class="Apple-converted-space">  </span>Historically, we create two more facts that mirror this two-way association with “portName” and “portNameByID” for pieces of text that are not numeric.<span class="Apple-converted-space">  </span>Historically, we started out with textual port names.<span class="Apple-converted-space">  </span>Later, we discovered that every port needs an index (for the coder pass) and made a new convention that insists that <i>every</i> port must have an index and that only some ports may have names.<span class="Apple-converted-space">  </span>We currently ignore textual port names.<span class="Apple-converted-space">  </span>In the future, I may return to using textual names for ports while automatically creating numeric indices for ports.</p>
<p class="p4"><br></p>
<p class="p5">In the two-Part pipeline, “markIndexedPorts” and “coincidentPorts”, I implement fan-out and fan-in.<span class="Apple-converted-space">  </span>I find all ports that overlap each other and assign the same index to all of those Ports.<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">The Part “mark_directions” is a no-op for this POC compiler.<span class="Apple-converted-space">  </span>In some editors, the direction of lines is not specified.<span class="Apple-converted-space">  </span>In such cases, lines might be made up of segments with no direction associated with them.<span class="Apple-converted-space">  </span>In such cases, the compiler needs to trace all connected segments to find the ultimate beginnings (sources) and ends (sinks) of the lines and create a virtual directed line between the beginning and end Ports.<span class="Apple-converted-space">  </span>In this POC, we use Draw.IO, and use the convention that all lines (wires) use Draw.IO’s arrows.<span class="Apple-converted-space">  </span>Draw.IO arrows already provide direction information, so “mark_directions” is a no-op in this case.</p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>The Drawing Compiler</b></h2>
<p class="p4"><br></p>
<p class="p5">This section documents the actual <i>facts</i> and <i>passes</i> used by the current POC (proof of concept) compiler.</p>
<p class="p5">These choices might not be the best ones, since understanding of the architecture grew over time, but they do represent the contents of the current POC.</p>
<p class="p4"><br></p>
<h1 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 18.0px Palatino"><b>Basic Concepts</b></h1>
<p class="p4"><br></p>
<p class="p5">The basic requirements for compiling a diagram are:</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10">To “arbitrarily” choose a set of graphical “atoms” which can be used to<span class="Apple-converted-space">  </span>draw the diagrams for the language.</li>
  <li class="li10">Then, use pattern matching and backtracking to infer new, semantic information which builds a knowledge base (some kind of data structure) that represents the interesting details within the diagram.</li>
  <li class="li10">Finally, convert the inferred information into some other text language, which is then compiled into executable code in the usual way, using existing compilers and tools.</li>
</ul>
<p class="p4"><br></p>
<p class="p5">At first, this may seem difficult or impossible.<span class="Apple-converted-space">  </span>One <i>can</i> use the method of “divide and conquer” to create ridiculously small components, to produce a working diagram compiler.</p>
<p class="p4"><br></p>
<p class="p5">I have concluded that no single programming language can do everything that is required, to solve an actual real-world problem.<span class="Apple-converted-space">  </span>Several “design principles” come from this conclusion:</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10">Use a paradigm and a language that is most suited to the task(s) at hand.</li>
  <li class="li10">Don’t over-design.<span class="Apple-converted-space">  </span>Create only what is needed to solve the problem.<span class="Apple-converted-space">  </span>Abstraction and generalisation are over-sold.<span class="Apple-converted-space">  </span>If done too early (e.g. before some 3 iterations on the solution), abstraction is a bad idea that wastes time and usually doesn’t solve the problem at hand.<span class="Apple-converted-space">  </span>A corollary is: code reuse is a bad idea, design (architecture) reuse is a better goal - code is (can be) cheap, thinking is hard.<span class="Apple-converted-space">  </span>Reuse “thinking”.<span class="Apple-converted-space">  </span><i>Refactoring</i> is a <i>symptom</i> of poorly-expressed design.<span class="Apple-converted-space">  </span>If you feel a need to refactor code (instead of just throwing it away), then you are probably doing something else wrong.</li>
  <li class="li10">Don’t build the Design into the program - encapsulate the Design and pull it out of the code.<span class="Apple-converted-space">  </span>Spaghetti Design is worse than spaghetti code. <span class="Apple-converted-space"> </span></li>
  <li class="li10">Don’t generalise, just get the job done. Code libraries bring other problems into the mix, which detract from getting the job done, as we’ve seen over the decades.<span class="Apple-converted-space">  </span>Making it possible to <i>reuse the Design</i> (the thinking time, e.g. patterns) results in better use of human resources than taking the time to abstract code and to make it a part of a library.</li>
</ul>
<p class="p4"><br></p>
<p class="p5">The above principles have led to an extremely simple diagram language, as discussed below.</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Menlo"><b>Graphical Atoms</b></h2>
<p class="p4"><br></p>
<p class="p5">In this diagrammatic language, we simply need about two (2) graphical objects - straight lines and text.<span class="Apple-converted-space">  </span>This diagrammatic language consists of<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10">boxes and<span class="Apple-converted-space"> </span></li>
  <li class="li10">arrows.<span class="Apple-converted-space"> </span></li>
</ul>
<p class="p4"><br></p>
<p class="p5">I will show that a language as simple as this, <i>can </i>result in useful expression of software concepts that cannot be done with text alone (esp. when the boxes represent asynchronous actions, not synchronous ones).</p>
<p class="p4"><br></p>
<p class="p5">The next step up is to infer rectangular boxes.<span class="Apple-converted-space">  </span>Rectangular boxes can be inferred from a diagram by pattern matching straight lines and discovering lines that have common (x,y) end points.</p>
<p class="p4"><br></p>
<p class="p5">Many drawing tools provide rectangular boxes, so we can simply add them to the list above.<span class="Apple-converted-space">  </span>In this POC (proof of concept), we are using Draw.IO.<span class="Apple-converted-space">  </span>Draw.IO provides rectangles as atomic graphical objects, hence, we can avoid inferencing rectangles. We extend the above list to three (3) items -<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10">straight lines,<span class="Apple-converted-space"> </span></li>
  <li class="li10">text, and</li>
  <li class="li10">rectangular boxes.</li>
</ul>
<p class="p4"><br></p>
<p class="p5">Draw.IO also provides straight lines with arrow-heads as primitive graphic atoms.<span class="Apple-converted-space">  </span>We will need to know the “direction” that lines point in, hence, we extend the the above list to four (4) items:<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10">straight lines,<span class="Apple-converted-space"> </span></li>
  <li class="li10">text,<span class="Apple-converted-space"> </span></li>
  <li class="li10">rectangular boxes, and</li>
  <li class="li10">arrow-heads.</li>
</ul>
<p class="p4"><br></p>
<p class="p5">Another diagrammatic language, say one for expressing StateCharts, might use another completely different set of graphical primitives (e.g. curved lines, text, ellipses, dotted ellipses, callouts), but, using the “do not over design” principle, above, we will ignore these other atoms for now.<span class="Apple-converted-space">  </span>Building a compiler for StateCharts is another project (and, it has been done in the past).</p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>FactBases</b></h2>
<p class="p4"><br></p>
<p class="p5">The “ideal” data structure for the compiler is one that implies no structure (!) to the data.<a id="fnlink1"></a><a href="#fn1"><sup>[1]</sup></a><span class="Apple-converted-space">  </span>One such data structure is the <i>factbase<a id="fnlink2"></a></i><a href="#fn2"><sup>[2]</sup></a> .<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">A <i>factbase</i> is an unordered collection of <i>facts</i>.<a id="fnlink3"></a><a href="#fn3"><sup>[3]</sup></a><span class="Apple-converted-space">  </span>A <i>fact </i>is a simple 3-tuple that contains a Subject, an Object and a Relation between them.</p>
<p class="p4"><br></p>
<p class="p5">In Lisp, a <i>fact</i> might be represented as</p>
<p class="p4"><br></p>
<p class="p7">(relation subject object)</p>
<p class="p8"><br></p>
<p class="p5">In Prolog, a <i>fact </i>might be represented as</p>
<p class="p4"><br></p>
<p class="p7">relation(subject, object).</p>
<p class="p8"><br></p>
<p class="p5">To keep things ridiculously simple, we can implement a <i>factbase</i> as a file, with one <i>fact</i> per line and with empty lines being ignored.<span class="Apple-converted-space">  </span>We append new <i>facts</i> to the front or to the end of the file (whichever is easiest - we don’t actually care, since the <i>factbase</i> is unordered).</p>
<p class="p4"><br></p>
<p class="p5">In this example, the most basic <i>factbase </i>would contain only the four graphical atoms plus geometry <i>facts</i> that describe their X and Y positions on the diagram plus width and height information (if appropriate).<span class="Apple-converted-space">  </span>For example, a simple <i>factbase<span class="Apple-converted-space"> </span></i> might be:</p>
<p class="p4"><br></p>
<p class="p7">text(id1,’’).</p>
<p class="p7">text_string(id1,’hello’).</p>
<p class="p7">text_x(id1,100).</p>
<p class="p7">text_y(id1,200).</p>
<p class="p4"><br></p>
<p class="p5">Here, ‘id1’ is some unique ID for the text.<span class="Apple-converted-space">  </span>The first line “declares” the existence of a piece of text on the diagram.<span class="Apple-converted-space">  </span>The rest of the lines all refer to the same ID (id1) and specify properties of the text e.g. the actual string of characters of the text, the (x,y) coordinates of the text.</p>
<p class="p4"><br></p>
<p class="p5"><i>Facts </i>are very similar to N-tuples found in the semantic web, etc.<span class="Apple-converted-space">  </span>A <i>factbase</i> is very similar to <i>triple-stores</i>.<span class="Apple-converted-space">  </span>Triple-stores and n-tuples are more general than what is needed for a diagram compiler, so they will be ignored for now.<span class="Apple-converted-space"> </span></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; min-height: 18.0px"><b></b><br></h2>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Pattern Matching &amp; Backtracking</b></h2>
<p class="p5">One operation that will be used repeatedly is <i>pattern matching</i> for inferring new information within the <i>factbase</i>.</p>
<p class="p5">Prolog is a language that expresses both of these operations conveniently, and Prolog is freely available. <span class="Apple-converted-space"> </span></p>
<p class="p5">I use gprolog in this project.</p>
<p class="p5">I assume that mini-Kanren (micro-Kanren) could be used (but, I haven’t explicitly tried that idea yet ; micro-Karen is available in Scheme, Clojure and Haskell, among other languages, and its use is detailed in the book “The Reasoned Schemer”).</p>
<p class="p4"><br></p>
<p class="p5">As an example of what we might use Pattern Matching &amp; Backtracking for is to infer that a rectangle is formed out of four lines (not that, if we use Draw.IO, we won’t actually need to do this):</p>
<p class="p4"><br></p>
<p class="p7">line(id2,’’).</p>
<p class="p7">line_x1(id2,10).</p>
<p class="p7">line_y1(id2,10).</p>
<p class="p7">line_x2(id2,20).</p>
<p class="p7">line_y2(id2,10).</p>
<p class="p7">line(id3,’’).</p>
<p class="p7">line_x1(id3,20).</p>
<p class="p7">line_y1(id3,10).</p>
<p class="p7">line_x2(id3,20).</p>
<p class="p7">line_y2(id3,20).</p>
<p class="p7">line(id4,’’).</p>
<p class="p7">line_x1(id4,20).</p>
<p class="p7">line_y1(id4,20).</p>
<p class="p7">line_x2(id4,10).</p>
<p class="p7">line_y2(id4,20).</p>
<p class="p7">line(id5,’’).</p>
<p class="p7">line_x1(id5,10).</p>
<p class="p7">line_y1(id5,20).</p>
<p class="p7">line_x2(id5,10).</p>
<p class="p7">line_y2(id5,10).</p>
<p class="p8"><br></p>
<p class="p5">The above <i>factbase</i> describes one rectangle as a set of four lines (id2, id3, id4, id5).<span class="Apple-converted-space">  </span>[X’s increase to the right, Y’s increase downwards, in this coordinate system].</p>
<p class="p4"><br></p>
<p class="p5">Pattern matching can be used to infer the rectangle by checking the endpoints, for example, the end-point of id2 matches the beginning-point of id3 and so on, all the way around.</p>
<p class="p4"><br></p>
<p class="p5">When we find such a closed rectangle, we insert a <span class="s11">new</span> set of <i>facts</i> into the factbase, for example:</p>
<p class="p4"><br></p>
<p class="p7">rectangle(id6,’’).</p>
<p class="p7">rectangle_center_x(id6,15).</p>
<p class="p7">rectangle_center_y(id6,15).</p>
<p class="p7">rectangle_width(id6,10).</p>
<p class="p7">rectangle_height(id6,10).</p>
<p class="p4"><br></p>
<p class="p5">It is simple-enough to write rules in Prolog, that pattern-match and backtrack to find all such rectangles in the <i>factbase</i>.<a id="fnlink4"></a><a href="#fn4"><sup>[4]</sup></a> <span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">In earlier days of computing, it was considered impractical to use backtracking in this way.<span class="Apple-converted-space">  </span>Numerous methods were developed to pattern match streams of characters (e.g. Lex to match strings of characters using state machines, Yacc to match strings of tokens using state machines).<span class="Apple-converted-space">  </span>These methods tended to restrict the kinds of sequences (languages) that could be recognised (e.g. Yacc could pattern match LALR(1) grammars and would raise errors if the incoming language did not conform to LALR(1)). <span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">Modern computers (2010 +) and Prolog engines make backtracking practical and quick.</p>
<p class="p4"><br></p>
<p class="p5">Using successive pattern matches, it is possible to infer a great deal of information about diagrams and to use this information to produce code from a diagram.<a id="fnlink5"></a><a href="#fn5"><sup>[5]</sup></a></p>
<p class="p4"><br></p>
<p class="p5">As an example, one version of this notation denoted <i>Ports</i> as small squares positioned on the edge of larger <i>Parts.<span class="Apple-converted-space">  </span></i>The inference was done using small steps - (1) pattern match ALL rectangles (and squares) (2) find all squares (3) find all squares that intersect the edges of bigger rectangles, and declare (by adding <i>facts </i>to the factbase) that the small squares are <i>Ports</i> and which rectangular <i>Parts</i> they belong to, e.g.</p>
<p class="p4"><br></p>
<p class="p20">…</p>
<p class="p20">port(id31,’’).</p>
<p class="p20">parent(id31,id77).</p>
<p class="p20">…</p>
<p class="p20">part(id77,’’).</p>
<p class="p20">…</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Intersection</b></h2>
<p class="p5">Most of the work in building a diagram compiler in this way is no more difficult than calculating whether lines intersect.</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Pipelines</b></h2>
<p class="p5">In the ’70’s and ’80’s,<span class="Apple-converted-space">  </span>the use of pipelines (shell “|”) was explored for applying “divide and conquer” strategy to solving problems, but, for some reason, the pipeline work has not been carried over into software language design (beyond Bash, etc).</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Small Components</b></h2>
<p class="p5">TBD</p>
<p class="p5">Rules of thumb:</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"><span class="Apple-converted-space">  </span>The smaller the better.</li>
  <li class="li10"><span class="Apple-converted-space">  </span>Remain practical - reasonable speed on current hardware.</li>
  <li class="li10"><span class="Apple-converted-space">  </span>Continue Dividing and Conquering until any professional can understand the purpose of the component and can implement the details in a few hours.</li>
</ul>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Prolog, Relational Programming</b></h2>
<p class="p5">TBD</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Garbage collection</b></h2>
<p class="p5">TBD</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Efficiency</b></h2>
<p class="p5"><span class="Apple-converted-space">  </span>TBD</p>
<p class="p5">O/S threads vs mutual dispatch.</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Concurrency</b></h2>
<p class="p5"><span class="Apple-converted-space">  </span>TBD</p>
<p class="p5">Cooperative Dispatching</p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Agile Methods</b></h2>
<p class="p5">TBD</p>
<p class="p5">- Agile attempts to solve the Specification problem, but does it in a non-rigorous manner (e.g. results, diagrams, comments, cannot be compiled).</p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 36.0px; text-indent: -36.0px; font: 13.0px Palatino"><b>Scanner</b></h2>
<p class="p14"><br></p>
<p class="p5">The purpose of this (Composite) Part, the “Scanner”, is to create a Prolog factbase from a .SVG file drawn in Draw.IO using the drawing conventions described earlier.</p>
<p class="p4"><br></p>
<p class="p5">Facts are written as Prolog 3-tuples, eg. “relation(id1,id2).” or “relation(id1,data).”<span class="Apple-converted-space">  </span>These facts correspond to triplestore databases (e.g. semantic web).<span class="Apple-converted-space">  </span>The full capabilities of Prolog are not used e.g. no functors, and all facts consist of one relation, one subject and one object, e.g. “relation(subject, object).”.<span class="Apple-converted-space">  </span>The design hope is that other technologies (e.g. mini-Karen) could be used for inferencing and that the design of factbases not be tied to Prolog.</p>
<p class="p4"><br></p>
<p class="p10">The Parts within this compound Part are:</p>
<ul class="ul1">
  <li class="li11"><i><span class="Apple-converted-space"> </span></i></li>
  <li class="li10">•<span class="Apple-tab-span">	</span> <span class="s11">hs-vsh-drawio-to-fb</span> test1 &lt;test5.svg &gt;...</li>
</ul>
<p class="p7"><span class="Apple-converted-space">   </span>[Lisp output: Container, Translate, Path, Rect, Text, AbsM, AbsL, relM, RelL]</p>
<p class="p8"><br></p>
<p class="p5">This Part (phase) is written in Haskell. <span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">It takes a .SVG file, removes the unneeded portions (most of it) and produces a file of Lisp tree (SEXPRs, aka Container) representing the most basic graphic operations needed by the rest of the compiler.</p>
<p class="p4"><br></p>
<p class="p5">The basic graphic operations are:</p>
<p class="p4"><br></p>
<ul class="ul2">
  <li class="li10">rectangles</li>
  <li class="li10">ellipses</li>
  <li class="li10">line and arrow paths</li>
  <li class="li10">text.</li>
</ul>
<p class="p8"><br></p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"><span class="s11">lib_insert_part_name </span>svgc</li>
</ul>
<p class="p7"><span class="Apple-converted-space">   </span>[Lisp output: (component &lt;name&gt;)]</p>
<p class="p8"><br></p>
<p class="p5">This Part is used by the bootstrap compiler.<span class="Apple-converted-space">  </span>It takes a “name” from the command line and produces one line of Lisp containing the name.</p>
<p class="p4"><br></p>
<p class="p5">This line is prepended to the output from above (hs-vsh-drawio-to-fb).</p>
<p class="p4"><span class="Apple-converted-space">   </span></p>
<ul class="ul1">
  <li class="li10"><span class="s11">fb-to-prolog<span class="Apple-converted-space"> </span></span></li>
</ul>
<p class="p11"><br></p>
<p class="p5">Output <i>facts</i> include:</p>
<p class="p11"><br></p>
<p class="p7"><span class="Apple-converted-space">  </span>component('name').</p>
<p class="p7"><span class="Apple-converted-space">  </span>line(new-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>edge(edge-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>node(begin-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>source(edge-id,begin-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>eltype(begin-id,'port').</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_left(begin-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_top(begin-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_right(begin-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_bottom(begin-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>node(end-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>sink(edge-id,end-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>eltype(end-id,'port').</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_left/top/right/bottom(edge-id,nnnn).</p>
<p class="p8"><br></p>
<p class="p7"><span class="Apple-converted-space">  </span>rect(rect-id,'').</p>
<p class="p7"><span class="Apple-converted-space">  </span>eltype(rect-id,'box').</p>
<p class="p7"><span class="Apple-converted-space">  </span>node(rect-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_x(rect-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_y(rect-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_w(rect-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_h(rect-id,nnnn).</p>
<p class="p8"><span class="Apple-converted-space">  </span></p>
<p class="p7"><span class="Apple-converted-space">  </span>text(text-id,nnnn). or text(text-id,'string').</p>
<p class="p7"><span class="Apple-converted-space">  </span>geometry_x/y/w/h(text-id,nnnn).</p>
<p class="p8"><span class="Apple-converted-space">  </span></p>
<p class="p7"><span class="Apple-converted-space">  </span>arrow(arrow-id,'').</p>
<p class="p7"><span class="Apple-converted-space">  </span>arrow_x(arrow-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>arrow_y(arrow-id,nnnn).</p>
<p class="p8"><span class="Apple-converted-space">  </span></p>
<p class="p5">This Part is the main work-horse of the Scanner.<span class="Apple-converted-space">  </span>It takes the output of “lib_insert_part_name” as a Lisp tree and converts it to Prolog.<span class="Apple-converted-space">  </span>It takes input on <i>stdin</i> and outputs the Prolog fact base on <i>stdout.</i></p>
<p class="p4"><br></p>
<p class="p5">It creates unique <i>id’s</i> for each main <i>fact</i> and outputs relations between the <i>facts</i> by referring to the <i>id’s</i>.<span class="Apple-converted-space">  </span>For example, a <i>rect</i> is declared by the “rect(id,’’).” fact.<span class="Apple-converted-space">  </span>The coordinates of the <i>rect</i> are given by four <i>geometry</i> facts, referring to the particular <i>rect’s id</i>.<span class="Apple-converted-space">  </span>The centre of the <i>rect</i> is specified by two facts - <i>geometry_x</i> and <i>geometry_y</i>.<span class="Apple-converted-space">  </span>The width and height of the <i>rect</i> are specified by two more facts - <i>geometry_w</i> and <i>geometry_h</i>, resp.<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">The <i>node</i> fact is obsolete - it is used to declare the presence of a new <i>id</i> for some kind of graphical object.<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5">If a <i>text fact </i>contains its text in single-quotes [‘].<span class="Apple-converted-space">  </span>If the text consists of only digits 0-9, it has no quotes.<span class="Apple-converted-space">  </span>Further down the pipeline, Prolog differentiates numeric <i>text facts</i> from strings by the non-presence or presence of quotes, resp. (See 2.1).<span class="Apple-converted-space">  </span>This differentiation is used by the bootstrap compiler to ensure that every port has a numeric index.<span class="Apple-converted-space">  </span>Only some ports have string names, but all ports have indices.</p>
<p class="p4"><br></p>
<p class="p5">Each line is described by a <i>path</i>, a <i>begin</i>ning coord and an <i>end</i> coordinate. <span class="Apple-converted-space">  </span>All intermediate points on a line (the bends drawn in Draw.IO) are discarded.<span class="Apple-converted-space">  </span>The compiler needs only to know where the line begins and ends.<span class="Apple-converted-space">  </span>Draw.IO does some of the work for us by making all lines fully contiguous, even if the line contains intermediate points.<span class="Apple-converted-space">  </span>In other drawing editors, it might be necessary to draw a bent line using line segments.<span class="Apple-converted-space">  </span>In this case,<a id="fnlink6"></a><a href="#fn6"><sup>[6]</sup></a> a pass needs to be added to the compiler to infer which segments touch one another and to infer a contiguous line, its beginning and end points.</p>
<p class="p4"><br></p>
<p class="p5">Arrows are specified by an (<i>x,y</i>) coordinate that corresponds to the tip of the arrow.<span class="Apple-converted-space">  </span>The tip coordinates must be near the end of a line (path).<span class="Apple-converted-space">  </span>The arrow tip is recognised as the <i>end</i> of the line.<span class="Apple-converted-space">  </span>The <i>arrows</i> give direction to lines and show which way the events flow.<span class="Apple-converted-space">  </span>In other versions of the compiler, one might choose to discard arrows and supply only output and input pins.<span class="Apple-converted-space">  </span>Compiler passes would be added to infer the direction of the lines (e.g. output pins imply <i>begin</i>nings of lines and input pins imply <i>end</i>ings of lines).</p>
<p class="p4"><br></p>
<p class="p5">All lines are assigned <i>begin</i> and <i>end</i> ports and these port facts are emitted to <i>stdout</i></p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"><span class="s11">plsort</span><span class="Apple-converted-space"> </span></li>
</ul>
<p class="p11"><br></p>
<p class="p5">This Part is a no-op.<span class="Apple-converted-space">  </span>It performs a *nix sort on the <i>factbase.</i><span class="Apple-converted-space">  </span>Prolog requires that all <i>facts</i> of the same kind be grouped together.<span class="Apple-converted-space">  </span>All incoming <i>facts</i> on <i>stdin</i> are sorted then output on <i>stdout</i>.<span class="Apple-converted-space">  </span>The factbase is not changed, just re-arranged.</p>
<p class="p11"><br></p>
<p class="p5">This Part is implemented as a *nix shell script using the <i>sort(1)</i> command.</p>
<p class="p11"><br></p>
<ul class="ul1">
  <li class="li10"><span class="s11">check_input</span></li>
</ul>
<p class="p4"><br></p>
<p class="p5">This Part is a place-holder that might be implemented in a non-POC / bootstrap version of the compiler.<span class="Apple-converted-space">  </span>Its purpose is to sanity-check the incoming (<i>stdin</i>) factbase.<span class="Apple-converted-space">  </span>In the bootstrap, this Part does almost nothing - it loads the <i>factbase</i> into Prolog, then spits it back out (<i>stdout</i>).<span class="Apple-converted-space">  </span>If there are any problems on input, Prolog will throw an error.</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Parser</b></h2>
<p class="p11"><br></p>
<p class="p5">This Part - the Parser (a Composite Part) does most of the work for the compiler.</p>
<p class="p11"><br></p>
<p class="p5">This Part accepts the fairly simple factbase and infers a great deal of information about the drawing. No sanity checking is performed in the Parser pass (checking is the domain of the following pipeline part “Semantic Check”).</p>
<p class="p11"><br></p>
<p class="p5">This Part emits (to stdout) an updated factbase containing “more interesting” details about the drawing.<span class="Apple-converted-space">  </span>In the POC / bootstrap, we do not elide any facts, all facts are kept in the factbase - the bootstrap was a growing “experiment” to see which facts were needed by the Coder phase.</p>
<p class="p11"><br></p>
<p class="p5">The Parser, in its current state, uses 10 Parts to complete the inferencing.<span class="Apple-converted-space">  </span>Each child Part is fairly simple.<span class="Apple-converted-space">  </span>We used Prolog to implement the Parts, since backtracking search for inferencing was required.<span class="Apple-converted-space">  </span>We could have used other inferencing / relational techniques, such as mini-Karen or deeply nested loops.<a id="fnlink7"></a><a href="#fn7"><sup>[7]</sup></a></p>
<p class="p11"><br></p>
<p class="p5">Each Prolog child Part begins by reading the factbase (from stdin) (files: “head.pl” and rule “readFB”).<span class="Apple-converted-space">  </span>It then performs inferencing per its main rule.<span class="Apple-converted-space">  </span>Finally it writes out the augmented factbase using rule “writeFB” (see file “tail.pl”) and calls “halt.”.</p>
<p class="p11"><br></p>
<p class="p5">Most of the passes do not need explanation.<span class="Apple-converted-space">  </span>In such cases, only the <span class="s11">new</span> facts added to the <i>factbase</i> by the pass are listed.</p>
<p class="p11"><br></p>
<ul class="ul1">
  <li class="li10"> <span class="s11">calc_bounds</span></li>
</ul>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_left(&lt;id&gt;,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_top(&lt;id&gt;,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_right(&lt;id&gt;,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>bounding_box_bottom(&lt;id&gt;,nnnn).</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"> <span class="s11">add_kinds</span></li>
</ul>
<p class="p7"><span class="Apple-converted-space">  </span>used(text-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>kind(box-id,Str).</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"> <span class="s11">make-unknown_port_names</span></li>
</ul>
<p class="p7"><span class="Apple-converted-space">  </span>unassigned(text-id).</p>
<p class="p4"><span class="Apple-converted-space">  </span></p>
<ul class="ul1">
  <li class="li10"> <span class="s11">create_centers</span></li>
</ul>
<p class="p7"><span class="Apple-converted-space">  </span>center_x(unassigned-text-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>center_y(unassigned-text-id).</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"> <span class="s11">calculate_distance</span></li>
</ul>
<p class="p7"><span class="Apple-converted-space">  </span>join_distance(join-pair-id,text-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>distance_xy(join-pair-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">  </span>join_centerPair(port-id,centerPair-id).</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"> <span class="s11">assign_portnames</span></li>
</ul>
<p class="p7"><span class="Apple-converted-space">  </span>portNameByID(port-id,text-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>portName(port-id,string).</p>
<p class="p7"><span class="Apple-converted-space">  </span>portIndexByID(port-id,num-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>portIndex(port-id,num-id).</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"> <span class="s11">markIndexedPorts</span></li>
</ul>
<p class="p7"><span class="Apple-converted-space">  </span>indexedSink(port-id).</p>
<p class="p7"><span class="Apple-converted-space">  </span>indexedSource(port-id).</p>
<p class="p4"><span class="Apple-converted-space">  </span></p>
<ul class="ul1">
  <li class="li10"> <span class="s11">coincidentPorts</span></li>
</ul>
<p class="p7"><span class="Apple-converted-space">  </span>portIndex(unindexed-port,index).</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"> <span class="s11">mark_directions</span></li>
</ul>
<p class="p7"><span class="Apple-converted-space">   </span># nothing - yEd and draw.io produce edges with direction</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"> <span class="s11">match_ports_to_components</span></li>
</ul>
<p class="p7"><span class="Apple-converted-space">   </span>parent(port-id,parent-id).</p>
<p class="p7"><span class="Apple-converted-space">   </span>n_c(port-id).</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Semantic Pass</b></h2>
<p class="p11"><br></p>
<p class="p5">The Semantic Pass should check as many design constraints as possible, e.g. types, and prevent the coder from producing code, if any design constraints are violated.<span class="Apple-converted-space">  </span>In this POC, the semantic pass exists only as an exemplar and does any real amount of design-rules checking.</p>
<p class="p11"><br></p>
<p class="p5">Once the <i>factbase</i> is emitted by the Semantic Pass,<i> </i>the <i>factbase</i> is “certified correct”, meaning that the original program is a correct program and meets all requirements posed by the language (a diagrammatic language, in this case).</p>
<p class="p11"><br></p>
<p class="p5">This POC / bootstrap contains very few semantic checks, for clarity and for development time.</p>
<p class="p11"><br></p>
<p class="p5">The two semantic checks, below, show how simple and self-contained each check can be.<span class="Apple-converted-space">  </span>The checks should all have an “error” output (but don’t, due to the bootstrapping nature of this example POC<span class="Apple-converted-space">  </span>compiler).<span class="Apple-converted-space">  </span>The error outputs might all be bussed together on a single error line that is an output of the semantic pass Composite Part.<span class="Apple-converted-space">  </span>If <i>anything</i> is output to the error output, the coder should ignore the incoming <i>factbase</i> and refuse to produce output code.</p>
<p class="p11"><br></p>
<ul class="ul1">
  <li class="li10"><span class="Apple-converted-space">  </span>sem_partsHaveSomePort</li>
</ul>
<p class="p11"><br></p>
<p class="p5">This Part checks that there is at least one port on every Part, in the system being compiled.<span class="Apple-converted-space">  </span>A Part with no pins does not make sense and is illegal.<a id="fnlink8"></a><a href="#fn8"><sup>[8]</sup></a></p>
<p class="p11"><br></p>
<ul class="ul1">
  <li class="li10"><span class="Apple-converted-space">  </span>sem_allPortsHaveAnIndex</li>
</ul>
<p class="p11"><br></p>
<p class="p5">This Part checks the underlying assumption that all Ports (on Parts) have a numeric index.<span class="Apple-converted-space">  </span>As the POC compiler stands at the moment, there is an underlying assumption that an index has been created for each Port.<span class="Apple-converted-space">  </span>If there are any Ports without an index, the prolog code might miss them and the <i>factbase</i> might describe an illegal program.</p>
<p class="p11"><br></p>
<p class="p5">Many other design constraint checks can be performed, but aren’t in this bootstrap POC compiler.<span class="Apple-converted-space">  </span>For example, all wires must terminate on Ports, etc.</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>Code Emitter</b></h2>
<p class="p11"><br></p>
<p class="p5">The Coder (aka Code Emitter) produces code from the diagram, for various languages.<span class="Apple-converted-space">  </span>In this particular POC, we produce code for JavaScript (JS).<span class="Apple-converted-space">  </span>In this particular POC, the JS code we produce is a JSON wiring table. (We join the JSON with <i>leaf</i> parts (JS) and a <i>kernel</i> in a later “build” pass).</p>
<p class="p11"><br></p>
<p class="p5">A Coder might also contain an optimiser, but this POC does not contain an optimiser.</p>
<p class="p11"><br></p>
<p class="p5">In this POC, the code consists of seven child Parts.<span class="Apple-converted-space">  </span>The first four Parts are written in Prolog and deal mostly with creating a “wire” array (called “pipes” for historical reasons), creating unique indices for the wires and describing which wire indices refer to which Pins.</p>
<p class="p11"><br></p>
<p class="p5">The fifth pass is just another *nix sort for Prolog requirements (probably unneeded, as it was experimental).</p>
<p class="p11"><br></p>
<p class="p5">The sixth Part, “emit-js” uses Prolog to walk the <i>factbase</i> and to emit intermediate code that can be read by Lisp.</p>
<p class="p11"><br></p>
<p class="p5">The final Part, “emit-js2” is written in Lisp and simply transforms the intermediate code from “emit-js” as a legal JSON table in JS.<span class="Apple-converted-space">  </span>Note that the character “@“ is a legal identifier character in Lisp.<span class="Apple-converted-space">  </span>The meat of this Part is in main() and describes its architecture as calls to zero-argument functions.<span class="Apple-converted-space">  </span>Each of the functions are prefixed with the character “@“ to mean that they are “mechanisms” (in the S/SL<a id="fnlink9"></a><a href="#fn9"><span class="s12"><sup>[9]</sup></span></a> sense).<span class="Apple-converted-space">  </span>These “@“ functions “support” the architectural intent written out in main().<span class="Apple-converted-space">  </span>Lisp was chosen for this Part, due to its rich output formatting, due to its ability to read() the intermediate code and familiarity to the author.<span class="Apple-converted-space">  </span>Any other language could have been used, and the preceding Part (“emit-js”) could have been tweaked to make the work easier in the other language.</p>
<p class="p11"><br></p>
<ul class="ul1">
  <li class="li10"><span class="Apple-converted-space">  </span>assign_wire_numbers_to_inputs</li>
</ul>
<p class="p7"><span class="Apple-converted-space">    </span>nwires(nnnn).</p>
<p class="p7"><span class="Apple-converted-space">    </span>wireNum(pin-id,nnnn).</p>
<p class="p8"><br></p>
<p class="p5">This pass creates a unique index (a number, incrementing monotonically starting at 0) for each wire in the diagram being compiled.<span class="Apple-converted-space">  </span>This pass creates a <i>fact</i> indicating the maximum number of wires and a <i>fact</i> for each wire associated with every input pin.<span class="Apple-converted-space">  </span>An input pin might have 0 or more wires connected to it.</p>
<p class="p4"><span class="Apple-converted-space">    </span></p>
<ul class="ul1">
  <li class="li10"><span class="Apple-converted-space">  </span>assign_wire_numbers_to_outputs</li>
</ul>
<p class="p7"><span class="Apple-converted-space">    </span>wireNum(pin-id,nnnn).</p>
<p class="p8"><br></p>
<p class="p5">This pass associates one or more wire numbers with each output pin on the diagram.</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"><span class="Apple-converted-space">  </span>assign_portIndices</li>
</ul>
<p class="p7"><span class="Apple-converted-space">    </span>sourcePortIndex(pin-id,nnnn).</p>
<p class="p7"><span class="Apple-converted-space">    </span>sinkPortIndex(pin-id,nnnn).</p>
<p class="p4"><br></p>
<p class="p5">This pass visits every pin (input and output) and creates a fact associating an index (a number) with it.<span class="Apple-converted-space">  </span>It also marks whether the pin is a source or a sink.<span class="Apple-converted-space">  </span>This pass simply collapses information that is already in the factbase, making traversal easier in downstream passes.</p>
<p class="p4"><br></p>
<ul class="ul1">
  <li class="li10"><span class="Apple-converted-space">  </span>inOutPins</li>
</ul>
<p class="p7"><span class="Apple-converted-space">    </span>inputPin(part-id,pin-id).</p>
<p class="p7"><span class="Apple-converted-space">    </span>outputPin(part-id,pin-id).</p>
<p class="p7"><span class="Apple-converted-space">    </span>wireIndex(pin-id,wire-index).</p>
<p class="p7"><span class="Apple-converted-space">    </span>n_c(pin-id).</p>
<p class="p8"><br></p>
<p class="p5">This pass marks every pin, associated with Part, as being an input or an output pin of that Part.<span class="Apple-converted-space">  </span>It also gathers the wire index and creates a wireIndex fact.<span class="Apple-converted-space">  </span>Pins that have no wires attached to them are marked as “No Connection” (n_c).<span class="Apple-converted-space"> </span></p>
<p class="p22"><br></p>
<ul class="ul1">
  <li class="li10"><span class="Apple-converted-space">  </span>plsort</li>
</ul>
<p class="p11"><br></p>
<p class="p5">This is the same as the previous plsort.<span class="Apple-converted-space">  </span>It simply uses *nix sort() to sort the factbase and to group like-named rules together according to Prolog’s requirements.<span class="Apple-converted-space">  </span>This pass might now be a no-op in the finished POC.<span class="Apple-converted-space">  </span>We need to test whether this Part can be removed from the pipeline.<a id="fnlink10"></a><a href="#fn10"><sup>[10]</sup></a></p>
<p class="p11"><br></p>
<ul class="ul1">
  <li class="li10"><span class="Apple-converted-space">  </span>emit-js</li>
</ul>
<p class="p11"><br></p>
<p class="p5">This Part is one-half of the final output functionality.<span class="Apple-converted-space">  </span>It gathers the information, from the <i>factbase</i>, to write out the JSON table.<span class="Apple-converted-space">  </span>Prolog is used for this Pass, since Prolog makes it “simple” to pattern-match, using backtracking, for the required information.<span class="Apple-converted-space">  </span>The author deemed it “easier” to format the output using Lisp instead of Prolog, hence emission is cut into two Parts.<span class="Apple-converted-space">  </span>This Part outputs a lisp data structure, not a <i>factbase</i>.</p>
<p class="p11"><br></p>
<ul class="ul1">
  <li class="li10"><span class="Apple-converted-space">  </span>emit-js2</li>
</ul>
<p class="p11"><br></p>
<p class="p5">This Part finalises the output, using Lisp code to read the the output from “emit-js” and uses Lisp’s “format” function to produce an indented JSON table.<span class="Apple-converted-space">  </span>This table is meant to be coupled (TBD) with the JS kernel code and any JS methods that are used by the parent Part.</p>
<p class="p23"><br></p>
<hr>
<p class="p24"><a id="fn1"></a><a href="#fnlink1"><span class="s13">[1]</span></a><span class="s13"> </span>The advantage to using a structure-less data structure is that one can apply no pre-conceptions to the data.<span class="Apple-converted-space">  </span>This leaves the software Architecture <i>open </i>for future consideration. An example I like to use is to create a completely different use for the <i>unordered factbase, </i>e.g. what if I want to create a Gantt Chart from the data?<span class="Apple-converted-space">  </span>If the data has a pre-determined structure, then it might not suit a Gantt Chart app.<span class="Apple-converted-space">  </span>This approach <i>wastes</i> cpu in lieu of data design, but save human-time (we have lots of cpu time to burn, using the latest hardware).</p>
<p class="p24"><a id="fn2"></a><a href="#fnlink2"><span class="s13">[2]</span></a><span class="s13"> </span>A <i>factbase</i> is very similar to a <i>triplestore</i> in Web3.</p>
<p class="p24"><a id="fn3"></a><a href="#fnlink3"><span class="s13">[3]</span></a><span class="s13"> </span>In fact, can a Prolog be twisted inside-out to suggest what structure the <i>factbase</i> should have to make future searches faster???</p>
<p class="p10"><span class="s14"><a id="fn4"></a><a href="#fnlink4"><span class="s13">[4]</span></a></span> We might need to delete the <i>line</i> <i>facts, </i>or mark them “used”, depending on the design of the compiler and the drawing conventions and whether the <i>line facts</i> interfere with further pattern matching in downstream passes.<span class="Apple-converted-space">  </span>In this particular case (PoC), we don’t need to pattern match lines to make rectangles, since Draw.IO already provides <i>rectangles</i>.</p>
<p class="p11"><br></p>
<p class="p10">In this POC, we simply invent new names for facts, such that old facts do not overlap with new facts, and old facts never need to be deleted.</p>
<p class="p11"><br></p>
<p class="p10">For example, <i>rectangle</i> <i>fact</i> carries more <span class="s11">semantic</span> information that any <i>line facts</i>.<span class="Apple-converted-space">  </span>Once we create a <i>rectangle fact</i>, we simply ignore all <i>line facts</i> in future (downstream) passes.</p>
<p class="p24"><span class="s13"><a id="fn5"></a><a href="#fnlink5">[5]</a> </span>N.B. This method of backtracking parsing has not been fully explored (but, see <a href="http://bford.info/packrat/"><span class="s6">http://bford.info/packrat/</span></a><span class="s6">)</span><span class="s7">, hence, creating useful error messages has not been explored fully.</span></p>
<p class="p25"><a id="fn6"></a><a href="#fnlink6"><span class="s13">[6]</span></a><span class="s13"> </span><span class="s5">But, not for this POC.</span></p>
<p class="p24"><a id="fn7"></a><a href="#fnlink7"><span class="s13">[7]</span></a><span class="s13"> </span>Searching the <i>factbase</i> for patterns can be done in any language.<span class="Apple-converted-space">  </span>Pattern matching happened to be very easy in Prolog.</p>
<p class="p24"><a id="fn8"></a><a href="#fnlink8"><span class="s13">[8]</span></a><span class="s13"> </span>Note to self: Is it legal to have a pinless component at the Top Level???</p>
<p class="p15"><span class="s15"><a id="fn9"></a><a href="#fnlink9"><span class="s16">[9]</span></a></span><span class="s16"> <a href="https://dl.acm.org/citation.cfm?id=357164"><span class="s9">https://dl.acm.org/citation.cfm?id=357164</span></a></span></p>
<p class="p24"><span class="s6"><a href="https://dl.acm.org/citation.cfm?id=357164"><a id="fn10"></a></a><a href="#fnlink10"><span class="s17">[10]</span></a><a href="https://dl.acm.org/citation.cfm?id=357164"><span class="s17"> </span></a></span>At time of writing - this plsort part might have been removed from the POC.</p>
</div>
</body>
</html>
