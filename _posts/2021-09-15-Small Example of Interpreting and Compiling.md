---
layout: post
title:  "Small Example of Interpreting and Compiling"
---
# Introduction
This note shows a very small example of using Ohm-JS to build an interpreter and a transpiler.

# Steps
I suggest a sequence of 4 steps for producing a transpiler:
1. Write and debug the grammar using Ohm-Editor.
2. Build the Ohm-JS support code around the grammar. Test that it works.
3. Build the interpreter.
4. Modify the interpreter to turn it into a transpiler.

This note shows these 4 steps.

# Transpiler / Compiler

I use the words _transpiler_ and _compiler_ interchangeably.

Typically, a _compiler_ is thought to compile a source language into _assembler_.

I try to use the word _transpiler_ when I am talking about compiling a source language into HLL assembler, like Common Lisp, JavaScript, etc[^1].  

[^1]: A "good" HLL assembler is a language that has little syntax, is mostly expression-based, doesn't insist on declaration-before-use and so on. I.E. a "good" assembler language is machine-readable/writable but might not be very human-readable. The emphasis is on features that aid machine reading and writing. Human-readability is secondary.

The task of building a _transpiler_ is the same as building a _compiler_, but the details are different.

# Ohm-JS

Ohm-JS is a PEG parser application that 

# The ABC Language
The ABC "language" allows:
- only single-letter variable names
- one operator `+` which must refer to variables only (not numbers/integers)
- assignment of integers to variables
- assignment of expressions to variables.

I hope that these severe simplifications make the underlying interpreter/transpiler simple to understand.

I believe that the underlying code can be easily extended to accept a larger input language.

# Source Example - ABC
```
b = 2
c = 3
a = b + c
```
# Step 1 - Grammar Development

<img src="https://github.com/guitarvydas/guitarvydas.github.io/blob/master/assets/Ohm%20Editor%20Screen%20Shot%202021-09-15%20at%204.58.14%20PM.png?raw=true" alt="Ohm Editor Screen Shot 2021-09-15 at 4.58.14 PM.png" style="zoom:67%;" />

# Step 2 - Scaffolding
## Step 2.1 - Roughing In The Action Code (Semantics)
Create a JS object with one named function property for each rule in the grammar.

The property names must match _exactly_ with the names of the grammar rules.


Each function has parameters that name the sub-matches of a given rule.

Each function must have _exactly_ the same number of parameters as there are sub-matches in the corresponding grammar rules.

The parameter names do not matter, but it is a good idea to make the names meaningful.

I use the prefix "k" to mean a _constant_ string, called a _terminal_ in Ohm-JS-ese.

Rules that have multiple branches with differing sub-matches must be marked by "-- _name_" in the grammar. Such functions are written as _function\_name_ in the supporting JS code.  Our example contains one such multi-branch rule - `Assignment`.[^4]

[^4]: In fact, Assignment could easily be rewritten to have only one branch.  I have left it as it is for expository purposes. Collapsing Assignment down to a single branch is left as an exercise to the reader.

```
exports.roughInSemantics = {
    TopLevel: function (assignments) {
    },
    
    Assignment_simple: function (v, keq, n) {
    },

    Assignment_complex: function (v, keq, expr) {
    },

    Expression: function (v1, kplus, v2) {
    },

    Variable: function (c) {
    },

    number: function (ds) {
    }
};
```
## Step 2.2 - The Other Stuff
The grammar and the semantics need to be wrapped with boilerplate JS code.

I chose to put the grammar inline and the action code in a separate file.  It doesn't matter how the code is structured, as long as all of the code is seen by the JS compiler.

I chose to use `node.js` for this example, but a `.html` version of the code could also be constructed.  In fact, Ohm-JS makes it easy to create grammars and compilers in webpages.  See the Ohm-JS documentation for further details.

We need to bring in the libraries:
- ohm-js, and,
- fs.

We need to supply 
- the grammar

- the action code (aka semantics)

- test program source code.

First, we let Ohm-JS build a CST[^2] by parsing the test program source.

[^2]: A CST is a Concrete Syntax Tree.  It is, essentially, an AST (Abstract Syntax Tree) for the grammar, pruned down to only the nodes that are matched in the input test program.

If that operation (the _parse_) succeeds, we hang various bits of action code (aka semantics) onto the CST generated by Ohm-JS.

In subsequent steps, we will hang an interpreter _and_ a transpiler onto the generated CST. We will ask Ohm-JS to walk the parse tree and invoke our action code (aka semantics) during the tree-walk.

The rest of the source code for this step (2) is shown below:

```
'use strict'

var ohm = require('ohm-js');
var fs = require('fs');

var semanticsCode = require('./abcSemanticsRoughIn.js');
var source = fs.readFileSync ('test.abc', 'utf-8');

var grammar = `
ABCgrok {
TopLevel = Assignment+

  Assignment =   Variable "=" Expression -- complex
               | Variable "=" number -- simple
  Expression = Variable "+" Variable

    Variable = "a" .. "z"
    number = digit+
}
`;


function main () {
    let parser = ohm.grammar (grammar);
    let cst = parser.match (source);
    if (cst.succeeded ()) {
	let cstSemantics = parser.createSemantics ();
	cstSemantics.addOperation ('roughIn', semanticsCode.roughInSemantics);
    } else {
	console.log (parser.trace (source).toString ());
	throw ("grammar error :");
    }
}

main ();
```

To run this second step, use the bash script:
- ./run2.bash

# Step 3 - Interpreter

The interpreter executes ABC operations as the parse tree is walked.

Simple _assignment_ statements, like

- b = 2

fetch the variable name (_b_ in this case), fetch the RHS value (_2_ in this case) and then put the fetche value into the symbol table under the fetched name. 

A VM-based interpreter would create a _stack_ data structure and would leave the fetched value on the _stack_.

The TopLevel function simply returns the whole symbol table, in this case.  This is a convenient operation in JavaScript and might be implemented differently when another underlying language were used.

The _tree walking_ is performed by calling the _interpret()_ function on matching nodes.

```
exports.interpret = {

    TopLevel: function (assignments) {
        var dontcare = assignments.interpret ();
        return symbolTable.symbolTable;
    },
    
    Assignment_simple: function (v, keq, n) {
        var name = v.interpret ();
        var value = n.interpret ();
        symbolTable.symbolTable[name] = value;
    },

    Assignment_complex: function (v, keq, expr) {
        let value = expr.interpret ();
        symbolTable.symbolTable[v.interpret ()] = value;
    },

    Expression: function (v1, kplus, v2) {
        let name1 = v1.interpret ();
        let name2 = v2.interpret ();
        let value1 = symbolTable.symbolTable [name1];
        let value2 = symbolTable.symbolTable [name2];
        return value1 + value2;
    },

    Variable: function (c) {
        return this.sourceString;
    },

    number: function (ds) {
        return parseInt (this.sourceString);
    }    
};
```
To run this (third) step use the bash script

- ./run3.bash

  You should see

  - { interpreted: { b: 2, c: 3, a: 5 } }

# Step 4 - Transpiler

The transpiler (aka compiler) uses the same parse tree as in step 3, but performs different actions.

In this case, the TopLevel returns a string of JS code.

The transpiler converts ABC statements into JS statements. It should be obvious how to change this code to return a string of Python, WASM, etc. code.[^3]

In this case, each action creates a string of code (JS code in this case).  I used JS _template strings` as a convenience.

Each _return_ statement returns a string.

The TopLevel function receives an array of strings (thanks to the Ohm-JS `+` operator).  The strings in this array are glued together into one large string (using the .join() JS method) and returned.

[^3]: See below for examples of emitting WASM, Python, JS and Lisp for a more interesting example language (the _arithmetic_ language in the Ohm-JS example set).

```
exports.transpile = {

    TopLevel: function (assignments) {
        var finalString = assignments.transpile ().join ('\n');
        return finalString;
    },
    
    Assignment_simple: function (v, keq, n) {
        var name = v.transpile ();
        var value = n.transpile ();
        return `var ${name} = ${value};`; 
    },

    Assignment_complex: function (v, keq, expr) {
        var name = v.transpile ();
        var value = expr.transpile ();
        return `var ${name} = ${value};`; 
    },

    Expression: function (v1, kplus, v2) {
        let name1 = v1.transpile ();
        let name2 = v2.transpile ();
        return `${name1} + ${name2}`;
    },

    Variable: function (c) {
        return this.sourceString;
    },

    number: function (ds) {
        return this.sourceString;
    }
};
```
To run this (third) step use the bash script

- ./run4.bash

  You should see (interpreted and transpiled code)

  - { b: 2, c: 3, a: 5 }

    var b = 2;

    var c = 3;

    var a = b + c;

# Appendix Github
[abc](https://github.com/guitarvydas/abc)

# Appendix Ohm-JS

[Ohm-JS](https://github.com/harc/ohm)

# Appendix Ohm-Editor

[Ohm Editor](https://ohmlang.github.io/editor/)

# Appendix See Also

[WASM Transpiler](https://guitarvydas.github.io/2021/05/15/WASM-Arithmetic-Transpiler.html)

[Python, JS, Lisp Transpilers](https://guitarvydas.github.io/2021/05/11/Ohm-Arithmetic.html)

[Scheme to JS Transpiler](https://github.com/guitarvydas/js-prolog)

[Ohm In Small Steps](https://computingsimplicity.neocities.org/blogs/OhmInSmallSteps.pdf)

[Blog](https://guitarvydas.github.io)
[Videos](https://www.youtube.com/channel/UC2bdO9l84VWGlRdeNy5)
[References](https://guitarvydas.github.io/2021/01/14/References.html)

<script src="https://utteranc.es/client.js" 
        repo="guitarvydas/guitarvydas.github.io" 
        issue-term="pathname" 
        theme="github-light" 
        crossorigin="anonymous" 
        async> 
</script> 
