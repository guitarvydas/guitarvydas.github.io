<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>OhmInSmallSteps</title>
  <meta name="Author" content="Paul Tarvydas">
  <meta name="CreationTime" content="2020-12-09T15:13:04Z">
  <meta name="ModificationTime" content="2020-12-09T15:13:04Z">
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.6">
  <style type="text/css">
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino}
    p.p3 {margin: 0.0px 0.0px 0.0px 36.0px; font: 13.0px Palatino}
    p.p4 {margin: 0.0px 0.0px 0.0px 72.0px; font: 13.0px Palatino}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; -webkit-text-stroke: #0000e9; min-height: 14.0px}
    p.p10 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo}
    p.p11 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo; min-height: 13.0px}
    p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 12.0px Times; color: #0000e9}
    p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 12.0px Times; color: #0000e9; min-height: 14.0px}
    p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 14.0px}
    p.p16 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo; -webkit-text-stroke: #0000e9}
    p.p17 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo; -webkit-text-stroke: #0000e9; min-height: 13.0px}
    p.p18 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 11.0px Menlo}
    p.p19 {margin: 0.0px 0.0px 0.0px 36.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Menlo}
    p.p21 {margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Menlo; min-height: 13.0px}
    p.p22 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0000e9}
    p.p23 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0000e9; min-height: 14.0px}
    p.p24 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9; min-height: 14.0px}
    p.p26 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p27 {margin: 0.0px 0.0px 0.0px 36.0px; text-indent: -36.0px; font: 12.0px Helvetica}
    p.p28 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000080}
    li.li2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino}
    li.li5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; min-height: 18.0px}
    span.s1 {text-decoration: underline}
    span.s2 {text-decoration: underline ; font-kerning: none}
    span.s3 {font-kerning: none}
    span.s4 {font: 11.0px Menlo}
    span.s5 {font: 13.0px Palatino; color: #000000}
    span.s6 {font: 12.0px Times; text-decoration: underline ; font-kerning: none}
    span.s7 {font: 9.0px Palatino}
    span.s8 {font: 13.0px Palatino; color: #000000; -webkit-text-stroke: 0px #000000}
    span.s9 {font: 13.0px 'Times New Roman'}
    span.s10 {font: 12.0px Times; text-decoration: underline ; font-kerning: none; color: #0000e9}
    span.s11 {font: 12.0px Times}
    span.s12 {font: 13.0px Times}
    span.s13 {font: 13.0px Symbol}
    span.s14 {font: 13.0px Palatino}
    span.s15 {font: 11.0px Menlo; text-decoration: underline ; font-kerning: none}
    span.s16 {font: 11.0px Menlo; text-decoration: underline ; font-kerning: none; color: #0000e9}
    span.s17 {font: 12.0px Times; text-decoration: underline ; color: #000080}
    span.s18 {font: 11.0px Menlo; text-decoration: underline}
    span.s19 {font: 12.0px Helvetica; color: #000000}
    span.Apple-tab-span {white-space:pre}
    table.t1 {border-collapse: collapse}
    td.td1 {border-style: solid; border-width: 1.0px 1.0px 1.0px 1.0px; border-color: #000000 #000000 #000000 #000000; padding: 0.0px 5.0px 0.0px 5.0px}
    td.td2 {border-style: solid; border-width: 1.0px 1.0px 1.0px 1.0px; border-color: #bfbfbf #bfbfbf #bfbfbf #bfbfbf; padding: 0.0px 5.0px 0.0px 5.0px}
    ol.ol1 {list-style-type: decimal}
    ol.ol2 {list-style-type: lower-alpha}
    ul.ul1 {list-style-type: hyphen}
    ul.ul2 {list-style-type: disc}
  </style>
</head>
<body>
<div style="width: 600px; margin: 0 auto">

<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Contents</b></h2>
<p class="p2">Contents<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Introduction<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">GitHub<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Source to Source<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">1. Get the Grammar to Work<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">2. Add Semantics<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Matching Pairs<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Flip Chunks of Code<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Find and Replace<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Skip Spaces<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Skipping Comments<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Grammar Inheritance<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Extending a Rule<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Overriding a Rule<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Start Rule<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">CST<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Pipelining Grammars<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Lines and Filenames<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Math Example in Browser<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Ohm and PROLOG<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Introduction<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">PROLOG CONTROL in 6 SLIDES<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Ohm and Scheme<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Basic Scheme Parser<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Inherit the Basic Parser<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Basic Scheme Version #2<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Basic Scheme vs prolog-6.scm<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Lisp is Assembly Language<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Basic Scheme to JS<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Unity Parser<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Expanding Quotes<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Expanding Backquotes<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Pipelning Grammar<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Top Level Forms<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p4">Tweak the Grammar for the 3 Top-Level Scheme Constructs<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Multiple Grammars in One HTML File<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Semantics - Quoting<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Special Forms<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Interlude - Illegal Characters<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">List Constants<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">When Do You Create a New Pass?<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Grammar Inheritance<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Isolation<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Emitting JavaScript<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Functional JS<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Waterfall<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Workflow<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Mapping Illegals to JS<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Refining Scheme to JS Emission<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Writability vs. Readability<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Greedy Matching<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Quoting Revisited<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Dotted Lists<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Dissecting the Parse<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Larger Tests<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Sweeping Changes<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Quote List Expansion<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Let*<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Function Copy()<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">MIssing Support Routines<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Working<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Recap<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Transpiling to Other Languages<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p3">Returning a List of Answers<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p4">Accumulator in print-frame<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Deeper<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Ideas<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p2">Errata<span class="s1"><span class="Apple-tab-span">	</span></span>?</p>
<p class="p5"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Introduction</b></h2>
<p class="p6">This is a set of experiments with 2 outcomes:</p>
<p class="p5"><br></p>
<ol class="ol1">
  <li class="li2">PROLOG in JavaScript - transpilation of Nils Holm's PROLOG in Scheme to JavaScript.</li>
  <li class="li2">A deep dive into Ohm-JS with commentary along the way.
  <ul class="ul1">
    <li class="li2">How to build a transpiler in OHM (which is a <i>lot</i> less work than building a whole language)</li>
    <li class="li2">a "stream of consciousness" description of how I built the transpiler, including errors on my part</li>
  </ul></li>
</ol>
<p class="p7"><br></p>
<p class="p6">If you want only the PROLOG in JS, feel free to skip to the end of this document and latest commit in github.</p>
<p class="p7"><br></p>
<p class="p6">I perform some experiments with Ohm-js, fill my toolbelt and then move on to more interesting applications…</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>GitHub</b></h2>
<p class="p8"><span class="s2"><a href="https://github.com/guitarvydas/OhmSmallSteps">https://github.com/guitarvydas/OhmSmallSteps</a></span></p>
<p class="p9"><span class="s3"></span><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Source to Source</b></h2>
<p class="p6">This is the most basic example I could think of - input a string from a file, then dump it out. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6"><span class="s1">NPM install ohm</span></p>
<p class="p7"><br></p>
<p class="p6">npm install ohm-js</p>
<p class="p7"><br></p>
<p class="p6"><span class="s1">Ohm file source2source.ohm:</span></p>
<p class="p7"><br></p>
<p class="p10">Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>code = any*</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6"><span class="s1">JS (JavaScript) file source2source.js:</span></p>
<p class="p7"><br></p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node source2source.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('source2source.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('s2s.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p10">const semantics = grammar.createSemantics()</p>
<p class="p11"><br></p>
<p class="p10">// recursive function to get the source of a non-terminal node</p>
<p class="p10">// from https://repl.it/talk/learn/Making-your-own-programming-language-with-NodeJS/45779</p>
<p class="p10">const node_to_source = node =&gt; {</p>
<p class="p10"><span class="Apple-converted-space">    </span>if (node.ctorName == "_terminal") {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.primitiveValue</p>
<p class="p10"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.children.map(n =&gt; node_to_source(n)).join('')</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">semantics.addOperation(</p>
<p class="p10"><span class="Apple-converted-space">    </span>'dump',</p>
<p class="p10"><span class="Apple-converted-space">    </span>{</p>
<p class="p10"><span class="Apple-converted-space">        </span>code: (s) =&gt; {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return node_to_source(s._node)</p>
<p class="p10"><span class="Apple-converted-space">        </span>}</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">)</p>
<p class="p11"><br></p>
<p class="p10">console.log(semantics(result).dump())</p>
<p class="p7"><br></p>
<p class="p6"><span class="s1">Test file s2s.js:</span></p>
<p class="p7"><span class="s1"></span><br></p>
<p class="p10">/* a sample comment */</p>
<p class="p10">function f(a, b) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>a = b; // a 2nd sample comment</p>
<p class="p10">}</p>
<p class="p7"><br></p>
<p class="p6"><span class="s1">usage:</span></p>
<p class="p6">&gt; node source2source.js</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>1. Get the Grammar to Work</b></h2>
<p class="p6">My workflow is:</p>
<ol class="ol1">
  <li class="li2">Get the grammar right. <span class="Apple-converted-space"> </span></li>
  <li class="li2">Add semantics.</li>
</ol>
<p class="p5"><br></p>
<p class="p2">This is step 1 - see that the grammar is working as expected. <span class="Apple-converted-space"> </span></p>
<p class="p5"><br></p>
<p class="p2">This should print "Matching Succeeded".</p>
<p class="p5"><br></p>
<p class="p2">See source2source1a.js.</p>
<p class="p5"><br></p>
<p class="p7"><span class="s1"></span><br></p>
<p class="p6"><span class="s1">Ohm file source2source.ohm:</span></p>
<p class="p7"><br></p>
<p class="p10">Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>code = any*</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6"><span class="s1">JS (JavaScript) file source2source1a.js:</span></p>
<p class="p7"><br></p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node source2source1a.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('source2source.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('s2s.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6"><span class="s1">Test file s2s.js:</span></p>
<p class="p7"><span class="s1"></span><br></p>
<p class="p10">/* a sample comment */</p>
<p class="p10">function f(a, b) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>a = b; // a 2nd sample comment</p>
<p class="p10">}</p>
<p class="p7"><br></p>
<p class="p6"><span class="s1">usage:</span></p>
<p class="p6">&gt; node source2source1a.js</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>2. Add Semantics</b></h2>
<p class="p6"><span class="s1">Ohm file source2source.ohm:</span></p>
<p class="p7"><br></p>
<p class="p10">Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>code = any*</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6"><span class="s1">JS (JavaScript) file source2source1b.js:</span></p>
<p class="p7"><br></p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node source2source.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('source2source.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('s2s.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p10">const semantics = grammar.createSemantics()</p>
<p class="p11"><br></p>
<p class="p10">// recursive function to get the source of a non-terminal node</p>
<p class="p10">// from https://repl.it/talk/learn/Making-your-own-programming-language-with-NodeJS/45779</p>
<p class="p10">const node_to_source = node =&gt; {</p>
<p class="p10"><span class="Apple-converted-space">    </span>if (node.ctorName == "_terminal") {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.primitiveValue</p>
<p class="p10"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.children.map(n =&gt; node_to_source(n)).join('')</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">semantics.addOperation(</p>
<p class="p10"><span class="Apple-converted-space">    </span>'dump',</p>
<p class="p10"><span class="Apple-converted-space">    </span>{</p>
<p class="p10"><span class="Apple-converted-space">        </span>code: (s) =&gt; {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return node_to_source(s._node)</p>
<p class="p10"><span class="Apple-converted-space">        </span>}</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">)</p>
<p class="p11"><br></p>
<p class="p10">console.log(semantics(result).dump())</p>
<p class="p7"><br></p>
<p class="p6"><span class="s1">Test file s2s.js:</span></p>
<p class="p7"><span class="s1"></span><br></p>
<p class="p10">/* a sample comment */</p>
<p class="p10">function f(a, b) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>a = b; // a 2nd sample comment</p>
<p class="p10">}</p>
<p class="p7"><br></p>
<p class="p6"><span class="s1">usage:</span></p>
<p class="p6">&gt; node source2source1b.js</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Matching Pairs</b></h2>
<p class="p6">Ohm can parse matching pairs of delimiters.<span class="Apple-converted-space">  </span>This can't be done easily with YACC or REGEX.</p>
<p class="p7"><br></p>
<p class="p6">Ohm, PEG and recursive-descent parsers in general can include rules that call themselves.</p>
<p class="p7"><br></p>
<p class="p6">A very simple example is shown below…</p>
<p class="p11"><br></p>
<p class="p10">Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>code = matchingBraces+ eol</p>
<p class="p10"><span class="Apple-converted-space">  </span>matchingBraces =<span class="Apple-converted-space">    </span>"{" matchingBraces "}" -- braces<a id="fnlink1"></a><a href="#fn1"><sup>[1]</sup></a></p>
<p class="p10"><span class="Apple-converted-space">                    </span>| innards</p>
<p class="p10"><span class="Apple-converted-space">  </span>innards = "inside"</p>
<p class="p10"><span class="Apple-converted-space">  </span>eol = "\n"</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6">The "magic" happens in the "matchingBraces" rule.<span class="Apple-converted-space">  </span>It consumes an opening brace "{", calls itself, then consumes a closing brace "}".</p>
<p class="p7"><br></p>
<p class="p6">This grammar can parse nested sets of pairs, e.g. "{{inside}}".</p>
<p class="p7"><br></p>
<p class="p6">Pairtest.js:</p>
<p class="p11"><br></p>
<p class="p10">{{inside}}</p>
<p class="p11"><br></p>
<p class="p6">Pairs.js:</p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node pairs.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('pairs.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('pairtest.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p10">//console.log(grammar.trace(input).toString())</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">const semantics = grammar.createSemantics()</p>
<p class="p11"><br></p>
<p class="p10">// recursive function to get the source of a non-terminal node</p>
<p class="p10">// from https://repl.it/talk/learn/Making-your-own-programming-language-with-NodeJS/45779</p>
<p class="p10">const node_to_source = node =&gt; {</p>
<p class="p10"><span class="Apple-converted-space">    </span>if (node.ctorName == "_terminal") {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.primitiveValue</p>
<p class="p10"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.children.map(n =&gt; node_to_source(n)).join('')</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">semantics.addOperation(</p>
<p class="p10"><span class="Apple-converted-space">    </span>'dump',</p>
<p class="p10"><span class="Apple-converted-space">    </span>{</p>
<p class="p10"><span class="Apple-converted-space">        </span>code: (braced,eol) =&gt; {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return "matching pairs of braces=/" +<span class="Apple-converted-space">  </span>node_to_source(braced) + "/"</p>
<p class="p10"><span class="Apple-converted-space">        </span>}</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">)</p>
<p class="p11"><br></p>
<p class="p10">console.log(semantics(result).dump())</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Flip Chunks of Code</b></h2>
<p class="p6">I, finally, "do something". <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">The parser figures out "chunkA" and "chunkB" for me.</p>
<p class="p7"><br></p>
<p class="p6">Then, I use JS to construct a final string with chunkA and chunkB reversed.</p>
<p class="p7"><br></p>
<p class="p6">This is a cheesy solution, but hey, I believe in single-use DSLs, so it's open season.<span class="Apple-converted-space">  </span>Anything that will get me from Point a to Point b in a repeatable<a id="fnlink2"></a><a href="#fn2"><span class="s4"><sup>[2]</sup></span></a> fashion is OK with me.</p>
<p class="p7"><br></p>
<p class="p6">This simple example <i>could</i> have been done solely in JS using RegExps and .replace(), but, when the problem becomes larger, e.g. using a parser to refactor code, it is more easily handled with parsers than with REGEX.</p>
<p class="p7"><span class="Apple-converted-space"> </span></p>
<p class="p6">flip.ohm:</p>
<p class="p7"><br></p>
<p class="p10">Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>code = chunkA chunkB</p>
<p class="p10"><span class="Apple-converted-space">  </span>chunkA = "aaa" eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>chunkB = "bbb" eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>eol = "\n"</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6">fliptest.js</p>
<p class="p10">aaa</p>
<p class="p10">bbb</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p6">flip.js:</p>
<p class="p11"><br></p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node flip.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('flip.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('fliptest.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p10">const semantics = grammar.createSemantics()</p>
<p class="p11"><br></p>
<p class="p10">// recursive function to get the source of a non-terminal node</p>
<p class="p10">// from https://repl.it/talk/learn/Making-your-own-programming-language-with-NodeJS/45779</p>
<p class="p10">const node_to_source = node =&gt; {</p>
<p class="p10"><span class="Apple-converted-space">    </span>if (node.ctorName == "_terminal") {</p>
<p class="p10"><span class="Apple-tab-span">	</span>if (node.primitiveValue.toString() == "\n") {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return ''</p>
<p class="p10"><span class="Apple-tab-span">	</span>}</p>
<p class="p10"><span class="Apple-tab-span">	</span>else</p>
<p class="p10"><span class="Apple-converted-space">            </span>return node.primitiveValue</p>
<p class="p10"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.children.map(n =&gt; node_to_source(n)).join('')</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">semantics.addOperation(</p>
<p class="p10"><span class="Apple-converted-space">    </span>'dump',</p>
<p class="p10"><span class="Apple-converted-space">    </span>{</p>
<p class="p10"><span class="Apple-converted-space">        </span>code: (a,b) =&gt; {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return node_to_source(b) + node_to_source(a)</p>
<p class="p10"><span class="Apple-converted-space">        </span>}</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">)</p>
<p class="p11"><br></p>
<p class="p10">console.log(semantics(result).dump())</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Find and Replace</b></h2>
<p class="p6">More JS cheeze.<span class="Apple-converted-space">  </span>I use the previously built code and JS's .replace() with REGEXs to edit the final result…</p>
<p class="p7"><br></p>
<p class="p6">Again, this toy example doesn't show the full power of this kind of parsing/editing.</p>
<p class="p7"><br></p>
<p class="p6">I suggest that this is a technique that needs to be stored one's toolbelt.</p>
<p class="p7"><br></p>
<p class="p6">FindAndReplace.js:</p>
<p class="p7"><br></p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node flip.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('flip.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('fliptest.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p10">const semantics = grammar.createSemantics()</p>
<p class="p11"><br></p>
<p class="p10">// recursive function to get the source of a non-terminal node</p>
<p class="p10">// from https://repl.it/talk/learn/Making-your-own-programming-language-with-NodeJS/45779</p>
<p class="p10">const node_to_source = node =&gt; {</p>
<p class="p10"><span class="Apple-converted-space">    </span>if (node.ctorName == "_terminal") {</p>
<p class="p10"><span class="Apple-tab-span">	</span>if (node.primitiveValue.toString() == "\n") {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return ''</p>
<p class="p10"><span class="Apple-tab-span">	</span>}</p>
<p class="p10"><span class="Apple-tab-span">	</span>else</p>
<p class="p10"><span class="Apple-converted-space">            </span>return node.primitiveValue</p>
<p class="p10"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.children.map(n =&gt; node_to_source(n)).join('')</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">semantics.addOperation(</p>
<p class="p10"><span class="Apple-converted-space">    </span>'dump',</p>
<p class="p10"><span class="Apple-converted-space">    </span>{</p>
<p class="p10"><span class="Apple-converted-space">        </span>code: (a,b) =&gt; {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return node_to_source(b) + node_to_source(a).replace(/a/g, "ABC")</p>
<p class="p10"><span class="Apple-converted-space">        </span>}</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">)</p>
<p class="p11"><br></p>
<p class="p10">console.log(semantics(result).dump())</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Skip Spaces</b></h2>
<p class="p6">To skip spaces, I simply need to change all of the rules so that they begin with uppercase letters.</p>
<p class="p7"><br></p>
<p class="p6">N.B. The semantic action "code" must also be changed to "Code".</p>
<p class="p7"><br></p>
<p class="p6">I used the flip code for this test…</p>
<p class="p7"><br></p>
<p class="p6">skipspacestest.js:</p>
<p class="p10">ccc<span class="Apple-converted-space">  </span>ddd</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p6">skipspaces.ohm:</p>
<p class="p7"><br></p>
<p class="p10">Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Code = ChunkC ChunkD</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkC = "ccc" Eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkD = "ddd" Eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>Eol = "\n"</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6">skipspaces.js:</p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node skipspaces.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('skipspaces.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('skipspacestest.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p10">const semantics = grammar.createSemantics()</p>
<p class="p11"><br></p>
<p class="p10">// recursive function to get the source of a non-terminal node</p>
<p class="p10">// from https://repl.it/talk/learn/Making-your-own-programming-language-with-NodeJS/45779</p>
<p class="p10">const node_to_source = node =&gt; {</p>
<p class="p10"><span class="Apple-converted-space">    </span>if (node.ctorName == "_terminal") {</p>
<p class="p10"><span class="Apple-tab-span">	</span>if (node.primitiveValue.toString() == "\n") {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return ''</p>
<p class="p10"><span class="Apple-tab-span">	</span>}</p>
<p class="p10"><span class="Apple-tab-span">	</span>else</p>
<p class="p10"><span class="Apple-converted-space">            </span>return node.primitiveValue</p>
<p class="p10"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.children.map(n =&gt; node_to_source(n)).join('')</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">semantics.addOperation(</p>
<p class="p10"><span class="Apple-converted-space">    </span>'dump',</p>
<p class="p10"><span class="Apple-converted-space">    </span>{</p>
<p class="p10"><span class="Apple-converted-space">        </span>Code: (a,b) =&gt; {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return node_to_source(b) + node_to_source(a)</p>
<p class="p10"><span class="Apple-converted-space">        </span>}</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">)</p>
<p class="p11"><br></p>
<p class="p10">console.log(semantics(result).dump())</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Skipping Comments</b></h2>
<p class="p6">I use the original s2s.js as a test file, add (+=) a set of rules that treat comments as whitespace.</p>
<p class="p7"><br></p>
<p class="p6">skipcomments.ohm:</p>
<p class="p7"><br></p>
<p class="p10">Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Code = any*</p>
<p class="p10"><span class="Apple-converted-space">  </span>space += <span class="Apple-converted-space">  </span>slashStarComment</p>
<p class="p10"><span class="Apple-converted-space">           </span>| slashSlashComment</p>
<p class="p10"><span class="Apple-converted-space">  </span>slashStarComment = "/*" (~"*/" any)* "*/"</p>
<p class="p10"><span class="Apple-converted-space">  </span>slashSlashComment = "//" (~"\n" any)* "\n"</p>
<p class="p10">}</p>
<p class="p7"><br></p>
<p class="p6">skipcomments.js:</p>
<p class="p11"><br></p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node source2source1b.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('skipcomments.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('s2s.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p10">const semantics = grammar.createSemantics()</p>
<p class="p11"><br></p>
<p class="p10">// recursive function to get the source of a non-terminal node</p>
<p class="p10">// from https://repl.it/talk/learn/Making-your-own-programming-language-with-NodeJS/45779</p>
<p class="p10">const node_to_source = node =&gt; {</p>
<p class="p10"><span class="Apple-converted-space">    </span>if (node.ctorName == "_terminal") {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.primitiveValue</p>
<p class="p10"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.children.map(n =&gt; node_to_source(n)).join('')</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">semantics.addOperation(</p>
<p class="p10"><span class="Apple-converted-space">    </span>'dump',</p>
<p class="p10"><span class="Apple-converted-space">    </span>{</p>
<p class="p10"><span class="Apple-converted-space">        </span>Code: (s) =&gt; {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return node_to_source(s._node)</p>
<p class="p10"><span class="Apple-converted-space">        </span>}</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">)</p>
<p class="p11"><br></p>
<p class="p10">console.log(semantics(result).dump())</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Grammar Inheritance</b></h2>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Extending a Rule</b></h2>
<p class="p6">I've written a grammar where Program2 inherits from Program.</p>
<p class="p7"><br></p>
<p class="p6">Both grammars are in the same file<a id="fnlink3"></a><a href="#fn3"><span class="s4"><sup>[3]</sup></span></a>.</p>
<p class="p7"><br></p>
<p class="p6">I use the += operator to extend the rule "Code" in the second grammar Program2.</p>
<p class="p7"><br></p>
<p class="p6">N.B. I need to call ohm.grammars(…) not ohm.grammar(…) when there is more than one grammar in the file.<span class="Apple-converted-space">  </span>This call returns a namespace instead of a grammar object.</p>
<p class="p7"><br></p>
<p class="p6">N.B. The default start rule remains "Code" (inherited from the original grammar).<span class="Apple-converted-space">  </span>I deal with the start rule later.</p>
<p class="p7"><br></p>
<p class="p6">inherittest.js:</p>
<p class="p11"><br></p>
<p class="p10">eee</p>
<p class="p10">aaa</p>
<p class="p10">bbb</p>
<p class="p11"><br></p>
<p class="p6">inherit.ohm:</p>
<p class="p7"><br></p>
<p class="p10">Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Code = ChunkA ChunkB -- code</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkA = "aaa" Eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkB = "bbb" Eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>Eol = "\n"</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">Program2 &lt;: Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Main = ChunkE</p>
<p class="p10"><span class="Apple-converted-space">  </span>Code += ChunkE ChunkA ChunkB<span class="Apple-converted-space">  </span>-- code3</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkE = "eee" Eol*</p>
<p class="p10">}</p>
<p class="p7"><br></p>
<p class="p6">inherit.js:</p>
<p class="p7"><br></p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node inherit.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('inherit.ohm')</p>
<p class="p10">const grammarsNamespace = ohm.grammars(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('inherittest.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammarsNamespace.Program2.match(input)</p>
<p class="p10">// console.log(result)</p>
<p class="p10">// console.log(grammarsNamespace.Program2.trace(input).toString())</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p10">// const semantics = grammar.createSemantics()</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Overriding a Rule</b></h2>
<p class="p10"><span class="Apple-converted-space">  </span>Code := ChunkF ChunkA ChunkB</p>
<p class="p11"><br></p>
<p class="p6">Use the := operator instead of = (and +=).</p>
<p class="p11"><br></p>
<p class="p6">overridetest.js:</p>
<p class="p7"><br></p>
<p class="p10">fff</p>
<p class="p10">aaa</p>
<p class="p10">bbb</p>
<p class="p7"><br></p>
<p class="p6">override.ohm:</p>
<p class="p7"><br></p>
<p class="p10">Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Code = ChunkA ChunkB</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkA = "aaa" Eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkB = "bbb" Eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>Eol = "\n"</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">Program2 &lt;: Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Code := ChunkF ChunkA ChunkB</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkF = "fff" Eol*</p>
<p class="p10">}</p>
<p class="p7"><br></p>
<p class="p6">override.js:</p>
<p class="p7"><br></p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node inherit.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('override.ohm')</p>
<p class="p10">const grammarsNamespace = ohm.grammars(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('overridetest.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammarsNamespace.Program2.match(input)</p>
<p class="p10">// console.log(result)</p>
<p class="p10">// console.log(grammarsNamespace.Program2.trace(input).toString())</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Start Rule</b></h2>
<p class="p6">To start with a given rule, specify its name (as a String) in match().</p>
<p class="p7"><br></p>
<p class="p10">const result = grammarsNamespace.Program2.match(input, "StartTest")</p>
<p class="p7"><br></p>
<p class="p6">starttest.js:</p>
<p class="p11"><br></p>
<p class="p10">ggg</p>
<p class="p10">aaa</p>
<p class="p10">bbb</p>
<p class="p11"><br></p>
<p class="p6">start.ohm:</p>
<p class="p7"><br></p>
<p class="p10">Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Code = ChunkA ChunkB</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkA = "aaa" Eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkB = "bbb" Eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>Eol = "\n"</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">Program2 &lt;: Program {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Code := ChunkF ChunkA ChunkB</p>
<p class="p10"><span class="Apple-converted-space">  </span>StartTest = ChunkG ChunkA ChunkB</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkF = "fff" Eol*</p>
<p class="p10"><span class="Apple-converted-space">  </span>ChunkG = "ggg" Eol*</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6">start.js:</p>
<p class="p11"><br></p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node inherit.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('start.ohm')</p>
<p class="p10">const grammarsNamespace = ohm.grammars(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('starttest.js')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammarsNamespace.Program2.match(input, "StartTest")</p>
<p class="p10">// console.log(result)</p>
<p class="p10">// console.log(grammarsNamespace.Program2.trace(input).toString())</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>CST</b></h2>
<p class="p6">(Concrete Syntax Tree)</p>
<p class="p6">An experiment.<span class="Apple-converted-space">  </span>I fed a very simple grammar into Ohm, then used the JS debugger (node inspect junk.js) to dissect the results:</p>
<p class="p7"><br></p>
<p class="p6">dissect.scm:</p>
<p class="p7"><br></p>
<p class="p6">#t</p>
<p class="p7"><br></p>
<p class="p6">dissect.ohm:</p>
<p class="p11"><br></p>
<p class="p10">Scm2JSBasic {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Program = Form+</p>
<p class="p10"><span class="Apple-converted-space">  </span>Form = Atom</p>
<p class="p10"><span class="Apple-converted-space">  </span>Atom = SBoolean</p>
<p class="p10"><span class="Apple-converted-space">  </span>SBoolean = "#f" | "#t"</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6">dissect.js:</p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('dissect.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('dissect.scm')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const semantics = grammar.createSemantics()</p>
<p class="p10">const node_to_source = node =&gt; {</p>
<p class="p10"><span class="Apple-converted-space">    </span>if (node.ctorName == "_terminal") {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.primitiveValue</p>
<p class="p10"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p10"><span class="Apple-converted-space">        </span>return node.children.map(n =&gt; node_to_source(n)).join('')</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p10">semantics.addOperation(</p>
<p class="p10"><span class="Apple-converted-space">    </span>'dump',</p>
<p class="p10"><span class="Apple-converted-space">    </span>{</p>
<p class="p10"><span class="Apple-converted-space">        </span>Program: (p) =&gt; {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return node_to_source(p)</p>
<p class="p10"><span class="Apple-converted-space">        </span>}</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">)</p>
<p class="p11"><br></p>
<p class="p10">console.log(semantics(result).dump())</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">function astString(obj) { return obj.toString() }</p>
<p class="p11"><br></p>
<p class="p10">class Program {<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>constructor(p) { this.p = p }<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>astString () {<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span>console.log("&lt;" + this.constructor.name + "&gt;: " + this.p.constructor.name) ;<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span>return "P \n" + this.p.map((x) =&gt; x.astString()).join('\n')}}</p>
<p class="p10">class Form {<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>constructor(s) { this.s = s }<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>astString () {<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span>return "&lt;" + this.constructor.name + "&gt;:" + this.s.constructor.name + " " + "[" + this.s.astString().constructor.name + "] " + this.s.astString();}}</p>
<p class="p11"><br></p>
<p class="p10">class Atom { constructor(a) { this.a = a } astString() { return this.a.astString() }}</p>
<p class="p10">class SBoolean { constructor(b) { this.b = b } astString(){ return this.b }}</p>
<p class="p11"><br></p>
<p class="p10">// an operation that uses the above classes</p>
<p class="p10">semantics.addOperation(</p>
<p class="p10"><span class="Apple-converted-space">    </span>'ast',</p>
<p class="p10"><span class="Apple-converted-space">    </span>{</p>
<p class="p10"><span class="Apple-tab-span">	</span>Program: (p) =&gt; { return new Program(p.ast()) },</p>
<p class="p10"><span class="Apple-tab-span">	</span>Form: (s) =&gt; {<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>console.log("Form " + this.s );},</p>
<p class="p10"><span class="Apple-tab-span">	</span>Atom: (a) =&gt; {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>console.log("Atom a=" + a);},</p>
<p class="p10"><span class="Apple-tab-span">	</span>SBoolean: (b) =&gt; {<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>console.log("b is " + b._node.ctorName + " and b's ast is " + b.ast()) ; },</p>
<p class="p10"><span class="Apple-tab-span">	</span>_terminal: () =&gt; { console.log("primitive " + this.primitiveValue); return this.primitiveValue }</p>
<p class="p10"><span class="Apple-converted-space">    </span>}</p>
<p class="p10">)</p>
<p class="p11"><br></p>
<p class="p10">console.log()</p>
<p class="p10">console.log("result")</p>
<p class="p10">console.log(result)</p>
<p class="p10">console.log()</p>
<p class="p10">console.log("semantics")</p>
<p class="p10">var sem<span class="Apple-converted-space">  </span>= semantics(result)</p>
<p class="p10">var tree = sem.ast()</p>
<p class="p10">console.log()</p>
<p class="p10">console.log("tree")</p>
<p class="p10">console.log(tree)</p>
<p class="p11"><br></p>
<p class="p6">Fig. 1 shows this data in diagrammatic form (some parts elided).</p>
<p class="p7"><br></p>
<p class="p6"><img src="/assets/2020-12-09-15-13-04-Images/Ohm-data-structures.png" width="286px" height="291px" alt="Image"></p>
<p class="p6">Fig. 1 Overview of Ohm Parse Results</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Pipelining Grammars</b></h2>
<p class="p6">Ideally, I would want a grammar that inputs a string and produces a token stream which I could then feed into other grammars in a pipeline fashion.</p>
<p class="p7"><br></p>
<p class="p6">OMeta is able to run grammar pattern matchers on arbitrary input (e.g. strings and tokens).</p>
<p class="p7"><br></p>
<p class="p6">Ohm-JS cannot do this and works only with input strings (of characters).</p>
<p class="p7"><br></p>
<p class="p6">I can compromise and produce strings.<span class="Apple-converted-space">  </span>I'll ignore low-level efficiency for the moment and see that our idea works.<span class="Apple-converted-space">  </span>Later, I can switch to OMeta if needed.<span class="Apple-converted-space">  </span>It might turn out that everything works "fast enough" so, I might not need to switch to OMeta and keep our "dumb" implementation.</p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Lines and Filenames</b></h2>
<p class="p6">A token-based representation allows us to stick debugging information into each token.</p>
<p class="p7"><br></p>
<p class="p6">For example, when there's a syntax error, we might want to know the line &amp; character position of each character and which file it came from.</p>
<p class="p7"><br></p>
<p class="p6">For now, we can use a trick pioneered by C compilers - create <i>pragmas</i> for file and lines.<span class="Apple-converted-space">  </span>The pragmas are passed down the pipeline and, if an error occurs, the filename and line number of the erroneous input can be examined and displayed. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">In C, the file pragma appears as a single line with the contents '#file<a id="fnlink4"></a><a href="#fn4"><span class="s4"><sup>[4]</sup></span></a> "&lt;…&gt;"'.<span class="Apple-converted-space">  </span>The line pragma appears as a different pragma '#line nn<a id="fnlink5"></a><a href="#fn5"><span class="s4"><sup>[5]</sup></span></a>'.<span class="Apple-converted-space">  </span>The various passes in the pipeline record the pragmas but otherwise ignore them until an error occurs.</p>
<p class="p7"><br></p>
<p class="p6">Question: if the grammar is embedded as a script in HTML, what is the #file for it?</p>
<p class="p6">Answer: I don't know yet.<span class="Apple-converted-space">  </span>It will depend on the debugger.</p>
<p class="p7"><br></p>
<p class="p6">Question: if the grammar is embedded as a script in HTML, what is <i>nn</i> in the #line for it?<span class="Apple-converted-space">  </span>Is <i>nn</i> a line-offset within the script or is it a line-offset from the beginning of the HTML file?</p>
<p class="p6">Answer: I don't know yet.</p>
<p class="p7"><br></p>
<p class="p6">Question: if the grammar is embedded as a script in HTML, maybe #file and #line can be replaced by something else, like hidden HTML elements?<span class="Apple-converted-space">  </span>Is #file even useful in this context?</p>
<p class="p6">Answer: I don't know yet.</p>
<p class="p7"><br></p>
<p class="p6">TODO:</p>
<ol class="ol1">
  <li class="li2">I want to create a unity grammar that simply outputs what is input (probably stripping out comments).<span class="Apple-converted-space">  </span>This might give us ideas on how to proceed - DI<a id="fnlink6"></a><a href="#fn6"><span class="s4"><sup>[6]</sup></span></a> via <i>divide&amp;conquer</i> and <i>experimentation</i>.</li>
  <li class="li2">I want to create a semantics that inserts #line pragmas.</li>
  <li class="li2">I want to create a grammar that expands the ' (QUOTE) shorthand in Scheme to its full form (also Scheme, just harder for humans to read).</li>
</ol>
<p class="p5"><br></p>
<p class="p2">I will switch to using an index.html page for these experiments, instead of using node.js…</p>
<p class="p5"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Math Example in Browser</b></h2>
<p class="p12"><span class="s5">See <a href="https://github.com/harc/ohm/tree/master/examples/math"><span class="s6">https://github.com/harc/ohm/tree/master/examples/math</span></a></span><span class="s2">.</span></p>
<p class="p13"><span class="s2"></span><br></p>
<p class="p6">This example shows how to embed a grammar into a webpage and then process it using different sets of semantics.</p>
<p class="p7"><br></p>
<p class="p12"><span class="s5">The grammar and semantics can be found in <a href="https://github.com/harc/ohm/blob/master/examples/math/index.html"><span class="s6">https://github.com/harc/ohm/blob/master/examples/math/index.html</span></a></span><span class="s2">.</span></p>
<p class="p13"><span class="s2"></span><br></p>
<p class="p6">The grammar is embedded as a script with type="text/ohm-js".<span class="Apple-converted-space">  </span>This type distinguishes the Ohm-JS grammar from the other scripts and is read into variable "g" by line 63:</p>
<p class="p7"><br></p>
<p class="p10">var g = ohm.grammarFromScriptElement();</p>
<p class="p11"><br></p>
<p class="p6">The actual matching (g.match(…)) of the grammar against some input (string) is done in input.oninput (line 456).</p>
<p class="p7"><br></p>
<p class="p6">A semantics dictionary is created in line 136:</p>
<p class="p7"><br></p>
<p class="p10">var s = g.createSemantics();</p>
<p class="p11"><br></p>
<p class="p6">Semantic actions are created by the "s.addOperation" and "s.addAttribute" functions.</p>
<p class="p7"><br></p>
<p class="p6">AddOperation is called to create 3 sets of semantics: 'interpret', 'toTree' and 'toTwoD'.</p>
<p class="p7"><br></p>
<p class="p6">AddAttribute is called to create a 4<span class="s7"><sup>th</sup></span> semantics names 'asLisp'.</p>
<p class="p7"><br></p>
<p class="p6">AddOperation and addAttribute are almost the same, except that the latter (addAttribute) creates properties (not methods) and is memoized (an optimization that reduces the cost of backtracking during the pattern match).</p>
<p class="p7"><br></p>
<p class="p6">'Interpret' returns a JS value, 'asLisp' returns a JS list (arrays of arrays), 'toTree' and 'toTwoD' return trees of HTML elements.<a id="fnlink7"></a><a href="#fn7"><span class="s4"><sup>[7]</sup></span></a></p>
<p class="p7"><br></p>
<p class="p6">The function 'input.oninput' (line 456) calls "show" (../lib.js) for each of the semantics. <span class="Apple-converted-space">  </span>The 'interpret' semantics returns a JS value which creates a string <i>div.<span class="Apple-converted-space"> </span></i> The 'asLisp' semantics returns a JS tree which is processed by the stringifyLisp function and creates a string <i>div</i>.<span class="Apple-converted-space">  </span>The semantic functions 'tree' and 'twoD' return trees of HTML elements.<span class="Apple-converted-space">  </span>The file math.css creates visualization styles for the elements which result in the final appearance of the elements as a parse tree and as 2D mathematical notation (factions shown as numerators and denominators).</p>
<p class="p7"><br></p>
<p class="p6">The "show()" function simply appends the elements to the various divs (value, lisp, tree, twoD) and the browser displays the divs.<span class="Apple-converted-space">  </span>The "show()" function also clears the top-level divs, allowing the display to be iterated.<span class="Apple-converted-space">  </span>The CSS file (math.css) does most of the real work - by arranging that #tree elements have a visible bottom border, etc.<span class="Apple-converted-space"> </span></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Ohm and PROLOG</b></h2>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Introduction</b></h2>
<p class="p6">PROLOG is just an exhaustive pattern matcher.</p>
<p class="p7"><br></p>
<p class="p6">PROLOG uses backtracking to exhaustively explore a search space.</p>
<p class="p7"><br></p>
<p class="p6">One could implement backtracking pattern matching with loops of loops, but the result quickly becomes unmaintainable and defies DI (expression of Design Intent), by overwhelming the code-reader with details.</p>
<p class="p7"><br></p>
<p class="p6">Once one splits the <i>expression</i> of backtracking pattern matching away from the details, one can begin to <i>think</i> in terms of relations.<span class="Apple-converted-space">  </span>PROLOG was an early attempt to make this split<a id="fnlink8"></a><a href="#fn8"><span class="s4"><sup>[8]</sup></span></a>.</p>
<p class="p7"><br></p>
<p class="p6">I don't know of a PROLOG library for JS.<span class="Apple-converted-space">  </span>Maybe one exists<a id="fnlink9"></a><a href="#fn9"><span class="s4"><sup>[9]</sup></span></a>, but that's not my point, here.<span class="Apple-converted-space">  </span>My point is to show that one can bolt high-falutin' technologies into JS by using parsers.</p>
<p class="p7"><br></p>
<p class="p6">The easiest-to-understand description of PROLOG (IMO) is Nils Holm's<a id="fnlink10"></a><a href="#fn10"><span class="s4"><sup>[10]</sup></span></a> PROLOG in Scheme.</p>
<p class="p7"><br></p>
<p class="p6">Can I steal that code?<span class="Apple-converted-space">  </span>It is written in Scheme and I want JS.<span class="Apple-converted-space">  </span>Oh wait, Scheme has a super-simple syntax.<span class="Apple-converted-space">  </span>Maybe I can use an Ohm-based parser to convert the Scheme code into JS, then build an Ohm-based parser that gives us PROLOG syntax?<span class="Apple-converted-space"> </span></p>
<p class="p6">The experiment begins…</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>PROLOG CONTROL in 6 SLIDES</b></h2>
<p class="p6"><a href="https://www.t3x.org/bits/prolog6.html">https://www.t3x.org/bits/prolog6.html</a></p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Ohm and Scheme</b></h2>
<p class="p7"><span class="Apple-converted-space"> </span></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Basic Scheme Parser</b></h2>
<p class="p6">The fundamental data type of Scheme is the SEXP (s-expression).</p>
<p class="p7"><br></p>
<p class="p6">A SEXP is either an atom or a list.<span class="Apple-converted-space">  </span>A list can contain atoms and other lists.</p>
<p class="p7"><br></p>
<p class="p6">If I get the basics right, I could use Ohm's grammar inheritance to build bigger grammars.</p>
<p class="p7"><br></p>
<p class="p6">I don't expect to get that grammar right on the first pass.<span class="Apple-converted-space">  </span>Divide and Conquer.<span class="Apple-converted-space">  </span>I try out bits of ideas first, then, modify the bits to suit the bigger picture.</p>
<p class="p7"><br></p>
<p class="p6">My first attempt at a basic parser for SEXPs:</p>
<p class="p7"><br></p>
<p class="p6">Scm2jsbasic1.ohm:</p>
<p class="p11"><br></p>
<p class="p10">Scm2JSBasic {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Scm = List | Atom |<span class="Apple-converted-space">  </span>Boolean</p>
<p class="p10"><span class="Apple-converted-space">  </span>List = <span class="Apple-converted-space">  </span>"(" ListInnards ")"</p>
<p class="p10"><span class="Apple-converted-space">  </span>ListInnards = (Atom | List)*</p>
<p class="p10"><span class="Apple-converted-space">  </span>Atom = Integer | Symbol | Boolean</p>
<p class="p10"><span class="Apple-converted-space">  </span>Boolean = "#f" | "#t"</p>
<p class="p10"><span class="Apple-converted-space">  </span>Integer = Numchar+</p>
<p class="p10"><span class="Apple-converted-space">  </span>Numchar = "0".."9"</p>
<p class="p10"><span class="Apple-converted-space">  </span>Symbol = Letchar (Letchar | Numchar | "?" | "_")*</p>
<p class="p10"><span class="Apple-converted-space">  </span>Letchar = LC | UC | "+" | "*"</p>
<p class="p10"><span class="Apple-converted-space">  </span>LC = "a".."z"</p>
<p class="p10"><span class="Apple-converted-space">  </span>UC = "A".."Z"</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6">I can already see that I'm going to be replacing Letchar with something more interesting…</p>
<p class="p7"><br></p>
<p class="p6">Hmm, maybe the whole definition of "symbol" needs to be replaced…</p>
<p class="p7"><br></p>
<p class="p6">Just to be clear - I am <i>not</i> trying to parse all of Scheme, only enough to parse Nils' PROLOG code.<span class="Apple-converted-space">  </span>This will be a single-use DSL…</p>
<p class="p7"><br></p>
<p class="p6">Engineering trade-off - I don't need to do everything (the last 5% of details always kill).<span class="Apple-converted-space">  </span>YAGNI.<span class="Apple-converted-space">  </span>I hope to transpile Nils' Scheme code to JS, then let the JS compiler do the heavy lifting.</p>
<p class="p7"><br></p>
<p class="p6">I'm planning to use the Ohm-js parser as a fancy editor…. Think of Ohm-JS as "sed" on steroids.</p>
<p class="p7"><br></p>
<p class="p6">Next step - pour all of Nils' code into the test, fix what doesn't parse…</p>
<p class="p7"><br></p>
<p class="p6">scm2jsbasictest1.scm:</p>
<p class="p11"><br></p>
<p class="p10">(null? xyz)</p>
<p class="p11"><br></p>
<p class="p6">scm2jsbasic1.js:</p>
<p class="p11"><br></p>
<p class="p10">// usage:</p>
<p class="p10">// npm install ohm-js</p>
<p class="p10">// node scm2jsbasic1.js</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('scm2jsbasic1.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('scm2jstest1.scm')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Inherit the Basic Parser</b></h2>
<p class="p6">Let's try to inherit the basic scheme parser.</p>
<p class="p7"><br></p>
<p class="p6">I think that I'm going to need to revisit that basic parser many times. I'm going to iterate on the basic definition as I build up more interesting parsers.</p>
<p class="p7"><br></p>
<p class="p6">This is <i>anti-waterfall</i> thinking.<span class="Apple-converted-space">  </span>Beginning with the belief that one doesn't know where this is going to go.</p>
<p class="p7"><br></p>
<p class="p6"><i>Waterfall</i> design would be the idea that I can get the basic grammar (and all subsequent layers) right without iterating the code.</p>
<p class="p7"><br></p>
<p class="p6"><span class="s1">Programmers</span> <span class="s1">like</span> languages that have REPLs (Read-Eval Print Loop) because it helps them iterate.<span class="Apple-converted-space">  </span>This is one form of "design".</p>
<p class="p7"><br></p>
<p class="p6"><span class="s1">Maintainers</span> <span class="s1">don't lik</span>e REPLs, but that's another whole branch of Software Engineering…</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Basic Scheme Version #2</b></h2>
<p class="p6">Add ! as a valid identifier (first &amp; follow) character.</p>
<p class="p7"><br></p>
<p class="p6">Add "-" as a valid identifier (follow) character.</p>
<p class="p7"><br></p>
<p class="p6">Move "-", "_", "!", "?" to first (&amp; follow) character sets.</p>
<p class="p7"><br></p>
<p class="p6">Add Strings (stunted, no escapes yet).</p>
<p class="p7"><br></p>
<p class="p6">Add comments as whitespace.</p>
<p class="p7"><br></p>
<p class="p6">Add () as a valid atom (NullList) and make List use + instead of * (looking ahead to future conversion simplicity).</p>
<p class="p7"><br></p>
<p class="p6">Add ' recognizer.<span class="Apple-converted-space">  </span>(Single quote).<span class="Apple-converted-space">  </span>Single quote is a convenience operator that expands into a QUOTE form.<span class="Apple-converted-space">  </span>E.G. "'(a b c)" =&gt; "(quote (a b c))".<span class="Apple-converted-space">  </span>In this step, I deal only with the parse. <span class="Apple-converted-space">  </span>I will re-write QUOTE later…</p>
<p class="p7"><br></p>
<p class="p6">Scheme macros use "`" (back quote) to start a macro.<span class="Apple-converted-space">  </span>Inside a macro, quoting is "reversed" - everything is quoted unless it is preceded by a comma ",".<span class="Apple-converted-space">  </span>There are more features, but I am striving only to recognize prolog-6.scm…. YAGNI<a id="fnlink11"></a><a href="#fn11"><span class="s4"><sup>[11]</sup></span></a>.</p>
<p class="p7"><br></p>
<p class="p6">Add ` recognizer.<span class="Apple-converted-space">  </span>(Back quote, back tick)</p>
<p class="p7"><br></p>
<p class="p6">Add , recognizer.</p>
<p class="p7"><br></p>
<p class="p6">Allow for multiple lists in a file.</p>
<p class="p7"><br></p>
<p class="p6">Lists are made up of cons cells.<span class="Apple-converted-space">  </span>A cons cell is a 2-tuple: {pointer to data, pointer to next cell}.<span class="Apple-converted-space">  </span>In most "normal" lists, the final "pointer to the next cell" is NIL (i.e. no next cell).<span class="Apple-converted-space">  </span>As a convenience, the printer prints such lists in the most common notation - openParen, items, closeParen (e.g. "(a b c)").<span class="Apple-converted-space">  </span>In some cases, lists end with a datum instead of NIL, and, in those cases the list prints as: openParen, items, dot, last item, closeParen (e.g. "(a b . c)").<span class="Apple-converted-space">  </span><span class="s1">All</span> lists are the same - they are made up of cons cells - it is <i>only </i>the <span class="s1">printer</span> that shows lists in shorthand notation, where the most common lists are null-terminated lists.</p>
<p class="p7"><br></p>
<p class="p6">sm2jstest2.scm (not a practical piece of code, just a test case):</p>
<p class="p11"><br></p>
<p class="p10">(define (clear_r x)</p>
<p class="p10"><span class="Apple-converted-space">  </span>(set-car! (cddr x) '(()))</p>
<p class="p10"><span class="Apple-converted-space">  </span>(append (cdr a) `(r! ,l) (cdr g)))</p>
<p class="p11"><br></p>
<p class="p10">(define (clear_r x)</p>
<p class="p10"><span class="Apple-converted-space">  </span>(set-car! (cddr x) '(()))</p>
<p class="p10"><span class="Apple-converted-space">  </span>(append (cdr a) `(r! ,l) (cdr g)))</p>
<p class="p11"><br></p>
<p class="p10">(a b . c)</p>
<p class="p10">((a b . c))</p>
<p class="p11"><br></p>
<p class="p6">scm2jsbasic2.ohm:</p>
<p class="p11"><br></p>
<p class="p10">Scm2JSBasic {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Program = Scm+</p>
<p class="p10"><span class="Apple-converted-space">  </span>Scm = List | Atom |<span class="Apple-converted-space">  </span>Boolean</p>
<p class="p10"><span class="Apple-converted-space">  </span>QuotedSexp = "'" Scm</p>
<p class="p10"><span class="Apple-converted-space">  </span>BackQuotedSexp = "`" Scm</p>
<p class="p10"><span class="Apple-converted-space">  </span>CommaSexp = "," Scm</p>
<p class="p10"><span class="Apple-converted-space">  </span>List = DottedList | NullTerminatedList</p>
<p class="p10"><span class="Apple-converted-space">  </span>DottedList = "(" ListItem+ "." ListItem ")"</p>
<p class="p10"><span class="Apple-converted-space">  </span>NullTerminatedList = <span class="Apple-converted-space">  </span>"(" ListItem+ ")"</p>
<p class="p10"><span class="Apple-converted-space">  </span>ListItem = (Atom | List)</p>
<p class="p10"><span class="Apple-converted-space">  </span>Atom = Integer | Symbol | String | Boolean | NullList | QuotedSexp | BackQuotedSexp | CommaSexp</p>
<p class="p10"><span class="Apple-converted-space">  </span>NullList = "(" ")"</p>
<p class="p10"><span class="Apple-converted-space">  </span>Boolean = "#f" | "#t"</p>
<p class="p10"><span class="Apple-converted-space">  </span>Integer = Numchar+</p>
<p class="p10"><span class="Apple-converted-space">  </span>Numchar = "0".."9"</p>
<p class="p10"><span class="Apple-converted-space">  </span>String = "\"" (~"\"" any)+ "\""</p>
<p class="p10"><span class="Apple-converted-space">  </span>Symbol = Letchar (Letchar | Numchar)*</p>
<p class="p10"><span class="Apple-converted-space">  </span>Letchar = LC | UC | "+" | "*" | "!" | "?"<span class="Apple-converted-space">  </span>| "_" | "-"</p>
<p class="p10"><span class="Apple-converted-space">  </span>LC = "a".."z"</p>
<p class="p10"><span class="Apple-converted-space">  </span>UC = "A".."Z"</p>
<p class="p10"><span class="Apple-converted-space">  </span>semiColonComment = ";" (~"\n" any)* "\n"</p>
<p class="p10"><span class="Apple-converted-space">  </span>space += semiColonComment</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6">scm2jsbasic2.js:</p>
<p class="p11"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('scm2jsbasic2.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('scm2jstest2.scm')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p10">// console.log(grammar.trace(input).toString())</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Basic Scheme vs prolog-6.scm</b></h2>
<p class="p6">Try the whole enchilada.</p>
<p class="p7"><br></p>
<p class="p6">test:</p>
<p class="p14"><span class="s8">see prolog-6.scm <a href="https://www.t3x.org/bits/prolog6.html"><span class="s6">https://www.t3x.org/bits/prolog6.html</span></a></span></p>
<p class="p15"><span class="s2"></span><br></p>
<p class="p14"><span class="s2">ohm grammar:</span></p>
<p class="p14"><span class="s2">see Basic Scheme Version #2</span></p>
<p class="p15"><span class="s2"></span><br></p>
<p class="p14"><span class="s2">scm3jsbasic3.js:</span></p>
<p class="p15"><span class="s2"></span><br></p>
<p class="p16">const fs = require ('fs')</p>
<p class="p16">const ohm = require ('ohm-js')</p>
<p class="p16">const grammarData = fs.readFileSync('scm2jsbasic2.ohm')</p>
<p class="p16">const grammar = ohm.grammar(grammarData)</p>
<p class="p17"><br></p>
<p class="p16">const input = fs.readFileSync('prolog-6.scm')</p>
<p class="p17"><br></p>
<p class="p16">const result = grammar.match(input)</p>
<p class="p16">//console.log(grammar.trace(input).toString())</p>
<p class="p17"><br></p>
<p class="p16">if (result.succeeded()) {</p>
<p class="p16"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p16">} else {</p>
<p class="p16"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p16">}</p>
<p class="p17"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Lisp is Assembly Language</b></h2>
<p class="p6">Lisp makes a wonderful assembly language - it does just about everything.<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">Programs can be built in multiple paradigms and, Lisp has no syntax to get in the way.</p>
<p class="p7"><br></p>
<p class="p6">Scheme is a stripped-down Lisp.<span class="Apple-converted-space">  </span>CL (Common Lisp) is a production tool.</p>
<p class="p7"><br></p>
<p class="p6">I think that Lisp should form the basis of most languages and most projectional editors, but, I digress.</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Basic Scheme to JS</b></h2>
<p class="p6">I will settle on scm2jsbasic2.ohm and call it scm2js.ohm.</p>
<p class="p7"><br></p>
<p class="p6">Likewise scm2js.js.</p>
<p class="p7"><br></p>
<p class="p6">test:</p>
<p class="p6">prolog-6.scm</p>
<p class="p7"><br></p>
<p class="p6">scm2js.ohm:</p>
<p class="p7"><br></p>
<p class="p10">Scm2JSBasic {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Program = Scm+</p>
<p class="p10"><span class="Apple-converted-space">  </span>Scm = List | Atom |<span class="Apple-converted-space">  </span>Boolean</p>
<p class="p10"><span class="Apple-converted-space">  </span>QuotedSexp = "'" Scm</p>
<p class="p10"><span class="Apple-converted-space">  </span>BackQuotedSexp = "`" Scm</p>
<p class="p10"><span class="Apple-converted-space">  </span>CommaSexp = "," Scm</p>
<p class="p10"><span class="Apple-converted-space">  </span>List = DottedList | NullTerminatedList</p>
<p class="p10"><span class="Apple-converted-space">  </span>DottedList = "(" ListItem+ "." ListItem ")"</p>
<p class="p10"><span class="Apple-converted-space">  </span>NullTerminatedList = <span class="Apple-converted-space">  </span>"(" ListItem+ ")"</p>
<p class="p10"><span class="Apple-converted-space">  </span>ListItem = (Atom | List)</p>
<p class="p10"><span class="Apple-converted-space">  </span>Atom = Integer | Symbol | String | Boolean | NullList | QuotedSexp | BackQuotedSexp | CommaSexp</p>
<p class="p10"><span class="Apple-converted-space">  </span>NullList = "(" ")"</p>
<p class="p10"><span class="Apple-converted-space">  </span>Boolean = "#f" | "#t"</p>
<p class="p10"><span class="Apple-converted-space">  </span>Integer = Numchar+</p>
<p class="p10"><span class="Apple-converted-space">  </span>Numchar = "0".."9"</p>
<p class="p10"><span class="Apple-converted-space">  </span>String = "\"" (~"\"" any)+ "\""</p>
<p class="p10"><span class="Apple-converted-space">  </span>Symbol = Letchar (Letchar | Numchar)*</p>
<p class="p10"><span class="Apple-converted-space">  </span>Letchar = LC | UC | "+" | "*" | "!" | "?"<span class="Apple-converted-space">  </span>| "_" | "-"</p>
<p class="p10"><span class="Apple-converted-space">  </span>LC = "a".."z"</p>
<p class="p10"><span class="Apple-converted-space">  </span>UC = "A".."Z"</p>
<p class="p10"><span class="Apple-converted-space">  </span>semiColonComment = ";" (~"\n" any)* "\n"</p>
<p class="p10"><span class="Apple-converted-space">  </span>space += semiColonComment</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<p class="p6">scm2js.js:</p>
<p class="p7"><br></p>
<p class="p10">const fs = require ('fs')</p>
<p class="p10">const ohm = require ('ohm-js')</p>
<p class="p10">const grammarData = fs.readFileSync('scm2jsbasic.ohm')</p>
<p class="p10">const grammar = ohm.grammar(grammarData)</p>
<p class="p11"><br></p>
<p class="p10">const input = fs.readFileSync('prolog-6.scm')</p>
<p class="p11"><br></p>
<p class="p10">const result = grammar.match(input)</p>
<p class="p10">// console.log(grammar.trace(input).toString())</p>
<p class="p11"><br></p>
<p class="p10">if (result.succeeded()) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Succeeded")</p>
<p class="p10">} else {</p>
<p class="p10"><span class="Apple-converted-space">    </span>console.log("Matching Failed")</p>
<p class="p10">}</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Unity Parser</b></h2>
<p class="p6">The first step towards pipelining grammars is to create a unity parser. The Unity parser contains a grammar plus an unparser. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">The grammar I need is the bare minimum to parse prolog-6.scm.<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">The unparser simply walks the CST (Concrete Syntax Tree) and re-emits the sub-trees as needed.</p>
<p class="p7"><br></p>
<p class="p6">Spaces and comments are dumped by the parser, so they don't appear in the CST and are not re-emitted.</p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p6">This exercise showed a deficiency in the original Scm2JSBasic grammar.<span class="Apple-converted-space">  </span>The grammar, as written, was slurping adjacent symbols and making them into single symbols.<span class="Apple-converted-space">  </span>The original grammar ignored spaces, including those that separated adjacent symbols.</p>
<p class="p7"><br></p>
<p class="p6">The original grammar was written using syntactic rules everywhere.</p>
<p class="p7"><br></p>
<p class="p6">The fix was to rewrite the grammar using lexical rules for the low-level recognizers.</p>
<p class="p7"><br></p>
<p class="p6">I, also, switched from using node.js to using HTML for the grammar.</p>
<p class="p7"><br></p>
<p class="p6">The result is in index.html.<span class="Apple-converted-space">  </span>(See commit 2e40532e25e63f4d3be1f8f37b18d37df266970d).</p>
<p class="p7"><br></p>
<p class="p6">index.html: (less prolog-6.scm code):</p>
<p class="p7"><br></p>
<p class="p10">&lt;!doctype html&gt;</p>
<p class="p10">&lt;html&gt;</p>
<p class="p10"><span class="Apple-converted-space">  </span>&lt;head&gt;</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;title&gt;ohm/js in small steps&lt;/title&gt;</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;meta charset=utf-8&gt;</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script src="/Users/tarvydas/projects/ohm/examples/lib.js"&gt;&lt;/script&gt;</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script src="/Users/tarvydas/projects/ohm/dist/ohm.js"&gt;&lt;/script&gt;</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script type="text/ohm-js"&gt;</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">      </span>// An Ohm grammar for Scheme, step 1.</p>
<p class="p10">Scm2JSBasic {</p>
<p class="p10"><span class="Apple-converted-space">  </span>Program = Form+</p>
<p class="p10"><span class="Apple-converted-space">  </span>Form = SList | Atom</p>
<p class="p10"><span class="Apple-converted-space">  </span>QuotedSexp = "'" Form</p>
<p class="p10"><span class="Apple-converted-space">  </span>BackQuotedSexp = "`" Form</p>
<p class="p10"><span class="Apple-converted-space">  </span>CommaSexp = "," Form</p>
<p class="p10"><span class="Apple-converted-space">  </span>SList = DottedList | NullTerminatedList</p>
<p class="p10"><span class="Apple-converted-space">  </span>DottedList = "(" ListItem+ "." ListItem ")"</p>
<p class="p10"><span class="Apple-converted-space">  </span>NullTerminatedList = <span class="Apple-converted-space">  </span>"(" ListItem+ ")"</p>
<p class="p10"><span class="Apple-converted-space">  </span>ListItem = (Atom | SList)</p>
<p class="p10"><span class="Apple-converted-space">  </span>Atom = lexical_atom | Syntactic_Atom</p>
<p class="p10"><span class="Apple-converted-space">  </span>Syntactic_Atom = QuotedSexp | BackQuotedSexp | CommaSexp</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">  </span>lexical_atom = lexical_integer | lexical_symbol | lexical_string | lexical_boolean | lexical_nullList</p>
<p class="p10"><span class="Apple-converted-space">  </span>lexical_nullList = "(" ")"</p>
<p class="p10"><span class="Apple-converted-space">  </span>lexical_boolean = "#f" | "#t"</p>
<p class="p10"><span class="Apple-converted-space">  </span>lexical_integer = lexical_numchar+</p>
<p class="p10"><span class="Apple-converted-space">  </span>lexical_numchar = "0".."9"</p>
<p class="p10"><span class="Apple-converted-space">  </span>lexical_string = "\"" (~"\"" any)+ "\""</p>
<p class="p10"><span class="Apple-converted-space">  </span>lexical_symbol = lexical_letchar (lexical_letchar | lexical_numchar)*</p>
<p class="p10"><span class="Apple-converted-space">  </span>lexical_letchar = lexical_lc | lexical_uc | "+" | "*" | "!" | "?"<span class="Apple-converted-space">  </span>| "_" | "-"</p>
<p class="p10"><span class="Apple-converted-space">  </span>lexical_lc = "a".."z"</p>
<p class="p10"><span class="Apple-converted-space">  </span>lexical_uc = "A".."Z"</p>
<p class="p10"><span class="Apple-converted-space">  </span>semiColonComment = ";" (~"\n" any)* "\n"</p>
<p class="p10"><span class="Apple-converted-space">  </span>space += semiColonComment</p>
<p class="p10">}</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script&gt;</p>
<p class="p10"><span class="Apple-converted-space">      </span>var g = ohm.grammarFromScriptElement();</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script type="text/test"&gt;</p>
<p class="p10"><span class="Apple-converted-space">      </span>(#t #f)</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><span class="Apple-converted-space">    </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script type="text/test"&gt;</p>
<p class="p10"><span class="Apple-converted-space">      </span>( #t #f . #t)</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><span class="Apple-converted-space">    </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script type="text/test"&gt;</p>
<p class="p10"><span class="Apple-converted-space">      </span>( . #t)</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><span class="Apple-converted-space">    </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script type="text/test"&gt;</p>
<p class="p10"><span class="Apple-converted-space">      </span>asymbol</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><span class="Apple-converted-space">    </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script type="text/test"&gt;</p>
<p class="p10"><span class="Apple-converted-space">      </span>(asymbol)</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script type="text/test"&gt;</p>
<p class="p10"><span class="Apple-converted-space">      </span>(asymbol1 asymbol2)</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script type="text/test"&gt;</p>
<p class="p10"><span class="Apple-converted-space">      </span>(asymbol1 asymbol2)</p>
<p class="p10"><span class="Apple-converted-space">      </span>(asymbol3 asymbol4)</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script type="text/test"&gt;</p>
<p class="p10">… code for prolog-6.scm …</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script&gt;</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">      </span>var sem = g.createSemantics();</p>
<p class="p11"><span class="Apple-converted-space">      </span></p>
<p class="p10"><span class="Apple-converted-space">      </span>function toListOfStrings(a) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>return a.join(' ');</p>
<p class="p10"><span class="Apple-converted-space">      </span>}</p>
<p class="p11"><span class="Apple-converted-space">      </span></p>
<p class="p10"><span class="Apple-converted-space">      </span>function toPackedString(a) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>return a.join('');</p>
<p class="p10"><span class="Apple-converted-space">      </span>}</p>
<p class="p11"><span class="Apple-converted-space">      </span></p>
<p class="p10"><span class="Apple-converted-space">      </span>sem.addOperation(</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>'unity',</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>{</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>Program: function(tree) {return toListOfStrings(tree.unity())},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>Form: function(item) {return item.unity()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>QuotedSexp: function(_, form) {return "'" + form.unity()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>BackQuotedSexp: function(_, form) {return "`" + form.unity()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>CommaSexp: function(_, form) {return "," + form.unity()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>SList: function(lis) {return lis.unity()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>DottedList: function(_lp, items, _dot, lastItem, _rp) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>return "(" + toListOfStrings(items.unity()) + " . " + lastItem.unity() + ")"},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>NullTerminatedList: function(_lp, items, _rp) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>return "(" + toListOfStrings(items.unity()) + ")"},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>ListItem: function(item) {return item.unity()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>Atom: function(a) {return a.unity()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_integer: function(ns) {return toPackedString(ns.unity());},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_symbol: function(c, cs) {return c.unity() + toPackedString(cs.unity());},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unity()) + "\""},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_letchar: function(c) {return c.unity()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_numchar: function(c) {return c.unity()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_lc: function(c) {return c.unity()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_uc: function(c) {return c.unity()},</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_nullList: function(_lp,_rp) {return "()"},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_boolean: function(b) {return this.sourceString},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>_terminal: function() { return this.primitiveValue; }</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>}</p>
<p class="p10"><span class="Apple-converted-space">      </span>);</p>
<p class="p11"><span class="Apple-converted-space">      </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script&gt;</p>
<p class="p10"><span class="Apple-converted-space">      </span>var tests = document.querySelectorAll('script[type="text/test"]');</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">  </span>&lt;/head&gt;</p>
<p class="p10"><span class="Apple-converted-space">  </span>&lt;body&gt;</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;button onclick="ohmtest()"&gt;Click me&lt;/button&gt;</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;p id="timestamp"&gt;&lt;/p&gt;</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;p id="input"&gt;&lt;/p&gt;</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;p id="output"&gt;&lt;/p&gt;</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;script&gt;</p>
<p class="p10"><span class="Apple-converted-space">      </span>var resultsString = '';</p>
<p class="p11"><span class="Apple-converted-space">      </span></p>
<p class="p10"><span class="Apple-converted-space">      </span>function displayDate () {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>document.getElementById('timestamp').innerHTML = Date();</p>
<p class="p10"><span class="Apple-converted-space">      </span>}</p>
<p class="p10"><span class="Apple-converted-space">      </span>function do1Test(testElement) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>var testString = testElement.innerHTML;</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>var r = g.match(testString);</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>var tail = "...";</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>var charsToDisplay = 40;</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>if (testString.length &lt; charsToDisplay) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>tail = "";</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>}</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>resultsString = resultsString + "&lt;br&gt;" + r.toString() + " " + testString.substring(0,charsToDisplay) + tail + (r.succeeded() ? (" &lt;--- " + sem(r).unity()) : '');</p>
<p class="p10"><span class="Apple-converted-space">      </span>}</p>
<p class="p10"><span class="Apple-converted-space">      </span>function displayTestResults(s) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>document.getElementById('input').innerHTML = s;</p>
<p class="p10"><span class="Apple-converted-space">      </span>}</p>
<p class="p10"><span class="Apple-converted-space">      </span>function ohmtest () {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>resultsString = '';</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>console.log(tests);</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>console.log(tests[0]);</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>tests.forEach(do1Test);</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>displayTestResults(resultsString);</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>displayDate();</p>
<p class="p10"><span class="Apple-converted-space">      </span>}</p>
<p class="p10"><span class="Apple-converted-space">      </span>ohmtest();</p>
<p class="p10"><span class="Apple-converted-space">    </span>&lt;/script&gt;</p>
<p class="p10"><span class="Apple-converted-space">  </span>&lt;/body&gt;</p>
<p class="p10">&lt;/html&gt;</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Expanding Quotes</b></h2>
<p class="p6">In Lisp, "quote" is used so often that it has been given a shortcut, consisting of a single quote.</p>
<p class="p7"><br></p>
<p class="p6">A quoted symbol,<span class="s9"> 'a</span> is internally expanded into <span class="s9">(quote a)</span> and, <span class="s9">('(a b))</span> is internally expanded into <span class="s9">((quote (a b)))</span>.</p>
<p class="p7"><br></p>
<p class="p6">Unquote is simple to implement as a tweak of the Unity parser:</p>
<p class="p6">(See commit f2105736ed1fb19b582986c4e8c2ba588c118eb8) <i>[this code has a bug - see later]</i></p>
<p class="p7"><br></p>
<p class="p10"><span class="Apple-converted-space">          </span>sem.addOperation(</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>'unquote',</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>{</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>Program: function(tree) {return toListOfStrings(tree.unquote())},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>Form: function(item) {return item.unquote()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>QuotedSexp: function(_, form) {return "(quote " + form.unquote() + ")"},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>BackQuotedSexp: function(_, form) {return "`" + form.unquote()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>CommaSexp: function(_, form) {return "," + form.unquote()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>SList: function(lis) {return lis.unquote()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>DottedList: function(_lp, items, _dot, lastItem, _rp) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>return "(" + toListOfStrings(items.unquote()) + " . " + lastItem.unquote() + ")"},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>NullTerminatedList: function(_lp, items, _rp) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>return "(" + toListOfStrings(items.unquote()) + ")"},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>ListItem: function(item) {return item.unquote()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>Atom: function(a) {return a.unquote()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_integer: function(ns) {return toPackedString(ns.unquote());},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_symbol: function(c, cs) {return c.unquote() + toPackedString(cs.unquote());},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unquote()) + "\""},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_letchar: function(c) {return c.unquote()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_numchar: function(c) {return c.unquote()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_lc: function(c) {return c.unquote()},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_uc: function(c) {return c.unquote()},</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_nullList: function(_lp,_rp) {return "()"},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>lexical_boolean: function(b) {return this.sourceString},</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">      </span>_terminal: function() { return this.primitiveValue; }</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>}</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Expanding Backquotes</b></h2>
<p class="p6">In Common Lisp (and Scheme), backquote is used as a shorthand to create lists.</p>
<p class="p6">Backquote evolved as a way to create programs that create programs.<span class="Apple-converted-space">  </span>In Lisp, programs are lists, so programs that create programs are just programs that create and modify lists.</p>
<p class="p6">In Lisp, the function "(LIST …)" creates a list containing all of its arguments.<span class="Apple-converted-space">  </span>In Lisp, all arguments are evaluated before being passed to a function.</p>
<p class="p6">In creating programs that create programs, using Lisp, one of the often-used idioms was a call to the function LIST with arguments that are quoted and with only <i>some</i> of the arguments that are evaluated.</p>
<p class="p6">This idiom occurred so frequently, that a shorthand was invented - the backquote.</p>
<p class="p7"><span class="Apple-converted-space"> </span></p>
<p class="p6">Backquote is a kind of an inverted QUOTE. <span class="Apple-converted-space"> </span></p>
<p class="p6">Inside a backquoted form, an unquoted sexp is quoted and a form preceded by a comma is not quoted (it is eval'ed in the usual manner). <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">For example <span class="s9">(LIST (QUOTE A)<span class="Apple-converted-space">  </span>(QUOTE B) (QUOTE C)) </span>is written in shorthand as <span class="s9">`(A B C)</span>, and,<span class="Apple-converted-space">  </span><span class="s9">(LIST (QUOTE A) B (QUOTE C))</span> is written in shorthand as <span class="s9">`(A ,B C)</span>.<span class="Apple-converted-space">  </span>Note that, in this latter case, B is evaluated but A and C are quoted.<span class="Apple-converted-space">  </span>A list of 3 values is created.<a id="fnlink12"></a><a href="#fn12"><span class="s4"><sup>[12]</sup></span></a><span class="Apple-converted-space">  </span>Clearly, <span class="s9">`(A ,B C)</span> is more expressive, and easier to write and read, than <span class="s9">(LIST (QUOTE A) B (QUOTE C))</span>, if you know the shorthand.</p>
<p class="p7"><br></p>
<p class="p6">The following examples form some of the tests I use for the backquote expander:</p>
<p class="p7"><br></p>
<p class="p10">`a —&gt; (quote a)</p>
<p class="p10">`,a —&gt; a</p>
<p class="p10">`(a) —&gt; (list (quote a))</p>
<p class="p10">`(a b c) —&gt; (list (quote a) (quote b) (quote c))</p>
<p class="p10">`(a ,b c) —&gt; (list (quote a) b (quote c))</p>
<p class="p10">,a —-&gt; error (comma not inside backquote)</p>
<p class="p11"><br></p>
<p class="p6">To parse this, I use the grammar already developed.<span class="Apple-converted-space">  </span>I <i>could</i> write some code within the rule "BackQuotedSexp" to rewrite the backquoted code, but, I will use a <i>trick</i> - I will switch to another set of semantic rules when I see a backquote.<span class="Apple-converted-space">  </span>The main set of semantic rules is called 'unbackquote' and the backquote helper is called 'inbackquote'.<span class="Apple-converted-space">  </span>The semantic rules in 'inbackquote' are written to return reverse-quoted strings, which is what I want when I see a backquote.<span class="Apple-converted-space">  </span>The BackQuotedSexp rule of the main semantics calls the unparser in 'inbackquote' instead of recursively calling 'unbackquote' (as is done in the straight-forward 'unquote' semantics).</p>
<p class="p7"><br></p>
<p class="p6">What happens in the case where a backquoted sexp is seen while already processing a backquote?<span class="Apple-converted-space">  </span>I don't care.<span class="Apple-converted-space">  </span>This case never happens in the prolog-6.scm code that I want to automatically process.<span class="Apple-converted-space">  </span>This is, obviously, a place where I leave it as an exercise to the reader: try double-backquoting in a Lisp REPL to test your theory about how this is supposed to work, then mimic this behaviour in the parser.</p>
<p class="p7"><br></p>
<p class="p6">Numeric, string and boolean atoms are essentially constants, so their values aren't changed by backquote.</p>
<p class="p7"><br></p>
<p class="p6">(See commit 33eb0eb6f6389ab3423e2561b04e5e9221145ac4).</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Pipelning Grammar</b></h2>
<p class="p6">I should be able to feed the result from the latest unbackquote expander into the unity transformer.</p>
<p class="p7"><br></p>
<p class="p6">This will test whether I can pipeline the grammar, i.e. feed one grammar into another.<span class="Apple-converted-space">  </span>Ohm-JS can only parse character strings.<span class="Apple-converted-space">  </span>The backquote expander produces strings, so this shouldn't be a problem for Ohm-JS.</p>
<p class="p7"><br></p>
<p class="p6">Pipelinetest() runs each test case twice.<span class="Apple-converted-space">  </span>The first time, the original Scheme is run through unbackquote.<span class="Apple-converted-space">  </span>Then, the result from unbackquote is run, again, through unbackquote (which should parse, but find no quotes or backquotes to expand).<span class="Apple-converted-space">  </span>The first run expands all quotes and backquotes.<span class="Apple-converted-space">  </span>The second run does nothing, but parses the (already expanded) Scheme.<span class="Apple-converted-space">  </span>The results from the first run should be the same as the results from the second (regression) run, using JS string equality "==". <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">This means that the results from unbackquote form a valid Scheme program (at least as far as this grammar goes - as far as I need it to).</p>
<p class="p7"><br></p>
<p class="p6">(See commit 56569e3b6e33344db9409368f5754454c71b37ce)</p>
<p class="p7"><br></p>
<p class="p6">This means that I can pipe output from one grammar into another grammar.</p>
<p class="p7"><br></p>
<p class="p6">The point of pipelining is to remove possible dependencies - Divide and Conquer.<span class="Apple-converted-space">  </span>Once I have a grammar that expands quotes and backquotes, I know that it works.<span class="Apple-converted-space">  </span>I never have to alter that grammar again.<span class="Apple-converted-space">  </span>It does one job.<span class="Apple-converted-space">  </span>Then it gets frozen.<a id="fnlink13"></a><a href="#fn13"><span class="s4"><sup>[13]</sup></span></a></p>
<p class="p7"><br></p>
<p class="p6">As I progress further, I will want to tweak the grammar (to give us better handles on parts of the parse).<span class="Apple-converted-space">  </span>Pipelining ensures that no tweaks can alter the functioning of previously written code (grammars).<span class="Apple-converted-space">  </span>Quote and backquote expansion is working and I can forget about it, knowing that it will always work in the same way.</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Top Level Forms</b></h2>
<p class="p6">In prolog-6.scm, there are only 3 kinds of top-level forms:<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<ol class="ol1">
  <li class="li2">global variable definition</li>
  <li class="li2">global function definition</li>
  <li class="li2">call a function.</li>
</ol>
<p class="p5"><br></p>
<p class="p2">I created a new grammar - Scm2JSPass2 - knowing that the grammar does not need to handle quotes and backquotes.</p>
<p class="p5"><br></p>
<p class="p2">I added new rules to the pass2 grammar, to handle the 3 top level forms.<span class="Apple-converted-space">  </span>The earlier grammar handled all forms, including top-level ones, with one rule "Form".<span class="Apple-converted-space">  </span>Now, the pass2 grammar differentiates between the 3 top-level forms.</p>
<p class="p5"><br></p>
<p class="p2">(See commit 9ad44acc2d62e918f33b652b49e3e8c950bbfcec).</p>
<p class="p5"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Tweak the Grammar for the 3 Top-Level Scheme Constructs</b></h2>
<p class="p6">The minimal Scheme parser that I need to parse and transpile prolog-6.scm contains (only) 3 top-level constructs.</p>
<p class="p7"><br></p>
<ol class="ol1">
  <li class="li2">Global variable definitions</li>
  <li class="li2">Global function definitions</li>
  <li class="li2">Function calls.</li>
</ol>
<p class="p5"><br></p>
<p class="p2">A global variable definition looks like "(define sym &lt;form&gt;)".</p>
<p class="p5"><br></p>
<p class="p2">A global function definition looks like "(define (sym syms) &lt;form&gt;)".</p>
<p class="p5"><br></p>
<p class="p2">Function calls look like "(sym &lt;forms&gt;)".</p>
<p class="p5"><br></p>
<p class="p2">To pattern match this (aka parse this), I first need to differentiate syms from other kinds of atoms. <span class="Apple-converted-space">  </span>I call these Identifiers.<span class="Apple-converted-space">  </span>Identifiers are symbol names, and cannot be other kinds of atoms (e.g. strings, numbers, etc.).</p>
<p class="p5"><br></p>
<p class="p5"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Multiple Grammars in One HTML File</b></h2>
<p class="p2">I can have multiple grammars in an .HTML file, but I need to use .grammarsFromScriptElements() which returns a namespace containing multiple grammars, each contained in &lt;script<span class="Apple-converted-space">  </span>type="text/ohm-js"&gt;…&lt;/script&gt;<span class="Apple-converted-space">  </span>in the HTML document.</p>
<p class="p5"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Semantics - Quoting</b></h2>
<p class="p6">I've reached the point where I need to consider how every kind of Scheme expression should be transpiled into valid - and meaningful - JS.<span class="Apple-converted-space">  </span>This is call "semantics".</p>
<p class="p7"><br></p>
<p class="p6">First, let's look at (quote …).<span class="Apple-converted-space">  </span>What does it mean in JS?</p>
<p class="p7"><br></p>
<p class="p6">'() needs to become an empty list.<span class="Apple-converted-space">  </span>In JS, I can convert that to an empty array "[]", or I can define a class called List and call "new" on it.</p>
<p class="p7"><br></p>
<p class="p6">Let's choose the List class solution.</p>
<p class="p7"><br></p>
<p class="p6">I have constructed a pattern matcher (aka parser) for Scheme.<span class="Apple-converted-space">  </span>I can simply add a pattern for '() to the matcher and have it convert '"()" into "new List()".</p>
<p class="p7"><br></p>
<p class="p6"><i>[breaking news: I change this decision, later, near the end and I use Cons() instead of List().<span class="Apple-converted-space">  </span>Again, divide and conquer means not having to care until you have to care.<span class="Apple-converted-space">  </span>Glossing over details is a good design choice. PROLOG itself is a good example - we know how to write nested loops, but the details of looping discourages higher level thinking.<span class="Apple-converted-space">  </span>Using PROLOG, we are allowed to think in terms of relations instead of in terms of looping details + relations.<span class="Apple-converted-space">  </span>I argue that most programming languages shackle us in details instead of allowing us to think at higher levels (much like C/Pascal broke the strangle-hold on designers, who had to express everything in assembler)].</i></p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Special Forms</b></h2>
<p class="p6">In Scheme, almost everything is a function call with evaluated arguments.</p>
<p class="p7"><br></p>
<p class="p6">There are some special forms, though:</p>
<p class="p7"><br></p>
<ul class="ul2">
  <li class="li2">cond</li>
  <li class="li2">let (and let*)</li>
  <li class="li2">if</li>
</ul>
<p class="p5"><br></p>
<p class="p2">These are handled by adding more detailed rules to the grammar. <span class="Apple-converted-space"> </span></p>
<p class="p2">(See commit f6c5b87c7a5995ea1a2486c8f05c6d92798c6610 and the preceding commits).</p>
<p class="p5"><br></p>
<p class="p2">Test expressions in COND and IF are essentially the same, but it helps to give rules different names depending on their context (e.g. test expression in COND vs. test expression in IF).<span class="Apple-converted-space">  </span>The transpiler might emit different code for each of these rules, depending on the target language and its syntax.<a id="fnlink14"></a><a href="#fn14"><span class="s4"><sup>[14]</sup></span></a><span class="Apple-converted-space"> </span></p>
<p class="p5"><br></p>
<p class="p2">For example, I created separate parsing rules for the first test+clause in COND vs. the rest of the test+clauses of a COND, even though they are semantically the same.<span class="Apple-converted-space">  </span>I want to transpile Scheme's COND into if-then-elseif-then… statements in JS.<span class="Apple-converted-space">  </span>In this case, the first test+clause needs to transpile to an "if" statement, whereas the rest of test+clauses need to transpile into "} else if (…) {" statements.</p>
<p class="p5"><br></p>
<p class="p2">The pattern matcher doesn't care when I split rules, but, this can be helpful in making the transpiler simpler, for me, to write.<span class="Apple-converted-space">  </span>Patterns can help tell me in which order phrases arrive, even when the patterns match for the same phrases.</p>
<p class="p5"><br></p>
<p class="p2">At this moment, in this commit I've transpiled the special forms into pseudo-code, to watch how certain Scheme phrases are transpiled.</p>
<p class="p5"><br></p>
<p class="p2">Later, I will convert the pass2 semantics from emitting pseudo-code to emitting JS.</p>
<p class="p5"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Interlude - Illegal Characters</b></h2>
<p class="p6">At this point, I can see that the transpiler, in its present state, allows characters, like "?" and "-" and "*" in identifiers that are illegal in JS identifiers.</p>
<p class="p7"><br></p>
<p class="p6">I will deal with these later.</p>
<p class="p7"><br></p>
<p class="p6">The transpiler is a pattern matcher, and, changing single characters to other strings will be easy.<span class="Apple-converted-space">  </span>For now, it is easier on the eyes (at least for me, since I'm very familiar with Lisp) to leave the illegal characters and debug the operation of the transpiler at the 30,000 foot level.</p>
<p class="p7"><br></p>
<p class="p6">I proceed using Divide&amp;Conquer and chew on the harder bits first, leaving the "obvious" stuff (least risky) to the end.<span class="Apple-converted-space">  </span>There is more to learn by attacking the unknowns first.<span class="Apple-converted-space">  </span>In the worst case, I could use the "SED" tool to change the illegal characters.<span class="Apple-converted-space">  </span>This problem isn't worrisome at present and can be deferred.</p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>List Constants</b></h2>
<p class="p6">Scheme (and Lisp in general) reads code into lists.<span class="Apple-converted-space">  </span>It interprets the first item in a list as the function and the rest of the items in the list as (evaluated) arguments.</p>
<p class="p7"><br></p>
<p class="p6">QUOTE is used to create list constants.<span class="Apple-converted-space">  </span>The Lisp runtime doesn't try to execute constants, but only creates them.<span class="Apple-converted-space">  </span>This is very similar to how, say, string constants are created in JS.</p>
<p class="p7"><br></p>
<p class="p6">For example, the "goals" database used in prolog-6.scm is:</p>
<p class="p7"><br></p>
<p class="p10">(define goals '((some (? X))</p>
<p class="p10"><span class="Apple-converted-space">                </span>(some (? Y))</p>
<p class="p10"><span class="Apple-converted-space">                </span>(neq (? X) (? Y))))</p>
<p class="p7"><br></p>
<p class="p6">which says that the global variable "goals" is created as a list constant containing 3 items. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">Pass1 of the transpiler converts this into:</p>
<p class="p11"><br></p>
<p class="p10">(define goals (quote ((some (? X)) (some (? Y)) (neq (? X) (? Y))))</p>
<p class="p7"><br></p>
<p class="p6">I want this to transpile to something like the following, in pseudo-code:</p>
<p class="p7"><br></p>
<p class="p10">(? X) —&gt; new List("?", "X") (where ? is a valid identifier in Lisp)</p>
<p class="p10">(some (new<span class="Apple-converted-space">  </span>List("?","X"))) —&gt; new List("some", new List("?","X"))</p>
<p class="p11"><br></p>
<p class="p6">and the whole global constant (global variable) definition becomes:</p>
<p class="p7"><br></p>
<p class="p10">var goals = new List( new List("some",new List("?","X")),</p>
<p class="p10"><span class="Apple-converted-space">                      </span>new List("some",new List("?","Y")),</p>
<p class="p10"><span class="Apple-converted-space">                      </span>new List("neq", new List("?","X"), new List("?","Y") );</p>
<p class="p7"><br></p>
<p class="p6">Looking at it this way, I see that the prolog-6.scm code uses "(? X)" to create "logic variables" (in this case, a logic variable called X).<span class="Apple-converted-space">  </span>Lists are used for all sorts of data in Lisp, but in this specific example, (? X) creates a logic variable.<span class="Apple-converted-space">  </span>Hmm, maybe I want the transpiler to turn this into:</p>
<p class="p7"><br></p>
<p class="p10">var goals = new List( new List("some",new LogicVar("X")),</p>
<p class="p10"><span class="Apple-converted-space">                      </span>new List("some",new LogicVar("Y")),</p>
<p class="p10"><span class="Apple-converted-space">                      </span>new List("neq", new LogicVar("X"), new LogicVar("Y")) );</p>
<p class="p7"><br></p>
<p class="p6">It would be easy to have the transpiler convert patterns like "(? X)" into something more meaningful.<span class="Apple-converted-space">  </span>Hmm, maybe I should stick to the List version and make such changes later, after the basics are debugged.</p>
<p class="p7"><br></p>
<p class="p6">Decision made - I'll stick with the List version for now and optimize later…</p>
<p class="p7"><br></p>
<p class="p6">So, the transpiler should convert</p>
<p class="p7"><br></p>
<p class="p10">(quote (…)) —&gt; new List(…)</p>
<p class="p11"><br></p>
<p class="p6">And, it should do this recursively.</p>
<p class="p7"><br></p>
<p class="p6">The syntax for JS is wildly different from that of Scheme.<span class="Apple-converted-space">  </span>In order to continue using (the simpler) Scheme syntax, I transpile the above into valid Scheme.<span class="Apple-converted-space">  </span>I will unwind this in the final (emitter) pass.</p>
<p class="p7"><br></p>
<p class="p10">(quote (…)) —&gt; (@newList@ (…))<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">(See commit 0c410d333c6370d39b9f648c38dff2f505a5502e).</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>When Do You Create a New Pass?</b></h2>
<p class="p6">The parser consists of two main parts:</p>
<p class="p7"><br></p>
<ul class="ul2">
  <li class="li2">a grammar</li>
  <li class="li2">a set of semantics hung off of the grammar</li>
</ul>
<p class="p7"><br></p>
<p class="p6">I am using the grammar<a id="fnlink15"></a><a href="#fn15"><span class="s4"><sup>[15]</sup></span></a> to help me build the transpiler.</p>
<p class="p7"><br></p>
<p class="p6">I start a new pass when I want encapsulation.<span class="Apple-converted-space">  </span>The encapsulation provided by pure OO is not enough.<span class="Apple-converted-space">  </span>Just creating new sets of semantics is not sufficient to encapsulate all of the changes I need to make. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">In particular, whenever I need to hack on the grammar to make things easier, I need to start a new pass.<span class="Apple-converted-space">  </span>OO encapsulation won't save me here - I need to start with a simple grammar (e.g. Scm2JSBasic) and freeze my work.<span class="Apple-converted-space">  </span>Then, I need to create new layers of grammars that perform specific functions for my transpiler. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">Ohm-JS has a way to extend grammars in an OO-like manner, but this feature does not actually encapsulate the changes.<span class="Apple-converted-space">  </span>The final result is a "flat" grammar that may contain hidden dependencies that make debugging harder.</p>
<p class="p7"><br></p>
<p class="p6">It is much better (safer, less debugging) to use a hierarchy of composed grammars instead of inherited grammars.</p>
<p class="p7"><br></p>
<p class="p6">I want to freeze what I've got.<span class="Apple-converted-space">  </span>I don't want new changes to interfere with previously-correct grammars.<span class="Apple-converted-space">  </span>The only way that I know of to accomplish this is to use <i>passes</i> (passes like pipelines in the UNIX® shell.<span class="Apple-converted-space">  </span>This feature - composition - might be why pipelines became popular).<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">The List Constant changes could be done in the pass1 grammar, but, then, the layering Architecture would be lost.<span class="Apple-converted-space">  </span>The grammar would become a ball of lint - collecting every change I've made, instead of laying out the changes in a layered manner.</p>
<p class="p7"><br></p>
<p class="p6">PEG's backtracking leads to unexpected bugs when new changes are added to an existing grammar.</p>
<p class="p7"><br></p>
<p class="p6">An example of the problem is seen when comparing the original pass1 grammar with the changes I added in pass2.<span class="Apple-converted-space">  </span>Pass2 has more details.<span class="Apple-converted-space">  </span>When trying to understand the grammar, one should begin by looking at the pass1 grammar.<span class="Apple-converted-space">  </span>The changes for pass2 could have been added by extending the grammar via inheritance and overriding, but overriding can lead to hidden dependencies and new bugs in previously working code.<span class="Apple-converted-space">  </span>What I want is a freeze of what already works.<span class="Apple-converted-space">  </span>Then, I want to compose new changes in layers over what already works.<span class="Apple-converted-space">  </span>Overriding does not layer my changes - inheritance and overriding change the final grammar and, possibly, the final result.</p>
<p class="p7"><br></p>
<p class="p6">Paul Bassett's work on Frame-based software<a id="fnlink16"></a><a href="#fn16"><span class="s4"><sup>[16]</sup></span></a> might be a direction to look into.<span class="Apple-converted-space">  </span>Bassett's Frames are not the same concept as the concept called "frames" in older forms of AI.</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Grammar Inheritance</b></h2>
<p class="p6">Grammars for Scm2JSListConstants and Scm2JSEmitter are rewritten to inherit from Scm2JSBasic.</p>
<p class="p7"><br></p>
<p class="p6">Note that this creates new "flat" grammars and does not, by itself, create new isolated passes.</p>
<p class="p7"><br></p>
<p class="p6">Note that Scm2JSEmitter inherits from Scm2JSBasic and not from its immediate predecessor Scm2JSListConstants (as would be done if I used only OO instead of a pass-based strategy).</p>
<p class="p7"><br></p>
<p class="p6">OO is essentially a fancy form of cut&amp;paste - it creates new "flat" grammars by piling changes up on predecessor grammars.<span class="Apple-converted-space">  </span>This applies to all forms of OO, not just to grammars.<span class="Apple-converted-space">  </span>OO provides only <i>some</i> encapsulation, not full encapsulation.</p>
<p class="p7"><br></p>
<p class="p6">Inheritance produces increasingly complicated software and does not provide a way to "freeze" changes.</p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Isolation</b></h2>
<p class="p6">I will use the word "isolation" to mean encapsulation that supports freezing.</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Emitting JavaScript</b></h2>
<p class="p6">I copy&amp;pasted the emitter semantics and created a new semantics (for the same grammar) called 'emitjs'.</p>
<p class="p7"><br></p>
<p class="p6">I modified the IF-THEN-ELSE code to emit JS ?: expressions.<span class="Apple-converted-space">  </span>(See commit cc41021f1f3efe0b02598ba25020064470f95093).<span class="Apple-converted-space"> </span></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Functional JS</b></h2>
<p class="p6">Lisp - and Scheme - does not have <i>statements</i>.<span class="Apple-converted-space">  </span>Lisp only has expressions (called s-exprs) and special forms</p>
<p class="p7"><br></p>
<p class="p6">Every expression returns a value.<span class="Apple-converted-space">  </span>Always.</p>
<p class="p7"><br></p>
<p class="p6">To stay true to the semantics of Scheme, I must emit JS code that is expression-based.<span class="Apple-converted-space">  </span>This is possible in JS using <i>anonymous functions</i>.<span class="Apple-converted-space">  </span>The emitted code is going to look horrible, but it will be a true representation of the original Scheme program.<span class="Apple-converted-space">  </span>Later, after I see things work and can regression test, I can try to "optimize" some of the sequences, so that they don't look as ugly.</p>
<p class="p7"><br></p>
<p class="p6">For example, whenever the parser sees an atom, we emit a function.</p>
<p class="p7"><br></p>
<p class="p6">If the atom is a number N, then the parser emits<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p10">(function(){return N;})</p>
<p class="p11"><br></p>
<p class="p6">If the atom is a string, say "abc", then the parser needs to emit:</p>
<p class="p7"><br></p>
<p class="p10">(function(){return "abc";})</p>
<p class="p11"><br></p>
<p class="p6">When the parser sees a function call (an s-expr, where the first item is a function and the rest of the items are arguments), it emits a function which evaluates the arguments and returns a function which calls the intended function, say (fn a b c) becomes:</p>
<p class="p7"><br></p>
<p class="p18"><span class="Apple-converted-space"> </span>(function(){return fn(a(),b(),c();})<a id="fnlink17"></a><a href="#fn17"><sup>[17]</sup></a></p>
<p class="p7"><br></p>
<p class="p6">Below, is a list of all transformations I think I need:</p>
<p class="p7"><br></p>
<p class="p10">atom x --&gt; (function(){return x;})</p>
<p class="p10">SList (a b c) --&gt; (function(){return a(fb(),fc());}) [where fb and fc are functions]</p>
<p class="p10">special (and b c) --&gt; (function(){return _and([b,c]);})</p>
<p class="p10">special (or b c) --&gt; (function(){return _or([b,c]);})</p>
<p class="p10">special (not b) --&gt; (function(){return (b() == false) ? true : false;})</p>
<p class="p10">special (if x y z) --&gt; (function(){return (x() != false) ? y() : z();})</p>
<p class="p10">special (if x y) --&gt; (function(){return (x() != false) ? y() : null;})</p>
<p class="p10">special (cond ((a b c) (d e f))) --&gt; (function(){return _cond([[a,b,c],[d,e,f]])})</p>
<p class="p10">special (let ((a b) (c d)) d e f) --&gt; (function(a=b(),c=d()){return d(),e(),f();})</p>
<p class="p10">special (quote symbol) —&gt; (function(){return "symbol";}) [since JS doesn't have symbols per se]</p>
<p class="p10">special (quote N) —&gt; (function(){return N;}) [where N is a number]</p>
<p class="p10">special (quote "abc") —&gt; (function(){return "abc";})</p>
<p class="p10">special (quote #f) —&gt; (function(){return false;})</p>
<p class="p10">special (quote #t) —&gt; (function(){return true;})</p>
<p class="p10">special (quote (…)) —&gt; (function(){return new List(…);})</p>
<p class="p11"><br></p>
<p class="p19"><br></p>
<p class="p6">I'm expecting to supply a small runtime library that defines functions _and(), _or() and _cond().<span class="Apple-converted-space">  </span>In Lisp, these things work like &amp;&amp; and || in JS.<span class="Apple-converted-space">  </span>Each item is evaluated and evaluation<i> stops </i>as soon as one item is non-false.<a id="fnlink18"></a><a href="#fn18"><span class="s4"><sup>[18]</sup></span></a><span class="Apple-converted-space">  </span>It is imperative that unneeded arguments not be evaluated.<span class="Apple-converted-space">  </span>In the JS version, I will pass an array of (unevaluated) functions to _and and _or.<span class="Apple-converted-space">  </span>This is like how Smalltalk implements control flow - it passes unevaluated blocks (anonymous functions) into branching code.<span class="Apple-converted-space">  </span>The code decides which branch to take and evaluates (runs) the block.<a id="fnlink19"></a><a href="#fn19"><span class="s4"><sup>[19]</sup></span></a><span class="Apple-converted-space">  </span><i>[breaking news: I will modify the above code templates later, before I finish].</i></p>
<p class="p6">Most of the mystique of compiler-writing is the act of learning, and coming up with, patterns that make the emitted code suck less. <span class="Apple-converted-space"> </span></p>
<p class="p6">It used to be that "suck less" meant creating emitted patterns that ran faster than their unoptimized versions. <span class="Apple-converted-space"> </span></p>
<p class="p6">We have learned, over the years, how to build compilers that are hot and fast.</p>
<p class="p6">Thankfully, I am just building a transpiler - I am going to let the JS compiler(s) worry about optimizing my emitted code.<span class="Apple-converted-space">  </span>I just want it to work, I don't need fast-ness.<span class="Apple-converted-space">  </span>If I do create some optimizations, it will probably have to do with making the emitted code more readable to humans.<a id="fnlink20"></a><a href="#fn20"><span class="s4"><sup>[20]</sup></span></a><span class="Apple-converted-space">  </span>Fast-ness isn't my problem - it's the problem that competent Efficiency Engineers can tackle (once the transpiler is working).</p>
<p class="p7"><br></p>
<p class="p6">I'll try implementing the above table, then see what breaks.<span class="Apple-converted-space">  </span>Divide &amp; Conquer…</p>
<p class="p7"><br></p>
<p class="p6">In the rule FunctionCall, the original grammar specifies that the arguments ("actuals") are parsed as ListItem.<span class="Apple-converted-space">  </span>In emitting this code, I want to append "()" to every argument (to effectively evaluate it), but only in function calls.<span class="Apple-converted-space">  </span>The easiest way that I could think of to do this was to create a new rule "Arg" and use it instead of ListItem when parsing the arguments to a function.<span class="Apple-converted-space">  </span>I am using the parser to tell me what the context is and, in the case of arguments to a function call (only) I append "()" to each list item.<a id="fnlink21"></a><a href="#fn21"><span class="s4"><sup>[21]</sup></span></a></p>
<p class="p7"><br></p>
<p class="p6">(See commit 9db14775d9acedfb187a33feaa8bf41b508e4617).</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Waterfall</b></h2>
<p class="p6">In software, it is never true that one can get it right the first time around. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">If you think that you know what you are doing, then you are employing a technique called <i>the Waterall method</i>. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">Even really smart people don't get it right most of the time - for example, refer to most existing multi-tasking libraries and the agony that these have caused.<a id="fnlink22"></a><a href="#fn22"><span class="s4"><sup>[22]</sup></span></a></p>
<p class="p7"><br></p>
<p class="p6">[If you thought that you got it right the "first time", odds are that you have done this before.]<span class="Apple-converted-space"> </span></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Workflow</b></h2>
<p class="p6">The grammar IDE at <a href="https://ohmlang.github.io/editor/"><span class="s10">https://ohmlang.github.io/editor/</span></a><span class="s10"> </span>is useful, although it appears not to accept grammars that inherit from user-defined grammars (not a big loss, since inheritance applied to code serves to de-localize the code, making it more difficult to debug).</p>
<p class="p6">My suggested workflow becomes:<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<ul class="ul2">
  <li class="li2">write the grammar (aka the pattern matcher)</li>
  <li class="li2">test the grammar against various cases, using the grammar editor <a href="https://ohmlang.github.io/editor/"><span class="s10">https://ohmlang.github.io/editor/</span></a><span class="s10">, </span>starting with simple cases, then escalating in complexity</li>
  <li class="li2">once the grammar is fully debugged, build the semantics object(s) associated with the grammar</li>
  <li class="li2">copy the output to a file and run <span class="s11">node</span> on it, to find further transpilation mistakes.</li>
  <li class="li5"><br></li>
</ul>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Mapping Illegals to JS</b></h2>
<p class="p6">Scheme allows many more characters as valid identifier characters than does JS.</p>
<p class="p7"><br></p>
<p class="p6">At this stage in debugging, I want to test the emitted code using the node compiler.</p>
<p class="p7"><br></p>
<p class="p6">The illegal characters must be mapped to valid JS character strings.<span class="Apple-converted-space">  </span>This is done using the .replace() function and JS REGEXs.<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">See the function <span class="s12">doReplacements() </span>in<span class="s12"> index.html </span>for a list of the actual replacements.</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Refining Scheme to JS Emission</b></h2>
<p class="p6">The JS emitter, as currently written, shows some weaknesses and bugs.<span class="Apple-converted-space">  </span>Notably, the emitted code is extremely hard to read.</p>
<p class="p6">This chapter of this essay describes a second attempt at code emission in JS…</p>
<p class="p7"><br></p>
<p class="p6">Instead of emitting <i>everything </i>as a function, I pay closer attention to which parts of JS are expressions and which parts are statements.<span class="Apple-converted-space">  </span>I hope to emit the expressions alone and to let them be emitted in "normal" JS.<span class="Apple-converted-space">  </span>I will wrap "function (…){…}" blocks around only the JS statements that do not, by default, return a value.<span class="Apple-converted-space">  </span>I believe that this will make the emitted code look more like "standard" JS.<span class="Apple-converted-space">  </span>I've already got the parser working, so I only need to think about one narrow aspect - the rewriting of the .semantics() code for 'emitjs'.</p>
<p class="p7"><br></p>
<p class="p6">The semantics (meaning) of Scheme is that everything is an expression and, thus, everything returns a value.<span class="Apple-converted-space">  </span>In Scheme, there are a few basic types.<span class="Apple-converted-space">  </span>Just about everything else looks like a function (with the open-parentheses moved leftward).</p>
<p class="p6">The emitted JS code must evaluate to the same semantics as Scheme.<span class="Apple-converted-space">  </span>Everything returns a value.<span class="Apple-converted-space">  </span>This is not a problem for basic types (numbers, strings, booleans), but, JS also specifies several statements (like "if") that are evaluated for side-effects only and do not return a value.<span class="Apple-converted-space">  </span>In mapping Scheme to JS, I must emit JS code that returns values for such statements.</p>
<p class="p6">Thankfully, JS allows me to create anonymous functions.<span class="Apple-converted-space">  </span>I will wrap anonymous functions around the statement types and invoke <i>return </i>inside of the functions.<span class="Apple-converted-space">  </span>I will cause the functions to be evaluated by suffixing them with "()".</p>
<p class="p6">I list the mappings below, as I understand them now…</p>
<p class="p11"><br></p>
<table width="100%" cellspacing="0" cellpadding="0" class="t1">
  <tbody>
    <tr>
      <td valign="top" class="td1">
        <p class="p20"><span class="s1"><b>Scheme syntax</b></span></p>
      </td>
      <td valign="top" class="td1">
        <p class="p20"><span class="s1"><b>Emitted JS</b></span></p>
      </td>
    </tr>
    <tr>
      <td valign="top" class="td1">
        <p class="p20">atom</p>
      </td>
      <td valign="top" class="td1">
        <p class="p20">atom</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(fn a b c)</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">fn(a,b,c)</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(if e thn els)</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">(function(){</p>
        <p class="p20"><span class="Apple-converted-space">    </span>if e {</p>
        <p class="p20"><span class="Apple-converted-space">        </span>return thn;</p>
        <p class="p20"><span class="Apple-converted-space">    </span>} else {</p>
        <p class="p20"><span class="Apple-converted-space">        </span>return els;</p>
        <p class="p20"><span class="Apple-converted-space">    </span>}</p>
        <p class="p20">)()</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(if e thn)</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">(function(){</p>
        <p class="p20"><span class="Apple-converted-space">    </span>if e {</p>
        <p class="p20"><span class="Apple-converted-space">        </span>return thn;</p>
        <p class="p20"><span class="Apple-converted-space">    </span>} else {</p>
        <p class="p20"><span class="Apple-converted-space">        </span>return null;</p>
        <p class="p20"><span class="Apple-converted-space">    </span>}</p>
        <p class="p20">)()</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(let ((a x) (b y)) d e f)</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">(function(a=x, b=y)){ d; e; return f; })()</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(and a b c)</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">(function() {</p>
        <p class="p20"><span class="Apple-converted-space">    </span>if (a &amp;&amp; b &amp;&amp; c) {</p>
        <p class="p20"><span class="Apple-converted-space">        </span>return true;</p>
        <p class="p20"><span class="Apple-converted-space">    </span>} else {</p>
        <p class="p20"><span class="Apple-converted-space">        </span>return false;</p>
        <p class="p20"><span class="Apple-converted-space">    </span>}</p>
        <p class="p20">}) ()</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(or a b c)</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">(function() {</p>
        <p class="p20"><span class="Apple-converted-space">    </span>if (a || b || c) {</p>
        <p class="p20"><span class="Apple-converted-space">        </span>return true;</p>
        <p class="p20"><span class="Apple-converted-space">    </span>} else {</p>
        <p class="p20"><span class="Apple-converted-space">        </span>return false;</p>
        <p class="p20"><span class="Apple-converted-space">    </span>}</p>
        <p class="p20">}) ()</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(not x)<span class="Apple-converted-space"> </span></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">!x</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(cond (a b c) (d e f) (else g h i))</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20"><span class="Apple-converted-space"> </span>(function () {</p>
        <p class="p20"><span class="Apple-converted-space">      </span>if a {</p>
        <p class="p20"><span class="Apple-converted-space">          </span>b;</p>
        <p class="p20"><span class="Apple-converted-space">          </span>return c;</p>
        <p class="p20"><span class="Apple-converted-space">       </span>} else if d {</p>
        <p class="p20"><span class="Apple-converted-space">          </span>e;</p>
        <p class="p20"><span class="Apple-converted-space">          </span>return f;</p>
        <p class="p20"><span class="Apple-converted-space">       </span>} else {</p>
        <p class="p20"><span class="Apple-converted-space">          </span>g;</p>
        <p class="p20"><span class="Apple-converted-space">          </span>h;</p>
        <p class="p20"><span class="Apple-converted-space">          </span>return i;</p>
        <p class="p20"><span class="Apple-converted-space">       </span>}</p>
        <p class="p20"><span class="Apple-converted-space">  </span>) ()</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(cond (a b c) (d e f))</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20"><span class="Apple-converted-space"> </span>(function () {</p>
        <p class="p20"><span class="Apple-converted-space">      </span>if a {</p>
        <p class="p20"><span class="Apple-converted-space">          </span>b;</p>
        <p class="p20"><span class="Apple-converted-space">          </span>return c;</p>
        <p class="p20"><span class="Apple-converted-space">       </span>} else if d {</p>
        <p class="p20"><span class="Apple-converted-space">          </span>e;</p>
        <p class="p20"><span class="Apple-converted-space">          </span>return f;</p>
        <p class="p20"><span class="Apple-converted-space">       </span>} else {</p>
        <p class="p20"><span class="Apple-converted-space">          </span>return null;</p>
        <p class="p20"><span class="Apple-converted-space">       </span>}</p>
        <p class="p20"><span class="Apple-converted-space">  </span>) ()</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(a b c)</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">a(b,c)</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p21"><br></p>
      </td>
      <td valign="middle" class="td2">
        <p class="p21"><br></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">;; top level</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p21"><br></p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(define g v)</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">var g = v;</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(define (f a b) c d)</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">function f(a b) { c ; return d; };</p>
      </td>
    </tr>
    <tr>
      <td valign="middle" class="td2">
        <p class="p20">(a b c)</p>
      </td>
      <td valign="middle" class="td2">
        <p class="p20">a(b,c)</p>
      </td>
    </tr>
  </tbody>
</table>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p6">Again, I won't be doing any checking - I will let the JS compiler check the types for me.<span class="Apple-converted-space">  </span>I continue to treat the parser as a glorified REGEX, not as a full-blown language builder.<span class="Apple-converted-space">  </span>Future generations of the tool environment might allow my transpiler to insert file location / debug information to allow easier debugging by humans.<span class="Apple-converted-space">  </span>Future IDEs might allow the insertion of BREAK statements into the generated code, much like what is currently done with IDEs+compilers+assembler today.<span class="Apple-converted-space">  </span>LISP has some advanced features for this kind of insertion.<span class="Apple-converted-space">  </span>I don't know enough about JS at present, to say whether JS does or does not have such features.</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Writability vs. Readability</b></h2>
<p class="p6">Ohm-JS documentation emphasizes the fact that grammars are "clean" and semantics have been moved out of the grammar<a id="fnlink23"></a><a href="#fn23"><span class="s4"><sup>[23]</sup></span></a>.</p>
<p class="p7"><br></p>
<p class="p6">This makes sense for <i>readability</i>.<span class="Apple-converted-space">  </span>The grammar and semantics have been created and checked by the compiler. <span class="Apple-converted-space">  </span>A Maintenance Engineer can <i>read</i> the grammar and then refer to the semantics object.</p>
<p class="p7"><br></p>
<p class="p6">This separation of semantics from grammar, though, makes <i>writing </i>more difficult, since one needs to refer to the grammar when writing semantic rules.<span class="Apple-converted-space">  </span>For example, I have broken CondExpression into many parts.<span class="Apple-converted-space">  </span>I have to ping-pong between the grammar and the semantics object to ensure that I have correctly named each semantic rule and to make sure that the arities of semantic rules match the grammar.<span class="Apple-converted-space">  </span>I just changed the grammar to split Cond into more pieces - now, I find it difficult to ensure that the semantics object corresponds to the tweaked grammar.<a id="fnlink24"></a><a href="#fn24"><span class="s4"><sup>[24]</sup></span></a></p>
<p class="p7"><br></p>
<p class="p6">Ideally, I should be able to choose whether I view grammar rules and the semantics rules in one eye-full, or, whether the grammar should be clean, with semantics rules moved elsewhere.</p>
<p class="p7"><br></p>
<p class="p6">At least, the ohm-js compiler performs arity checks and raises error conditions if there is a mismatch between grammar and semantic rules.</p>
<p class="p7"><br></p>
<p class="p6">Can this<a id="fnlink25"></a><a href="#fn25"><span class="s4"><sup>[25]</sup></span></a> be significantly improved?</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Greedy Matching</b></h2>
<p class="p6">PEG (and ohm-js) uses <i>greedy </i>matching.<span class="Apple-converted-space">  </span>It matches the longest possible phrase and doesn't turn back.</p>
<p class="p7"><br></p>
<p class="p6">This means that I can write a rule, like:</p>
<p class="p7"><br></p>
<p class="p10"><span class="Apple-converted-space">  </span>CondExpressionWithElse = BEGIN lexical_COND FirstCondClause MoreCondClause CondElseClause END</p>
<p class="p11"><br></p>
<p class="p6">but not a rule like:</p>
<p class="p7"><br></p>
<p class="p10"><span class="Apple-converted-space"> </span>StatementBlock = Statement* LastStatement<span class="Apple-converted-space"> </span></p>
<p class="p11"><br></p>
<p class="p6">The first pattern matches one CondClause then matches more CondClauses.</p>
<p class="p19"><br></p>
<p class="p6">The second pattern matches a bunch of statements, greedily matching all statements, then I want it to back up and leave one Statement to match LastStatement.<span class="Apple-converted-space">  </span>This back up doesn't happen and the pattern match fails.</p>
<p class="p7"><br></p>
<p class="p6">The corrected version of the rule is</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-converted-space"> </span>StatementBlock = Statement+<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">I can handle the "last" statement in the semantics, since ohm-js gives me an Iter node containing statements.</p>
<p class="p7"><br></p>
<p class="p6">I would <i>prefer</i> to have the pattern matcher tell me which is the last statement, without having to write code to walk the Iter node chain.</p>
<p class="p7"><br></p>
<p class="p6">Can I rewrite this?<span class="Apple-converted-space">  </span>Maybe, using ohm-js' lookahead operation.</p>
<p class="p7"><br></p>
<p class="p6">Maybe I can say something like:</p>
<p class="p19"><br></p>
<p class="p10">StatementBlock = MidStatement* LastStatement</p>
<p class="p10">MidStatement = Statement &amp;Statement</p>
<p class="p10">LastStatement = Statement ~Statement</p>
<p class="p19"><br></p>
<p class="p6">?</p>
<p class="p6">I'll try it out in the editor using "(a) (b) (c)" as input and selecting (from the pull-down) the start rule as StatementBlock.</p>
<p class="p7"><br></p>
<p class="p6">Note that the editor shows the input string at the top of the tree output window.<span class="Apple-converted-space">  </span>For every &amp;, it shows the input an extra time.<span class="Apple-converted-space">  </span>For example when the above rules are use to parse "(a) (b) (c)", the editor shows two "(c)" even though the input contains only one "(c)".</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Quoting Revisited</b></h2>
<p class="p6">As I get further and try more detailed examples, I see some bugs in the quote expander code.</p>
<p class="p7"><br></p>
<p class="p6">Firstly,<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p10">(define db '(5)) </p>
<p class="p11"><br></p>
<p class="p6">Comes out as</p>
<p class="p11"><br></p>
<p class="p10">(define db (@newList@ "5")) </p>
<p class="p11"><br></p>
<p class="p6">whereas it should be</p>
<p class="p11"><br></p>
<p class="p10">(define db (@newList@ 5)).</p>
<p class="p11"><br></p>
<p class="p6">This is a variant of the problem I solved in the Scm2JS grammar, and should be easy to repair.<span class="Apple-converted-space">  </span>Thankfully, the quote expansion is isolated, so I know that changes to it will not affect what I've done so far. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">See commit 8946e4f755f5b3083fcf0203c0d3246d0b8cd399 which fixes quoted lists of single atoms and a quoted null list.<span class="Apple-converted-space">  </span>The result still has problems…</p>
<p class="p7"><br></p>
<p class="p6">Next, I see (1) that the Scm2JS grammar treats the insides of quoted lists as function calls and (2) something looks odd for input "(define db '(((edge a b))):.</p>
<p class="p7"><br></p>
<p class="p6">Actually, after a more detailed look, I see that (1) is misdiagnosed.<span class="Apple-converted-space">  </span>The emitter has left-over code that places "()" after every item when emitting for SList_atnewlistat.<span class="Apple-converted-space">  </span>I need to remove the spurious "()".<span class="Apple-converted-space">  </span>See commit 0ce488124f292152754348e030b78be3b449fb13 (now back on the 'master' branch, once again).</p>
<p class="p7"><br></p>
<p class="p6">Now, (2) looks more reasonable, but still has spurious "function"s emitted.<span class="Apple-converted-space">  </span>Again, this is just legacy code - easy to clean up and fix.<span class="Apple-converted-space">  </span>See commit 6a5a268cccdc04c593c79983bd5d02ccf80160ed.</p>
<p class="p7"><br></p>
<p class="p6">The emitted code is</p>
<p class="p7"><br></p>
<p class="p10">var db = new List(new List(new List("edge","a","b")));</p>
<p class="p7"><br></p>
<p class="p6">but the node compiler balks with the error that List is undefined.</p>
<p class="p7"><br></p>
<p class="p6">Manually stubbing in List…</p>
<p class="p7"><br></p>
<p class="p10">function List(args) {</p>
<p class="p10">};</p>
<p class="p7"><br></p>
<p class="p6">and the code compiles cleanly under node (put the code into "junk.js" and run node: "node junk.js").</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Dotted Lists</b></h2>
<p class="p6">There is but one instance of a dotted list in prolog-6.scm</p>
<p class="p7"><br></p>
<p class="p10">(define db</p>
<p class="p10"><span class="Apple-converted-space">  </span>'(((edge a b))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge a f))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge a g))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge b c))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge b d))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge c d))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge c e))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge g h))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge d h))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge h e))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge h f))</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>((path (? A) (? B) ((? A) (? B)))</p>
<p class="p10"><span class="Apple-converted-space">     </span>(edge (? A) (? B)))</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>((path (? A) (? B) ((? A) . (? CB)))</p>
<p class="p10"><span class="Apple-converted-space">     </span>(edge (? A) (? C))</p>
<p class="p10"><span class="Apple-converted-space">     </span>(path (? C) (? B) (? CB)))))</p>
<p class="p11"><br></p>
<p class="p6">I could handle the dotted list in the grammar, but, it is easier to change the code manually to remove the dotted list completely (and rewrite it to call a library function that I'll call _cons).<span class="Apple-converted-space">  </span>I will write the replacement in Scheme and let the transpiler do the rest of the job…</p>
<p class="p7"><br></p>
<p class="p10">(define db</p>
<p class="p10"><span class="Apple-converted-space">  </span>'(((edge a b))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge a f))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge a g))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge b c))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge b d))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge c d))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge c e))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge g h))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge d h))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge h e))</p>
<p class="p10"><span class="Apple-converted-space">    </span>((edge h f))</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>((path (? A) (? B) ((? A) (? B)))</p>
<p class="p10"><span class="Apple-converted-space">     </span>(edge (? A) (? B)))</p>
<p class="p11"><br></p>
<p class="p10"><span class="Apple-converted-space">    </span>((path (? A) (? B) (_cons (? A) (? CB)))</p>
<p class="p10"><span class="Apple-converted-space">     </span>(edge (? A) (? C))</p>
<p class="p10"><span class="Apple-converted-space">     </span>(path (? C) (? B) (? CB)))))</p>
<p class="p11"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Dissecting the Parse</b></h2>
<p class="p6">I found that the parsing results from the ohm editor were misleading.<span class="Apple-converted-space">  </span>I implemented my own tree viewer, using Lisp-like syntax.<span class="Apple-converted-space">  </span>See commit 950c308f28e5a3360afc14fb6b9f171c4a4acb32.</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Larger Tests</b></h2>
<p class="p6">The new grammars now handle all of prolog-6.scm.</p>
<p class="p7"><br></p>
<p class="p6">I view the JavaScript output using my favourite pretty-printer (emacs, JavaScript-mode, in my case).</p>
<p class="p7"><br></p>
<p class="p6">I am manually eyeing the output backwards - starting with the final call to prove6().</p>
<p class="p7"><br></p>
<p class="p6">I see something suspicious in the transpilation of the function "resolve".</p>
<p class="p7"><br></p>
<p class="p6">I have saved the output in prolog-6.js.<span class="Apple-converted-space">  </span>Running "node<a id="fnlink26"></a><a href="#fn26"><span class="s4"><sup>[26]</sup></span></a>" on it shows an error at function "back5".</p>
<p class="p7"><br></p>
<p class="p6">That gives me at least two errors to look at.</p>
<p class="p7"><br></p>
<p class="p6">I will start debugging by looking at back5.<span class="Apple-converted-space">  </span>I start with cutting back5 out of the full test and making a test harness for it.</p>
<p class="p7"><br></p>
<p class="p6">Back5 transpiled and formated, is:</p>
<p class="p7"><br></p>
<p class="p10">function back5(l,g,r,e,n) {</p>
<p class="p10"><span class="Apple-converted-space">    </span>return (function(){</p>
<p class="p10"><span class="Apple-tab-span">	</span>if (</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>(function(){</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>ifpair_Q_(g) &amp;&amp; pair_Q_(r) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return true;</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>} else {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return false;</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}))</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>()</p>
<p class="p10"><span class="Apple-tab-span">	</span>) {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return prove5(l,g,cdr(r),e,n);</p>
<p class="p10"><span class="Apple-tab-span">	</span>} else {</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">    </span>return prove5(L_l(l),L_g(l),cdr(L_r(l)),L_e(l),L_n(l));</p>
<p class="p10"><span class="Apple-tab-span">	</span>}</p>
<p class="p10"><span class="Apple-converted-space">    </span>})</p>
<p class="p10"><span class="Apple-converted-space">    </span>();</p>
<p class="p10">};</p>
<p class="p11"><br></p>
<p class="p6">The first obvious problem is the ifpair_Q_. The branching AND (&amp;&amp;) needs to be wrapped in parentheses and, for readability, the "if" could use a space before the expression.<span class="Apple-converted-space">  </span>Both of these problems can be addressed by adjusting the code for &amp;&amp; (and ||).</p>
<p class="p7"><br></p>
<p class="p6">Next, there is a problem with CondClauses - MoreCondClause is defined as CondClause*.<span class="Apple-converted-space">  </span>Instead it should be defined as a CondClause and the * repetition is moved up into CondExpressionWithElse and CondExpressionWithoutElse.<span class="Apple-converted-space">  </span>Now, each MoreCondClause will be prefixed with "} else if " instead of only the first MoreCondClause having this prefix.<span class="Apple-converted-space">  </span>(See commit 49ee1506144edb8bbca68e796ad3b4a94cdcb318).</p>
<p class="p7"><br></p>
<p class="p6">Next, another named let, that I overlooked, is in "lookup".<span class="Apple-converted-space">  </span>I rewrote this manually, as before.</p>
<p class="p7"><br></p>
<p class="p6">It seems that the grammar does not handle LETs with no bindings.<span class="Apple-converted-space">  </span>This appears in my manual rewrite of<span class="Apple-converted-space">  </span>"print_frame_loop".<span class="Apple-converted-space">  </span>Putting in dummy bindings (_xx and _yy) solves the immediate problem.<span class="Apple-converted-space">  </span>Since this problem appears only in my rewrite, I choose not to repair the grammar (at this time).</p>
<p class="p7"><br></p>
<p class="p6">I created references to cd*r().</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Sweeping Changes</b></h2>
<p class="p6">In debugging support.js, I hit a variable scoping problem which looks like a JS problem</p>
<p class="p7"><br></p>
<p class="p6">The problem appears to go away if I use "let" instead of "var" in the transpiled code.</p>
<p class="p7"><br></p>
<p class="p6">This is one of the advantages of using the DSL approach.<span class="Apple-converted-space">  </span>This is a late change in strategy, but the fix is easy and all of the code is regenerated (transpiled).</p>
<p class="p7"><br></p>
<p class="p6">Now, node complains that "db" is defined more than one.<span class="Apple-converted-space">  </span>This is true - the original code in prolog-6.scm uses "db" as a global and relies on Lisp's ability to redefine variables as the code is loaded.<span class="Apple-converted-space">  </span>Possible solutions:<span class="Apple-converted-space"> </span></p>
<ol class="ol1">
  <li class="li2">alter the .scm code to create multiple variables with different names,<span class="Apple-converted-space"> </span></li>
  <li class="li2">allow multiple (define x …) statements and transpile them into variable assignments if the variable has already been defined (this would require making a table of top-level variables (globals), and checking it before emitting a top-level "let" definition, or<span class="Apple-converted-space"> </span></li>
  <li class="li2">?.</li>
</ol>
<p class="p7"><br></p>
<p class="p6">First, it seems prudent to remove the global variable and turn it into a function parameter.<span class="Apple-converted-space">  </span>This means going back to Scheme, checking that prolog-6.scm still runs, making the change to original Scheme code and seeing that it still gives the same answers…</p>
<p class="p7"><br></p>
<p class="p6">Running Scheme (mit-scheme) on my macbook produces the output:</p>
<p class="p7"><br></p>
<p class="p6">&gt; scheme</p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p10">1 ]=&gt; (load "prolog-6")</p>
<p class="p11"><br></p>
<p class="p10">;Loading "prolog-6.scm"...</p>
<p class="p10">p = (a f)</p>
<p class="p11"><br></p>
<p class="p10">p = (a b c d h f)</p>
<p class="p11"><br></p>
<p class="p10">p = (a b d h f)</p>
<p class="p11"><br></p>
<p class="p10">p = (a g h f)</p>
<p class="p11"><br></p>
<p class="p10">p = (a f)</p>
<p class="p11"><br></p>
<p class="p10">p = (a b c d h f)</p>
<p class="p11"><br></p>
<p class="p10">p = (a b d h f)</p>
<p class="p11"><br></p>
<p class="p10">p = (a g h f)</p>
<p class="p11"><br></p>
<p class="p10">y = bar</p>
<p class="p10">x = foo</p>
<p class="p11"><br></p>
<p class="p10">y = baz</p>
<p class="p10">x = foo</p>
<p class="p11"><br></p>
<p class="p10">y = foo</p>
<p class="p10">x = bar</p>
<p class="p11"><br></p>
<p class="p10">y = baz</p>
<p class="p10">x = bar</p>
<p class="p11"><br></p>
<p class="p10">y = foo</p>
<p class="p10">x = baz</p>
<p class="p11"><br></p>
<p class="p10">y = bar</p>
<p class="p10">x = baz</p>
<p class="p10">;... done</p>
<p class="p10">;Value: #t</p>
<p class="p11"><br></p>
<p class="p6">Next, I make a copy and remove the definitions for prove3 and prove5.<span class="Apple-converted-space">  </span>I remove the tests for prove3 and prove5.</p>
<p class="p7"><br></p>
<p class="p10">1 ]=&gt; (load "prolog-6a")</p>
<p class="p11"><br></p>
<p class="p10">;Loading "prolog-6a.scm"...</p>
<p class="p10">y = bar</p>
<p class="p10">x = foo</p>
<p class="p11"><br></p>
<p class="p10">y = baz</p>
<p class="p10">x = foo</p>
<p class="p11"><br></p>
<p class="p10">y = foo</p>
<p class="p10">x = bar</p>
<p class="p11"><br></p>
<p class="p10">y = baz</p>
<p class="p10">x = bar</p>
<p class="p11"><br></p>
<p class="p10">y = foo</p>
<p class="p10">x = baz</p>
<p class="p11"><br></p>
<p class="p10">y = bar</p>
<p class="p10">x = baz</p>
<p class="p10">;... done</p>
<p class="p10">;Value: #t</p>
<p class="p11"><br></p>
<p class="p6">That gets rid of the extra references to db.<span class="Apple-converted-space">  </span>Db is still a global and is used once in the "else" clause of prove6.<span class="Apple-converted-space">  </span>This use comes about because the pattern-matching "loop" needs to start from the beginning of the database.<span class="Apple-converted-space">  </span>The mutual recursion between loop6 and back6 is actually a nested set of loops and, deep in the nested loops, the algorithm needs to start matching rules against the whole database.<span class="Apple-converted-space">  </span>In this case, the recursion is a trick that covers up what is really going on<a id="fnlink27"></a><a href="#fn27"><span class="s4"><sup>[27]</sup></span></a> - loops nested in loops nested in loops<span class="Apple-converted-space">  </span>- recursion isn't actually needed, except to appease Scheme and allergy sufferers - those who think that "loop" is a four-letter word.<span class="Apple-converted-space">  </span>In mathematics(?) notation the algorithm would clearly show a nested set of for-all's<a id="fnlink28"></a><a href="#fn28"><span class="s4"><sup>[28]</sup></span></a> (<span class="s13">∀</span>).<span class="Apple-converted-space">  </span>I'll rewrite the algorithm more clearly, later.<span class="Apple-converted-space">  </span>For now, I'll pass "db" in as a parameter ("whole-db") while ensuring that it gets copied without change in prove6 and back6.<span class="Apple-converted-space">  </span>See commit 42e75c5499e8e0df65d49ba0b52eb521fc15f1dd.</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Quote List Expansion</b></h2>
<p class="p6">I've revamped the emitjs semantics to output "cons(…)" instead of "new List(…)".</p>
<p class="p7"><br></p>
<p class="p6">The quote list expansion is not fully correct.<span class="Apple-converted-space">  </span>A quoted list should be converted to "list(…)",<span class="Apple-converted-space">  </span>where list() inserts a null at the end of the list.</p>
<p class="p7"><br></p>
<p class="p6">See commit 9ba41fe9151d5bde775852f573f19de3fcc9e251.</p>
<p class="p7"><br></p>
<p class="p6">Note that this was anti-waterfall development, I made progress without needing to get everything right at first.<span class="Apple-converted-space">  </span>A placeholder was enough.<span class="Apple-converted-space">  </span>I fixed the error, then iterated.<span class="Apple-converted-space">  </span>Fixing the error was easy - a minor change to the .semantics() of the emitter.</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Let*</b></h2>
<p class="p6">The let* (LetSequential) emission is incorrect.<span class="Apple-converted-space">  </span>It needs to be transformed into sequential Lets.<span class="Apple-converted-space">  </span>There are at least 2 ways forward -<span class="Apple-converted-space"> </span></p>
<ol class="ol1">
  <li class="li2">fix LetSequential, or<span class="Apple-converted-space"> </span></li>
  <li class="li2">manually rewrite prolog-6a.scm to remove all let*s.</li>
</ol>
<p class="p7"><br></p>
<p class="p6">For now, let's take choice 2 (there is only one let* in prolog-6a.scm).</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Function Copy()</b></h2>
<p class="p6">The Copy() function is not being emitted correctly.</p>
<p class="p7"><br></p>
<p class="p6">The first clause returns "x" as an atom.<span class="Apple-converted-space">  </span>There is no "return" statement emitted.</p>
<p class="p7"><br></p>
<p class="p6">I will copy/paste it into my test-harness element and zero in on it.</p>
<p class="p7"><br></p>
<p class="p6">I pare the test case down to:</p>
<p class="p7"><br></p>
<p class="p10">(define (copy x n)</p>
<p class="p10"><span class="Apple-converted-space">  </span>(cond</p>
<p class="p10"><span class="Apple-converted-space">    </span>((not (pair? x)) x)))</p>
<p class="p11"><br></p>
<p class="p6">and look at "pass1 &amp; listConstants &amp; emitter tree".</p>
<p class="p7"><br></p>
<p class="p6">The parse tree is:</p>
<p class="p7"><br></p>
<p class="p10">(:Program<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space"> </span>(:GlobalFunctionDefinition<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">  </span>(:Identifier<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">   </span>(:symbol [[copy]] ))<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">  </span>(:Identifier<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">   </span>(:symbol [[x]] )),</p>
<p class="p10"><span class="Apple-converted-space">  </span>(:Identifier<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">   </span>(:symbol [[n]] ))<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">  </span>(:StatementBlock<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">   </span>(:SequentialStatement<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>(:LastStatement<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">     </span>(:Statement<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">      </span>(:Form<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">       </span>(:SList<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span>(:SpecialForm<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span> (:CondExpression<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>(:CondExpressionWithoutElse [toCL operation] )))))))))))</p>
<p class="p11"><br></p>
<p class="p6">I see 2 potential problems:<span class="Apple-converted-space"> </span></p>
<ol class="ol1">
  <li class="li2">there is a comma between the args "x" and "n" and<span class="Apple-converted-space"> </span></li>
  <li class="li2">the :CondExpressionWithoutElse is showing "[toCL operation]" instead of a value.</li>
</ol>
<p class="p7"><br></p>
<p class="p6">It looks like (1) was intentional, so I will focus on (2).</p>
<p class="p7"><br></p>
<p class="p6">CondClauseWithoutElse was missing () after firstCondClause.toCL.<span class="Apple-converted-space">  </span>This is in the toCL operation, so the actual problem has not been repaired, but may become more visible.</p>
<p class="p7"><br></p>
<p class="p6">Now, the parse tree is appears as:</p>
<p class="p7"><br></p>
<p class="p11"><br></p>
<p class="p10">(:Program<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space"> </span>(:GlobalFunctionDefinition<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">  </span>(:Identifier<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">   </span>(:symbol [[copy]] ))<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">  </span>(:Identifier<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">   </span>(:symbol [[x]] )),</p>
<p class="p10"><span class="Apple-converted-space">  </span>(:Identifier<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">   </span>(:symbol [[n]] ))<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">  </span>(:StatementBlock<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">   </span>(:SequentialStatement<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">    </span>(:LastStatement<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">     </span>(:Statement<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">      </span>(:Form<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">       </span>(:SList<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">        </span>(:SpecialForm<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">         </span>(:CondExpression<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">          </span>(:CondExpressionWithoutElse<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">           </span>(:FirstCondClause<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">            </span>(:CondClause<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">             </span>(:CondTest<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">              </span>(:Form<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">               </span>(:SList<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                </span>(:SpecialForm<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                 </span>(:NotExpression<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                  </span>(:Bool<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                   </span>(:Form<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                    </span>(:SList<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                     </span>(:FunctionCall<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                      </span>(:Identifier<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                       </span>(:symbol [[pair_Q_]] ))</p>
<p class="p10"><span class="Apple-converted-space">                      </span>(:Arg<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                       </span>(:ListItem<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                        </span>(:Atom<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                         </span>(:atom<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                          </span>(:symbol [[x]] ))))))))))))))<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">             </span>(:CondStatementBlock<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">              </span>(:StatementBlock<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">               </span>(:Atom<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                </span>(:atom<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-converted-space">                 </span>(:symbol [[x]] ))))))) )))))))))))</p>
<p class="p11"><br></p>
<p class="p6">[^ I put the output into emacs .lisp mode and pretty-printed it.]</p>
<p class="p7"><br></p>
<p class="p6">The problem appears to be that the grammar looks for "StatementBlock = Atom | SequentialStatement".<span class="Apple-converted-space">  </span>The grammar is over-specified.<span class="Apple-converted-space">  </span>I simply remove Atom and leave "StatementBlock = SequentialStatement".<span class="Apple-converted-space">  </span>This now leaves Atom to be parsed by Statement and takes its rightful place as a MidStatement or a LastStatement.</p>
<p class="p6">I've made the code simpler by removing code.<span class="Apple-converted-space">  </span>This is good.</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>MIssing Support Routines</b></h2>
<p class="p6">Append is missing.<span class="Apple-converted-space">  </span>I will write one in Scheme, called AppendInefficient, and replace all calls to Append by this - in the Scheme code.</p>
<p class="p7"><br></p>
<p class="p6">N.B. I am now <i>using</i> the Scheme to JS transpiler.<span class="Apple-converted-space">  </span>I will write AppendInefficient in Scheme and let the transpiler convert it to JS.<span class="Apple-converted-space">  </span>There are some interesting trade-offs to be had when the transpiler begins to work (even hobbling).<span class="Apple-converted-space">  </span>Should I write Append() in JS or in Scheme?<span class="Apple-converted-space">  </span>Or, should I rewrite it in PROLOG?<span class="Apple-converted-space">  </span>I'm not worried about efficiency (yet), and I am very comfortable writing Scheme.<span class="Apple-converted-space">  </span>Writing it in Scheme will allow me to debug the implementation in a working compiler - MIT-Scheme. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">Instead of dealing with varargs, I wrote AppendInefficient3 which is defined using AppendInefficient.<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">In a sense, I'm using Scheme as a meta-language…</p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Working</b></h2>
<p class="p6">Now, the full test is working (compared to the Scheme output for prolog-6a.scm).</p>
<p class="p7"><br></p>
<p class="p6">See commit 544c1d52c9278b1cb90724f6452408a8154fc750.</p>
<p class="p7"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Recap</b></h2>
<p class="p6">I now have the JS code for a PROLOG interpreter.<span class="Apple-converted-space">  </span>It consists of the support.js routines plus the output from our transpiler. <span class="Apple-converted-space"> </span></p>
<p class="p6">"Prove6" is the entry point.</p>
<p class="p6"><span class="Apple-converted-space"> </span>I need to create a database of facts, rules and, a database of goals.<span class="Apple-converted-space">  </span>I pass these to prove6() and it prints the results.</p>
<p class="p6">I need several simple things:</p>
<ol class="ol2">
  <li class="li2">Prove6() needs to return a list of answers instead of printing them out.</li>
  <li class="li2">A PROLOG-like syntax skin over JS, that converts PROLOG-like statements into databases and calls to prove6().<span class="Apple-converted-space">  </span>This is probably going to be another grammar (Ohm-JS).</li>
  <li class="li2">A way to combine chunks of PROLOG-like statements into JS.<span class="Apple-converted-space">  </span>Each chunk will be fed into the above PROLOG-to-JS transpiler and the result will be pasted back into the JS program.<span class="Apple-converted-space">  </span>When done, the final JS program will be fed to the JS compiler/interpreter.<span class="Apple-converted-space">  </span>In its simplest form this will involve calls to String.search() and String.split() (etc.).<span class="Apple-converted-space">  </span>Q: What do I do with the resulting JS code?<span class="Apple-converted-space">  </span>Can I overwrite &lt;script&gt; segments in the DOM?<span class="Apple-converted-space">  </span>Do I generate another .html page with new &lt;script&gt;…&lt;/script&gt; segments?<span class="Apple-converted-space">  </span>Do I generate a .JS file and feed it to node.js? The ideal would be a page, an .html file, that contains the mixed PROLOG and JS script, which invisibly transpiles the code and runs and produces a result.<span class="Apple-converted-space">  </span>[This is the "hard part" for me.<span class="Apple-converted-space">  </span>I don't yet have enough JS and HTML experience.<span class="Apple-converted-space">  </span>Grammars are the "easy part" for me:-].</li>
</ol>
<p class="p5"><br></p>
<p class="p2">I will address point (a) and leave (b) and (c) for other essays.<a id="fnlink29"></a><a href="#fn29"><span class="s4"><sup>[29]</sup></span></a></p>
<p class="p5"><br></p>
<p class="p5"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Transpiling to Other Languages</b></h2>
<p class="p6">I claim that the transpiler can be modified to emit the code in other languages.</p>
<p class="p7"><br></p>
<p class="p6">All that is necessary is to write a new<span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p10"><span class="Apple-converted-space">      </span>emitter_semantics.addOperation(</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-converted-space">  </span>'emit???',</p>
<p class="p10">…</p>
<p class="p10">);</p>
<p class="p11"><br></p>
<p class="p6">I don't plan to prove this assertion and to show how it would be done, in this essay.<span class="Apple-converted-space">  </span>By now, it should be clear how to do this.<a id="fnlink30"></a><a href="#fn30"><span class="s4"><sup>[30]</sup></span></a></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Returning a List of Answers</b></h2>
<p class="p6">As it stands, prolog6 prints every answer (a successful match) in the function print-frame.</p>
<p class="p7"><br></p>
<p class="p6">I want to collect the answers into a list and return it, instead of printing it.</p>
<p class="p7"><br></p>
<p class="p6">I have a number of choices in how to do this.</p>
<p class="p7"><br></p>
<p class="p6">The first choice is whether the return will be a Cons() list or something more amenable to<span class="Apple-converted-space">  </span>JS - an array, for example.<span class="Apple-converted-space">  </span>The code generated by the transpiler will be used in JS programs.<span class="Apple-converted-space">  </span>The better choice seems to be that of returning a JS Array.</p>
<p class="p6">The PROLOG code creates a Cons() list, though.<span class="Apple-converted-space">  </span>Returning a Cons() list will be easier.<span class="Apple-converted-space">  </span>Easy wins - I can always write a toArray method for Cons() - later.</p>
<p class="p7"><br></p>
<p class="p6">The next choice is how to accumulate the result.<span class="Apple-converted-space">  </span>The most obvious answer is to accumulate the result in some sort of global variable.<span class="Apple-converted-space">  </span>Alternately, I can accumulate the result in an accumulator list that is passed to prove6 and everything it calls.</p>
<p class="p6">Again, "easy" wins out - I will choose to use a global variable.</p>
<p class="p6">Rhetorical question, for discussion - when is it OK to use a global instead of using an accumulator parameter?<span class="Apple-converted-space">  </span>For discussion:<span class="Apple-converted-space"> </span></p>
<ul class="ul2">
  <li class="li2">using parameters instead of globals evolved as a protectionist strategy when text-only code was used. <span class="Apple-converted-space"> </span></li>
  <li class="li2">Further: using parameters instead of globals evolved as a protectionist strategy when code "freezing" was not possible - e.g. when the programmer doesn't know how the code will be used. <span class="Apple-converted-space"> </span></li>
  <li class="li2">Further: using parameters instead of globals evolved in an environment where the only tools &amp; languages available could cause subtle changes to behaviour. <span class="Apple-converted-space"> </span></li>
  <li class="li2">Further: the use of parameters instead of globals converts globals into scoped parameters, to reduce the "problem" - the "problem" being that globals don't necessarily fit in an eye-full, whereas it is hoped that parameters do fit in an eye-full ; global variables are removed from the global scope and are moved into local scope.<span class="Apple-converted-space">  </span>The concept of modules solved this problem by wrapping "global variables" into modules.<span class="Apple-converted-space">  </span>OO was, essentially, a riff on this theme - modules became objects that could be instantiated at runtime. <span class="Apple-converted-space"> </span></li>
  <li class="li2">Further: isn't the real problem one of freezing known-to-be-working code instead of a problem of scoping?</li>
</ul>
<p class="p7"><br></p>
<p class="p6">Divide &amp; conquer - I choose to ignore the issue and proceed using the "least change" principal - i.e. the design is working, change as little code as possible.<span class="Apple-converted-space">  </span>Let Maintenance Engineering worry about this issue.<span class="Apple-converted-space">  </span>Can CI tools help us detect future problems?<span class="Apple-converted-space">  </span>(That is the claim :-).</p>
<p class="p7"><br></p>
<p class="p6">Next choice - do I make the change in JS or in Scheme?<span class="Apple-converted-space">  </span>I am treating Scheme as my meta-language.<span class="Apple-converted-space">  </span>Every change I make in Scheme will be reflected in the transpiled code, even when it is transpiled to something other than JS.<span class="Apple-converted-space">  </span>If I make the change in JS, then only the JS version has the fix and I will need to make the change in every target language.<span class="Apple-converted-space">  </span>This is the same issue that HLLs solved - one could write code in a meta-language (e.g. C) and have it be compiled to many various assembly languages.<span class="Apple-converted-space">  </span>Over time, we learned how to "standardize" languages so that they were more portable across target architectures.<span class="Apple-converted-space">  </span>An example of a successful standard is the Common Lisp standard - Cltl2.<span class="Apple-converted-space">  </span>An example of an evolving standard is the ECMAscript standards for JavaScript.</p>
<p class="p7"><br></p>
<p class="p6">So, my immediate goals are:</p>
<ul class="ul2">
  <li class="li2">collect answers in a Cons() list</li>
  <li class="li2">use a global variable as the top-level accumulator of a list of answers</li>
  <li class="li2">do all of this in Scheme - in prolog-6a.scm. <span class="Apple-converted-space"> </span></li>
</ul>
<p class="p5"><br></p>
<p class="p2">The only remaining question is whether I need to make copies of the Cons() list answers.<span class="Apple-converted-space">  </span>I will defer this issue until I see good or broken results ; I have used Cons() lists in Lisp without needing to make copies, and I expect this to be the case here.</p>
<p class="p5"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Accumulator in print-frame</b></h2>
<p class="p6">It turns out the Scheme and the way that the code is written, makes it easy to use an accumulator in print-frame (and print-frame-loop)</p>
<p class="p7"><br></p>
<p class="p6">The accumulator is intialized to '() in the top call to print-frame.<span class="Apple-converted-space">  </span>Successive calls to print-frame-loop either<span class="Apple-converted-space"> </span></p>
<ul class="ul2">
  <li class="li2">pass the accumulator unchanged, or,<span class="Apple-converted-space"> </span></li>
  <li class="li2">cons a result onto the accumulator. <span class="Apple-converted-space"> </span></li>
</ul>
<p class="p6">The bottom-most call to print-fame-loop simply returns the accumulator.</p>
<p class="p7"><br></p>
<p class="p6">Wiring an accumulator into prove6 requires some non-local changes - all calls to prove6() need to be altered, and, back6() needs to be altered, and all calls to back6() need to be altered. <span class="Apple-converted-space"> </span></p>
<p class="p7"><br></p>
<p class="p6">Discussion:<span class="Apple-converted-space"> </span></p>
<ul class="ul2">
  <li class="li2">If proves6() were written as a nested set of loops, locality would have been "better".<span class="Apple-converted-space">  </span>The goal of PROLOG is a one-off problem - stop after every answer and let the user decide whether more answers are wanted.<span class="Apple-converted-space">  </span>Discussion: should all of the code be affected by this one-off problem?<span class="Apple-converted-space">  </span>Should the solution be first described in its simplest form (a set of nested loops), and show points where user interaction is required?<span class="Apple-converted-space">  </span>If I had infinitely fast hardware, I would simply generate all of the answers, then print them out (in a REPL) one by one.<span class="Apple-converted-space">  </span>Everything beyond this is an optimization.<span class="Apple-converted-space">  </span>Clouding the DI<a id="fnlink31"></a><a href="#fn31"><span class="s4"><sup>[31]</sup></span></a> with optimization details is something I dislike.<span class="Apple-converted-space">  </span>Optimization is a valid concern, but should not be tangled up with DI.</li>
  <li class="li2">The PROLOG "problem" breaks down (divide&amp;conquer) into two sub-problems
  <ul class="ul1">
    <li class="li2">find all solutions</li>
    <li class="li2">allow the user to ask for solutions one by one.</li>
  </ul></li>
</ul>
<ul class="ul2">
  <li class="li2">Paul Graham<a id="fnlink32"></a><a href="#fn32"><span class="s4"><sup>[32]</sup></span></a> and Peter Norvig<a id="fnlink33"></a><a href="#fn33"><span class="s4"><sup>[33]</sup></span></a> went to great lengths to show optimized solutions to the PROLOG problem, essentially using CPS<a id="fnlink34"></a><a href="#fn34"><span class="s4"><sup>[34]</sup></span></a>.<span class="Apple-converted-space">  </span>Their code is very complicated and imparts a mystical property to their books.</li>
</ul>
<ul class="ul2">
  <li class="li2">At what point does the cognitive load get so large that using an accumulator makes the code no clearer?<span class="Apple-converted-space">  </span>As a <i>maintainer</i>, I want to make as few changes as possible - using a global variable to "cross-cut" prove6 and back6 makes sense from this perspective (back6 doesn't even use the accumulator), but, as a <i>designer</i>, I might want to describe the algorithm in terms of an accumulator and would be happy to wire it into prove6 and back6.
  <ul class="ul1">
    <li class="li2">The mutual recursion between prove6 and back6 is a code-driven, non-natural split, but, the if emphasis is on showing how backtracking works, is this split needed?</li>
  </ul></li>
  <li class="li2">The original intent of Nils Holm's paper (and code) was to show how backtracking in PROLOG works.<span class="Apple-converted-space">  </span>"Back6()" shows the backtracking and "prove6()" calls it at the appropriate points.<span class="Apple-converted-space">  </span>When "prove6()" finds an answer, it calls "print-frame()", then backtracks to find more answers.<span class="Apple-converted-space">  </span>I, firstly, want to find <i>all</i> of the answers.<span class="Apple-converted-space">  </span>Later, I might want to cut the PROLOG behaviour in - which is: stop after any answer is found, let the user choose whether more answers are wanted.</li>
  <li class="li5"><br></li>
</ul>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Deeper</b></h2>
<p class="p22"><span class="s2">Chapter 2 contains a good overview of Ohm:</span></p>
<p class="p23"><span class="s2"></span><br></p>
<p class="p8"><span class="s2"><a href="https://escholarship.mcgill.ca/concern/theses/j67316286">https://escholarship.mcgill.ca/concern/theses/j67316286</a></span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">OMeta: an Object-Oriented Language for Pattern Matching</span></p>
<p class="p8"><span class="s2"><a href="http://www.tinlizzie.org/~awarth/papers/dls07.pdf">http://www.tinlizzie.org/~awarth/papers/dls07.pdf</a></span></p>
<p class="p8"><span class="s2">(N.B. Ohm is not OMeta, but Ohm is a descendant of OMeta</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space"> </span>N.B. Ohm only understands how to parse characters</span></p>
<p class="p8"><span class="s2"><span class="Apple-converted-space"> </span>N.B. Ohm breaks semantics and grammar apart, whereas OMeta expects semantics to be a part of the grammar description)</span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">OMeta: PhD Thesis</span></p>
<p class="p8"><span class="s2"><a href="http://www.vpri.org/pdf/tr2008003_experimenting.pdf">http://www.vpri.org/pdf/tr2008003_experimenting.pdf</a></span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">OMeta website</span></p>
<p class="p8"><span class="s2"><a href="http://www.tinlizzie.org/ometa/">http://www.tinlizzie.org/ometa/</a></span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">Ohm examples</span></p>
<p class="p8"><span class="s2"><a href="https://cs.lmu.edu/~ray/notes/ohmexamples/">https://cs.lmu.edu/~ray/notes/ohmexamples/</a></span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">Ohm github:</span></p>
<p class="p8"><span class="s2"><a href="https://github.com/harc/ohm">https://github.com/harc/ohm</a></span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">article: Making your own programming language with NodeJS</span></p>
<p class="p8"><span class="s2"><a href="https://repl.it/talk/learn/Making-your-own-programming-language-with-NodeJS/45779">https://repl.it/talk/learn/Making-your-own-programming-language-with-NodeJS/45779</a></span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">Repl.it:</span></p>
<p class="p8"><span class="s2"><a href="https://repl.it/">https://repl.it/</a></span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">Ohm paper (and how it differs from OMeta):</span></p>
<p class="p8"><span class="s2"><a href="https://ohmlang.github.io/pubs/dls2016/modular-semantic-actions.pdf">https://ohmlang.github.io/pubs/dls2016/modular-semantic-actions.pdf</a></span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">PubNub blogs about Ohm</span></p>
<p class="p8"><span class="s2">1. <a href="https://www.pubnub.com/blog/javascript-parser-ohm-makes-creating-a-programming-language-easy/">https://www.pubnub.com/blog/javascript-parser-ohm-makes-creating-a-programming-language-easy/</a></span></p>
<p class="p8"><span class="s2">2.<span class="Apple-converted-space">  </span>(includes toAST): <a href="https://www.pubnub.com/blog/build-your-own-symbol-calculator-with-ohm/">https://www.pubnub.com/blog/build-your-own-symbol-calculator-with-ohm/</a></span></p>
<p class="p8"><span class="s2">3. (Meow language): <a href="https://www.pubnub.com/blog/add-code-blocks-conditionals-to-ohm/">https://www.pubnub.com/blog/add-code-blocks-conditionals-to-ohm/</a></span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">writing a compiler (incl. toAST):</span></p>
<p class="p8"><span class="s2"><a href="https://cs.lmu.edu/~ray/notes/writingacompiler/">https://cs.lmu.edu/~ray/notes/writingacompiler/</a></span></p>
<p class="p24"><span class="s2"></span><br></p>
<p class="p8"><span class="s2">A Compiler for Ael</span></p>
<p class="p8"><span class="s2">(good introduction - a bit of everything including code generators for JS, C and ASM):</span></p>
<p class="p8"><span class="s2"><a href="https://cs.lmu.edu/~ray/notes/aelcompiler/">https://cs.lmu.edu/~ray/notes/aelcompiler/</a></span></p>
<p class="p9"><span class="s3"></span><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Ideas</b></h2>
<h2 style="margin: 13.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino"><b>IDEAS</b></h2>
<p class="p6">Ohm-JS does not parse anything but single characters.</p>
<p class="p7"><br></p>
<p class="p6">In an ideal situation, we would want to parse "tokens".</p>
<p class="p7"><br></p>
<p class="p6">Tokens would provide:</p>
<p class="p7"><br></p>
<ul class="ul2">
  <li class="li2">separation between Syntactic entities - when we ignore spaces, we would still have (delimited) tokens, for example, in the scanner pass (the very first pass), we would recognize identifiers.<span class="Apple-converted-space">  </span>If we had tokens, the scanner would emit 3 tokens for: abc&lt;space&gt;def - token(identifier, "abc"), token(spaces," "), token(identifier, "def").<span class="Apple-converted-space">  </span>In later passes, we could ignore spaces and still see distinct identifiers, e.g. token(identifier,"abc"), token(identifier,"def").<span class="Apple-converted-space">  </span>In the current version of Ohm-JS, the string abc&lt;space&gt;def is recognized as a single token, when spaces are ignored, e.g. "abcdef".<span class="Apple-converted-space">  </span>Maybe this problem just needs more thought…</li>
  <li class="li2">extra information, such as line#, character position and filename, e.g. token(identifier, "abc", line=10, startPosition="3", filename="sample.txt").</li>
</ul>
<p class="p5"><br></p>
<p class="p2">The above could be accomplished by using distinguished strings, for example "!!!&lt;token identifier abc … !!!&gt;".<span class="Apple-converted-space">  </span>The "problem" with this solution is that strings are not terminals and, hence, there is no automatic backtracking.</p>
<p class="p2">Maybe we could use Unicode characters instead of distinguished strings?<span class="Apple-converted-space">  </span>For example "† identifier abc … ®".<span class="Apple-converted-space">  </span>JS purportedly supports unicode characters, so, in theory, Ohm-JS should be able to parse them, with backtracking.<span class="Apple-converted-space">  </span>Is this worth it?<span class="Apple-converted-space">  </span>Maybe the whole issue is moot?</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Errata</b></h2>
<p class="p6">Nov. 6, 2020:<span class="Apple-converted-space"> </span></p>
<p class="p6">It turns out that the final version of the prolog transpiler was broken.<span class="Apple-converted-space">  </span>The error was in the hand-rewritten code for print-frame (a parenthesis was off-by-one).</p>
<p class="p6">I re-examined the original prolog-6.scm and rewrote it (in Scheme) as a simple recursive function that did not used Scheme's named let feature.<span class="Apple-converted-space">  </span>In the process, I lifted as many implementation details out and put them into auxiliary functions.</p>
<p class="p6">The result appears to work, is in branch "main" commit 70989e3333021327b472f56a548a6e81c8abcbca, in <a href="https://github.com/guitarvydas/OhmSmallSteps">https://github.com/guitarvydas/OhmSmallSteps</a>.</p>
<p class="p6">To run it, simply execute</p>
<p class="p11"><br></p>
<p class="p10">./run.bash</p>
<p class="p7"><br></p>
<p class="p6">in the OhmSmallSteps directory.<span class="Apple-converted-space">  </span>This should create a file j<span class="s4">unk.js</span> by concatenating <span class="s4">support.js</span> and <span class="s4">prolog-6.js</span>.<span class="Apple-converted-space">  </span>The script then runs<span class="Apple-converted-space"> </span></p>
<p class="p11"><br></p>
<p class="p10">node junk.js</p>
<p class="p7"><br></p>
<p class="p6">which should print the final set of matches as bindings to X and Y:</p>
<p class="p7"><br></p>
<p class="p10">(((X . baz)<span class="Apple-converted-space">  </span>(Y . bar))<span class="Apple-converted-space">  </span>((X . baz)<span class="Apple-converted-space">  </span>(Y . foo))<span class="Apple-converted-space">  </span>((X . bar)<span class="Apple-converted-space">  </span>(Y . baz))<span class="Apple-converted-space">  </span>((X . bar)<span class="Apple-converted-space">  </span>(Y . foo))<span class="Apple-converted-space">  </span>((X . foo)<span class="Apple-converted-space">  </span>(Y . baz))<span class="Apple-converted-space">  </span>((X . foo)<span class="Apple-converted-space">  </span>(Y . bar)))</p>
<p class="p7"><br></p>
<p class="p6">To re-create "prolog-6.js" and watch the transpiler transpile the Scheme code, load "index.html" in a browser (I used Chrome) and hit the "emit JavaScript" button.<span class="Apple-converted-space">  </span>This should produce JavaScript code in the browser.<span class="Apple-converted-space">  </span>Copy the code and paste it into a file or <span class="s4">prolog-6.js</span>.<span class="Apple-converted-space">  </span>The transpiled Javascript should have no differences with the file <span class="s4">prolog-6.js</span> found in the above-mentioned git repository.</p>
<p class="p6">The Javascript in <span class="s4">support.js</span> and <span class="s4">prolog-6.js</span> forms the basis for new, follow-on, work in <span class="s4">../js-match</span>.</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Addendum - Foreign Call</b></h2>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Addendum - Rewrite MAP</b></h2>
<hr>
<p class="p2"><a id="fn1"></a><a href="#fnlink1"><span class="s4">[1]</span></a><span class="s4"> </span>The "- -" annotation is syntactic sugar provided by Ohm, to help with conformance of Arities.<span class="Apple-converted-space">  </span>There are two rules in "matchingBraces", the first has Arity 3 ('"{" matchingBraces "}"' has 3 matches) and the second has Arity 1 ("innards" is a single match).<span class="Apple-converted-space">  </span>The "- -" notation automagically splits its branch off into a sub-rule called matchingBraces_braces.<span class="Apple-converted-space">  </span>The sub-rule "matchingBraces_braces" has Arity 3, but the alternate in "matchingBraces" has Arity 1 (after the split).<span class="Apple-converted-space">  </span>After this split, all alternates of "matchingBraces" have Arity 1 and Ohm-js is happy.</p>
<p class="p26"><span class="s14"><a id="fn2"></a><a href="#fnlink2"><span class="s4">[2]</span></a></span><span class="s4"> </span>and understandable / maintainable</p>
<p class="p26"><a id="fn3"></a><a href="#fnlink3"><span class="s4">[3]</span></a><span class="s4"> </span>I haven't figured out how to split them across files, yet.</p>
<p class="p26"><a id="fn4"></a><a href="#fnlink4"><span class="s4">[4]</span></a><span class="s4"> </span>Where "&lt;…&gt;" is the filename in quotes.</p>
<p class="p26"><a id="fn5"></a><a href="#fnlink5"><span class="s4">[5]</span></a><span class="s4"> </span>Where "nn" is an integer line number.</p>
<p class="p27"><a id="fn6"></a><a href="#fnlink6"><span class="s4">[6]</span></a><span class="s4"> </span>Design Intent - see another of my essays.</p>
<p class="p27"><a id="fn7"></a><a href="#fnlink7"><span class="s4">[7]</span></a><span class="s4"> </span>The Elements are created by the 'elt' function.<span class="Apple-converted-space">  </span>The first parameter to 'elt()' is always an element id, which always corresponds to one of the rules in the grammar.<span class="Apple-converted-space">  </span>The rest of the arguments are sub-trees.</p>
<p class="p26"><a id="fn8"></a><a href="#fnlink8"><span class="s4">[8]</span></a><span class="s4"> </span>A more recent technology is miniKanren.<span class="Apple-converted-space">  </span>Once one learns to think in miniKanren, the possibilities become fantastic and weird very quickly.<span class="Apple-converted-space">  </span>See Barliman and <a href="https://www.youtube.com/watch?v=er_lLvkklsk"><span class="s10">https://www.youtube.com/watch?v=er_lLvkklsk</span></a><span class="s10">.</span></p>
<p class="p26"><span class="s10"><a id="fn9"></a><a href="#fnlink9"><span class="s15">[9]</span></a></span><span class="s16"> </span>Or, maybe there is a core.logic miniKanren library for JS?</p>
<p class="p26"><a id="fn10"></a><a href="#fnlink10"><span class="s4">[10]</span></a><span class="s4"> </span>See <a href="https://www.t3x.org/bits/prolog6.html"><span class="s17">https://www.t3x.org/bits/prolog6.html</span></a></p>
<p class="p28"><span class="s1"><a href="https://www.t3x.org/bits/prolog6.html"><a id="fn11"></a></a><a href="#fnlink11"><span class="s18">[11]</span></a><a href="https://www.t3x.org/bits/prolog6.html"><span class="s18"> </span></a></span><span class="s19">Ya Ain't Gonna Need It</span></p>
<p class="p26"><a id="fn12"></a><a href="#fnlink12"><span class="s4">[12]</span></a><span class="s4"> </span>a list of 3 items: (QUOTE A), the value of B, and, (QUOTE C).</p>
<p class="p26"><a id="fn13"></a><a href="#fnlink13"><span class="s4">[13]</span></a><span class="s4"> </span>N.B. OO does not do this - it does not freeze the code.<span class="Apple-converted-space">  </span>Inheritance and overriding can change the meaning of the original code.</p>
<p class="p26"><a id="fn14"></a><a href="#fnlink14"><span class="s4">[14]</span></a><span class="s4"> </span>DRY is a detail that should be ignored until later - during Maintenance Engineering.<span class="Apple-converted-space">  </span>Parser technology shows how RY can be used to advantage during the Design phase.</p>
<p class="p26"><a id="fn15"></a><a href="#fnlink15"><span class="s4">[15]</span></a><span class="s4"> </span>and a bit of semantics</p>
<p class="p26"><a id="fn16"></a><a href="#fnlink16"><span class="s4">[16]</span></a><span class="s4"> </span>https://www.amazon.ca/Framing-Software-Reuse-Lessons-1996-08-05/dp/B01K17JFS4/ref=sr_1_1?dchild=1&amp;keywords=framing+software+reuse&amp;qid=1600651776&amp;sr=8-1</p>
<p class="p26"><a id="fn17"></a><a href="#fnlink17"><span class="s4">[17]</span></a><span class="s4"> </span>N.B for purists: Lisp intentionally does not specify an order for argument evaluation, so it is OK to let the JS compiler pick any order of evaluation.<span class="Apple-converted-space">  </span>If this were not the case, I would have to add more code to ensure that arguments are evaluated in a specific order.<span class="Apple-converted-space">  </span>If you don't understand the previous statement, don't worry.</p>
<p class="p26"><a id="fn18"></a><a href="#fnlink18"><span class="s4">[18]</span></a><span class="s4"> </span>N.B. for purists: Lisp thinks that Booleans are NIL and anything-that-isn't NIL.<span class="Apple-converted-space">  </span>Scheme reserves #f and #t for false and true, resp.</p>
<p class="p26"><a id="fn19"></a><a href="#fnlink19"><span class="s4">[19]</span></a><span class="s4"> </span>If you didn't notice, I've just explained how CPS (Continuation Passing Style) works.<span class="Apple-converted-space">  </span>CPS is the ultimate GOTO.</p>
<p class="p26"><a id="fn20"></a><a href="#fnlink20"><span class="s4">[20]</span></a><span class="s4"> </span>Actually, humans have no business looking at the emitted code.<span class="Apple-converted-space">  </span>We don't normally look at the assembly code emitted.<span class="Apple-converted-space">  </span>We used to look at the emitted assembler, but that urge has gone away, as compilers have gotten to be really good.<span class="Apple-converted-space">  </span>Over time, I expect that no one will care to look at the code emitted by transpilers, such as this.</p>
<p class="p26"><a id="fn21"></a><a href="#fnlink21"><span class="s4">[21]</span></a><span class="s4"> </span>N.B. This is, again, a place where I'm using the parser to parse similar phrases, but categorize them to tell me how to emit code them. "Arg" is only another way of saying "ListItem", but is emitted differently in the .semantics() portion.</p>
<p class="p26"><a id="fn22"></a><a href="#fnlink22"><span class="s4">[22]</span></a><span class="s4"> </span>Currently, multi-tasking is considered "hard",<span class="Apple-converted-space">  </span>Most of the problem is due to Accidental Complexity - the use of Time-Sharing (a hard problem) and the idea that memory needs to be shared.<span class="Apple-converted-space">  </span>Both of these are based on old-fashioned criteria that have little to do with generalized multi-tasking.</p>
<p class="p26"><a id="fn23"></a><a href="#fnlink23"><span class="s4">[23]</span></a><span class="s4"> </span>S/SL has this property, too.</p>
<p class="p26"><a id="fn24"></a><a href="#fnlink24"><span class="s4">[24]</span></a><span class="s4"> </span>This looks like an opportunity for automation.<span class="Apple-converted-space">  </span>I shouldn't have to worry about matching the semantics to the grammar.<span class="Apple-converted-space">  </span>This matching should be automated…</p>
<p class="p26"><a id="fn25"></a><a href="#fnlink25"><span class="s4">[25]</span></a><span class="s4"> </span>the readability vs. writability conundrum</p>
<p class="p26"><a id="fn26"></a><a href="#fnlink26"><span class="s4">[26]</span></a><span class="s4"> </span>&gt; node prolog6.js</p>
<p class="p26"><a id="fn27"></a><a href="#fnlink27"><span class="s4">[27]</span></a><span class="s4"> </span>Nils intended to break backtracking out, and used mutual recursion to clearly show the backtracking.<span class="Apple-converted-space">  </span>My analysis might be unfair.</p>
<p class="p26"><a id="fn28"></a><a href="#fnlink28"><span class="s4">[28]</span></a><span class="s4"> </span>In fact, the inner-most loop would have to contain a "stop and wait for go-ahead from user" statement (which doesn't exist in any language, at present) and would continue looping or break out of looping, depending on the user's command.</p>
<p class="p26"><a id="fn29"></a><a href="#fnlink29"><span class="s4">[29]</span></a><span class="s4"> </span>Or as exercises for the reader :-)</p>
<p class="p26"><a id="fn30"></a><a href="#fnlink30"><span class="s4">[30]</span></a><span class="s4"> </span>If not, I haven't done my job of explaining things.<span class="Apple-converted-space">  </span>Contact me.</p>
<p class="p27"><a id="fn31"></a><a href="#fnlink31"><span class="s4">[31]</span></a><span class="s4"> </span>Design Intent</p>
<p class="p27"><a id="fn32"></a><a href="#fnlink32"><span class="s4">[32]</span></a><span class="s4"> </span>http://www.paulgraham.com/onlisp.html</p>
<p class="p27"><a id="fn33"></a><a href="#fnlink33"><span class="s4">[33]</span></a><span class="s4"> </span>https://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910/ref=sr_1_1?dchild=1&amp;keywords=paradigms+of+artificial+intelligence&amp;qid=1600610453&amp;s=books&amp;sr=1-1</p>
<p class="p27"><a id="fn34"></a><a href="#fnlink34"><span class="s4">[34]</span></a><span class="s4"> </span>Continuation Passing Style</p>
</div>
</body>
</html>
