## TL;DR

I'm developing a cutting-edge tool that leverages ChatGPT to ghost-write prose based on my point-form outlines, particularly focusing on 'new ideas' that the AI wasn't trained on. The challenge lies in preventing hallucinations and incorrect extrapolations from the outline. Early experimental results have been promising prompting me to create a dedicated workflow tool. This tool enables me to swiftly input point-form outlines, using the user-friendly Kinopio platform for brainstorming. I then paste the outline to ChatGPT, transforming it into coherent and readable prose. Join me in revolutionizing idea development and content creation with this innovative solution!
## Method
1. I created a brainstorm in Kinopio about a single topic, containing only 7 point-form notes.
2. I re-typed the brainstorm in markdown format into a .md file.
3. I fed the .md file to ChatGPT and received a response that looks reasonable.

## BRAINSTORMING:
I Use Kinopio to capture ideas in point form:
![control flow is not data](/screenshots/Screenshot 2023-10-30 at 4.31.58 AM.png)

## Interacting With My Ghost Writer ChatGPT 

I pasted text into ChatGPT's chat window.  The sections labelled "PROMPT:" are what I typed in.  The sections labelled "REPONSE:" are responses generated by ChatGPT.
### PROMPT: 
summarize the following markdown as a subsection for a chapter in a book

### RESPONSE: 

I'd be happy to help you summarize the content, but it seems like you haven't provided the specific Markdown content you'd like me to summarize. Please paste the content you want summarized, and I'll assist you in creating a subsection for a chapter in a book based on that content.

### PROMPT:
*[I manually created this file, using the above Kinopio brainstorm as a guide]*

control flow is not data
- control flow is _interpretation_ of data - dynamic flow
    - a CPU is an interpreter
        - a CPU interprets _opcodes_
        - a CPU interprets _opcodes_ so quickly that we think of it as something other than interpretation
- data is _static_ - and is not interpreted by the underlying system
    - static data is interpreted by the _program_, not the CPU

### REPONSE:
**Chapter Subsection: Control Flow and Data Interpretation**

In this subsection, we explore the fundamental distinction between control flow and data in the context of computing. 

**Control Flow Is Not Data**

Control flow is a crucial aspect of computational systems, but it differs significantly from data. Control flow involves the dynamic interpretation of data to direct the execution of a program. In essence, it is the decision-making process that determines which steps the computer should take next.

**Control Flow as Interpretation of Data**

Control flow can be best understood as the interpretation of data, giving rise to a dynamic flow of instructions. Much like a conductor guiding an orchestra, the Central Processing Unit (CPU) is the interpreter of these instructions in a computer system.

- **The CPU as an Interpreter:** A CPU serves as the chief interpreter in a computing system. It deciphers and executes the low-level instructions known as opcodes. These opcodes are the elemental commands that drive the CPU's operations.

- **Swift Interpretation:** CPUs interpret opcodes so rapidly that it often appears as if they are not interpreting at all. This blistering speed can lead us to perceive the CPU's actions as something other than interpretation, concealing the underlying intricacies of control flow.

**Data Is Static and Program-Interpreted**

In contrast to control flow, data is inherently static and is not directly interpreted by the underlying hardware. Instead, data interpretation is primarily carried out by the software program itself.

- **Static Nature of Data:** Data remains relatively unchanging and does not actively participate in the dynamic decision-making processes that control flow orchestrates.

- **Program-Driven Data Interpretation:** It is the responsibility of the software program to interpret and manipulate data. The program determines how data is accessed, processed, and used, bringing a level of predictability and consistency to the handling of information.

Understanding this distinction between control flow and data is fundamental in the realm of computer science, as it lays the groundwork for comprehending how computers execute instructions and manage data effectively.

## Next Step
I am building a tool to convert Kinopio tree drawings into markdown format.

## Appendix: Background
I believe that there should be a distinction between the concepts of *data* and *control flow*.  Control flow is the *interpretation* of *data*.  *Data*, itself is static.  A CPU *interprets* data - opcodes.

I am struggling, trying to find the right words to explain this distinction.

I like to write in point-form.  

I believe that an *idea* is more important than a particular realization of that idea.  
I believe in the concept of *showing your work* and the *scientific method* ("fail fast" - brutal truthiness about whether the idea worked or failed).  To this end, I publish *ideas* and show the *experiments* that support the ideas.  Typically, very little of my code is directly usable, except, maybe, by someone who is inspired by the idea and wants to further riff on the idea.

I tend not to go back and edit my point-form notes.  In essence, I want "someone" to re-cast my notes into prose.  In the past, one would employ editors and ghost-writers.  I am exploring the concept of using ChatGPT to ghost-write prose from my notes.  

Thus far, the indications are positive.  ChatGPT ingests my 7-point note - in markdown format - and generates reasonable prose, suitable to use as a  subsection of a chapter in a book, or, as an essay on a blog.

## Appendix: Future 1
I am building a pipeline - in drawware/0D - to take raw JSON exported from Kinopio and to  convert it to point-form notes in markdown format.

The pipeline uses JavaScript, Python, PROLOG (swipl), draw.io, OhmJS, RWR, and, odin0d.

Thus far, the pipeline converts JSON from Kinopio into a PROLOG factbase.  I manually copy/paste the factbase into a PROLOG program `md.pl` and then run the program using the commands:
```
swipl
consult(md).
main.
```

The next step will be modifying the `main` diagram in `top.drawio` to glue the generated factbase and `md.pl` together, then, shelling-out to *swipl* to generate the markdown point-form text[^oct31].

[^oct31]: update: 2023/10/31 `top.drawio` has been modified.  Now, making the project, using `make`, ingests `softwareAtomsTest.json` and spits out markdown.  commit 19916ad06b0c01cffe53ff0496dac044a478b1a7

## Appendix: Future 2
I am playing with `Khoj` to see if I can AI-generate reasonable responses on my local machine without moving my data off of my local machine.

This certainly seems to generate prose more slowly (tens of minutes, instead of seconds) than ChatGPT, but, holds some promise.
## Appendix: Code Repo

[kinopio2md](https://github.com/guitarvydas/kinopio2md)

This is a stand-alone repo that contains all of `odin0d` and `top.drawio` (the diagram of my pipeline).

## Appendix: How Does This All Fit In With My Other Projects?
- RT
- odin0d
- find-and-replace
- transpiler
- OhmJS
- RWR
- Ceptre
- Software Atoms
- Behavior Trees
- Blogging and Book Writing
- Code Commenting
- OPL - Orthogonal Programming Languages
- Golf
- Software Simplicity

- RT
	- RT - Recursive Text - is the pursuit of a common syntax for all languages/compilers
	- attempt to define all possible languages using recursive language, instead of linear language
	- need 3 basic elements:
		1. Lists, recursive, of things
		2. Atoms, the bottom things - non-recursive
		3. Whitespace, terminators in addition to terminators such as `"("` and `")"`
	- like the goal of Projectional Editing, but, borrowing from already-existing syntax (e.g. Lisp)
	- this project - Experimenting With ChatGPT As My Ghost Writer - is related to RT due to experimentation with a syntax-building workflow (OhmJS + draw.io / 0D / drawware + RWR)
- odin0d
	- the basis for building programs in a simplified manner using draw.io
	- this project - Experimenting With ChatGPT As My Ghost Writer - refines odin0D ideas by using that code for something real ("eating my own dogfood")
- find-and-replace
	- using non-nested syntax - i.e. markdown - as a programming language
	- stepping stone towards simplifying syntax creation
- transpiler
	- Scheme to JavaScript transpiler
	- builds PROLOG-like pattern-matching capabilities in JavaScript
- OhmJS
	- syntax-defining language based on PEG
	- PEG opens up a new world in language creation
	- OhmJS is language based on PEG ; OhmJS is a "better PEG"
	- OhmJS is used in this drawware workflow
- RWR
	- SCN (nano-DSL) that allows writing *semantics* code for use with OhmJS without needing to write JavaScript
- Ceptre
	- a language that may hold the key to better concurrency primitives
- Software Atoms
	- boiled-down concepts of *paradigms* vs *syntax*
	- atoms for
		- types
		- control flow
		- data structure
- Behavior Trees
	- language and "operating system" for Robotics
- Blogging and Book Writing
	- writing blogs and essays (see "See Also")
	- writing books (see "See Also")
- Code Commenting
	- comments consist, at least, of 2 kinds of concepts
		1. describe operation of code (*how* the code works)
		2. describe Architecture (*why* the code was built ; what problems the code is meant to solve)
	- better tools for documentation might allow for *more* documentation, where *why*-documentation remains relevant even when *how*-documentation drifts over time
	- can A.I. be used to generate the *why* documentation?
		- maybe needs some *why*-related point-form text
		- maybe the tool prompts for more *why*-related points
- OPL - Orthogonal Programming Languages
	- strive for clean separation of *operations* from *operands*
	- ideas for programming language design, based on Cordy's OCG and Fraser/Davidson's RTL (used in *gcc*)
	- OhmJS makes it possible to easily build languages that use *phrases*
		- this leads to the possibility to defining syntaxes that treat *operations* and *operands* as orthogonal concepts
	- "conditional" code has, at least, 2 purposes:
		1. defining values of functions (on a conditional basis), like taught in grade-school math (Functions and Relations)
		2. scripting *control flow*
	- currently, the 2 kinds of conditionals are usually conflated into single programming languages, leading to non-structured use of variables and `if...then...else` and is accompanied by edicts such as *"state is bad"* (state is not bad, unstructured use of state is bad)
- Golf
	- Flow
		- "Analysis Paralysis"
			- over-thinking actions leads to poor performance
	- programming should be done in a *Flow* state (formerly known as *"in the zone"*)
		- current IDEs and programming languages interfere with *Flow* and make it more difficult to effectively create programs
- Software Simplicity
	- Discord channel to discuss how to drastically simplify programming (see "See Also")

### basic building blocks used in this project
- odin0d
- OhmJS
- RWR
- Golf (re. Flow)

### projects that await better description/documenting
- Software Atoms
- Blogging and Book Writing
- Code Commenting
- Software Simplicity

### extension/refinement of syntax creating workflow
- RT
- find-and-replace
- transpiler

### projects that await better language-building workflows
- Ceptre
- Behavior Trees
- OPL
## Appendix - Gradual Development of the Elevator Pitch

### My words:
I am exploring the use of ChatGPT to ghost-write prose from my outline, which contains point-form notes about "new ideas" that ChatGPT was not trained on. The problem is to avoid hallucinations and incorrect extrapolations of the outline.

I like the early experimental results and am beginning to build a tool to help with this kind of workflow, exploring the use of larger outlines.  The tool allows me to rapidly enter an outline in point form, using a very convenient tool for brainstorming (Kinopio), then pass the outline to ChatGPT for expansion into more-readable prose.

### ChatGPT's take on the above 
15 regenerates:

"I'm developing a cutting-edge tool that leverages ChatGPT to ghost-write prose based on my point-form outlines, particularly focusing on 'new ideas' that the AI wasn't trained on. The challenge lies in preventing hallucinations and incorrect extrapolations from the outline. Encouragingly, early experimental results have been promising, prompting me to create a dedicated workflow tool. This tool enables me to swiftly input point-form outlines, using the user-friendly Kinopio platform for brainstorming. It then paste the outline to ChatGPT, transforming it into coherent and readable prose. Join me in revolutionizing idea development and content creation with this innovative solution!"

## Appendix: See Also

### References

https://guitarvydas.github.io/2021/12/15/References.html

### Blogs
[blog](https://guitarvydas.github.io/)

[obsidian blogs](https://publish.obsidian.md/programmingsimplicity) (see blogs that begin with a date 202x-xx-xx-)
### Videos
[videos - programming simplicity playlist](https://www.youtube.com/@programmingsimplicity2980)
### Books
leanpub'ed (disclaimer: leanpub encourages publishing books before they are finalized - these books are WIPs)
[Programming Simplicity Takeaways, and, Programming Simplicity Broad Brush](https://leanpub.com/u/paul-tarvydas)
### Discord
[Programming Simplicity](https://discord.gg/Jjx62ypR) all welcome, I invite more discussion of these topics, esp. regarding Drawware and 0D
### Twitter
@paul_tarvydas
### Mastodon
(tbd, advice needed re. most appropriate server(s))

<script src="https://utteranc.es/client.js" 
        repo="guitarvydas/guitarvydas.github.io" 
        issue-term="pathname" 
        theme="github-light" 
        crossorigin="anonymous" 
        async> 
</script> 
