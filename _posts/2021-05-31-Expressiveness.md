---
layout: post
title:  "Expressiveness"
---
Step back and try to define "expressiveness".

What does that term mean?

Currently, I think that people use the term "expressiveness" to mean Implementation-ability.

I'm trying to point out that "expressiveness" is a relative term. It is relative to what you want to accomplish.

Currently, Implementation is first-class and everything else is second-class (or lower).

I am trying to point out that Architecture and Engineering (and Testing, and ...) should be considered to be first-class things.

If you accept that "expressiveness" is a relative term, then the idea of one-language-to-rule-them-all dissolves.

You need at least one language for Implementation.

You need at least one language for Architecture.

You need at least one language for Engineering (Engineering is not Coding).

And so on.

Today, we have many languages for Implementation, and zero languages for just about everything else.

(Anecdote: My first full-time job was at Mitel Corp. where I was a "Software Test Engineer". My job was to augment the testing of Mitel's products before they went into the field. Part of my job was to examine designs and to make them more testable. I had the power to request design changes that would improve testability.  Designers would design and I would change the designs.  My goals were very different from their goals.  No one tried to abstract the goals and to union them into some kind of LCD (lowest common denominator)).

# See Also

[References](https://guitarvydas.github.io/2021/01/14/References.html)
[Table of Contents](https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html)

<script src="https://utteranc.es/client.js" 
        repo="guitarvydas/guitarvydas.github.io" 
        issue-term="pathname" 
        theme="github-light" 
        crossorigin="anonymous" 
        async> 
</script> 
