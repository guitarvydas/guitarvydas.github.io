University-bred Engineers are taught to make products that are rock-solid when they are released.  Engineers provide guarantees under threat of Law. CompSci practitioners, though, are taught to produce products so buggy that the products need to be updated quarterly/monthly/daily/hourly and tend to be immune to lawsuits.  

Engineers focus on end-users, CompSci focuses on developers. 

Calling a programmer an "Engineer" is like a bad joke, and, in Ontario, Canada, gets you a stern letter from lawyers at the Engineering society. The title "Engineer" is regulated by Law in Canada.

CompSci focuses on making rock-solid transitions from what-developers-want to executable code, which is not the same as making the rock-solid transitions from what-users-want to products.

Products involve two concerns:
1. implementation
2. design

Implementation is code, mechanics, electronics, etc.

Design is what satisfies users of the product.

Product guarantees are made regarding satisfaction and non-injuring of users, i.e. aspect 2.

Rock-solid, non-buggy, *Implementation* does not necessarily imply rock-solid, non-buggy *Design*.  

To achieve rock-solid Design, you need testing, Q/A, etc.  Q/A is essentially missing from today's software.  We use CI/CD to optimize the cost of Q/A down to a negative quantity, i.e. users *pay* to give *free* Q/A (bug reports) to product developers.  When Ford tried this kind of premature-optimization with their Pinto automobile, they were sued.  When Microsoft and Apple do this kind of premature-optimization, we just live with it and don't sue them.

What is called "programming" today is really just "production engineering", i.e. optimizing product implementation.  But, due to the conflation of concerns, "programming" is "production engineering" applied to an untested design, the unfinished product.  Premature optimization.  Optimization before the Design has been shaken out.

What is call "programming" today is mostly brick-laying.  We over-pay "programmers" because we require them to perform two activities
1. lay bricks
2. think, design.

Instead, we could chop "programming" up into two activities, with more appropriate pay scales:
1. Implementing
2. Engineering


## See Also

### References

[https://guitarvydas.github.io/2021/12/15/References.html](https://guitarvydas.github.io/2021/12/15/References.html)

### Blogs
[blog](https://guitarvydas.github.io/)

[obsidian blogs](https://publish.obsidian.md/programmingsimplicity) (see blogs that begin with a date 202x-xx-xx-)
### Videos
[videos - programming simplicity playlist](https://www.youtube.com/@programmingsimplicity2980)
### Books
leanpub'ed (disclaimer: leanpub encourages publishing books before they are finalized - these books are WIPs)
[Programming Simplicity Takeaways, and, Programming Simplicity Broad Brush](https://leanpub.com/u/paul-tarvydas)
### Discord
[Programming Simplicity](https://discord.gg/Jjx62ypR) all welcome, I invite more discussion of these topics, esp. regarding Drawware and 0D
### Twitter
@paul_tarvydas
### Mastodon
(tbd, advice needed re. most appropriate server(s))

<script src="https://utteranc.es/client.js" 
        repo="guitarvydas/guitarvydas.github.io" 
        issue-term="pathname" 
        theme="github-light" 
        crossorigin="anonymous" 
        async> 
</script> 
