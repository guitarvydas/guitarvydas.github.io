<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://computingsimplicity.neocities.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://computingsimplicity.neocities.org/" rel="alternate" type="text/html" /><updated>2021-04-28T08:22:31-04:00</updated><id>https://computingsimplicity.neocities.org/feed.xml</id><title type="html">Computing Simplicity</title><subtitle>Various thoughts on making programming simpler, and, breaking programming down into several disciplines: Architecture, Engineering, Implementation.  Concurrency is not parallelism and concurrency is not multitasking.</subtitle><entry><title type="html">Txl</title><link href="https://computingsimplicity.neocities.org/2021/04/28/TXL.html" rel="alternate" type="text/html" title="Txl" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/TXL</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/TXL.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;TXL&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;txl&quot;&gt;TXL&lt;/h1&gt;

&lt;p&gt;[&lt;em&gt;Why not use TXL instead of Ohm?&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Good question. I didn&amp;#8217;t explicitly understand the problem until later, when I had PEG and JavaScript in my hands.&lt;/p&gt;

&lt;p&gt;S/SL laid the groundwork for my understanding. It took only 30 more years. [&lt;em&gt;I used S/SL right from the beginning, but it took me a while to verbalize why I found it so useful.&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;I wonder if Cordy &amp;#8220;got it&amp;#8221; much earlier?&lt;/p&gt;

&lt;p&gt;TXL is based on parse trees. Ohm-JS is based on JS objects. It became easier to program when I thought of objects instead of parse trees.&lt;/p&gt;

&lt;p&gt;TXL looks like &amp;#8220;compiler technology&amp;#8221;. Ohm-JS &lt;em&gt;can&lt;/em&gt; look like lowly JS. Maybe that makes Ohm-JS &lt;em&gt;feel&lt;/em&gt; more accessible?&lt;/p&gt;

&lt;p&gt;Paul Morrison talks about &amp;#8220;steam engine time&amp;#8221; - multiple inventions of the same concept, at about the same time.&lt;/p&gt;

&lt;h1 id=&quot;appendix-txl&quot;&gt;Appendix - TXL&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.txl.ca/&quot;&gt;https://www.txl.ca/&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">TXL</summary></entry><entry><title type="html">Subdividing problems</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Subdividing-Problems.html" rel="alternate" type="text/html" title="Subdividing problems" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Subdividing%20Problems</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Subdividing-Problems.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Dubdividing Problems&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;subdividingproblems&quot;&gt;Subdividing Problems&lt;/h1&gt;

&lt;p&gt;[&lt;em&gt;Do you have a heuristic when to use certain paradigms and when to avoid them?&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Fractalize.&lt;/p&gt;

&lt;p&gt;FDD - Failure Driven Development.&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Break a problem down, break each part down into sub-parts. Repeat (recur).&lt;/p&gt;

&lt;p&gt;Choose a different paradigm for each sub-part. Choose based on the problem-at-hand.&lt;/p&gt;

&lt;p&gt;For example, input is mostly pattern matching &amp;#8212; parsing, PEG, S/SL.&lt;/p&gt;

&lt;p&gt;Output can be done with printf and JS back-tick strings. When I need tabular output, I use a spreadsheet to edit the final tables (I convert / normalize the data into .CSV files, to make the data more acceptable to spreadsheets).&lt;/p&gt;

&lt;p&gt;[&lt;em&gt;N.B. I needed an editor to make the final output format for a project. Spreadsheets are good editors (for tabular data), but tend to lock you into a single paradigm (spreadsheet language). .CSV is a normalized format acceptable to most spreadsheets. If you convert your data to/from .CSV, you can use any editor (built into spreadsheets) you want. Export from the &amp;#8220;editor&amp;#8221; to CSV. We need a .CSV-like normal form for all data and programs (I suggest triples).&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;[&lt;em&gt;N.B. Talking about editors, I like to use Keynote as an editor &amp;#8212; it helps me organize my thoughts and to keep my text short. Keynote has the disadvantage in that it doesn&amp;#8217;t export well to normalized forms. Keynote does export to HTML, but includes a bunch of JS in the process.&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Queries are exhaustive search. PROLOG has a nice syntax for crafting queries. PROLOG can import and export data in normal form (triples).&lt;/p&gt;

&lt;p&gt;Note that I am breaking programming down into two classes (at least): human readable syntax vs. machine readable syntax.&lt;/p&gt;

&lt;p&gt;/bin/sh was aimed at machine readability. After that, things like /bin/bash and /bin/zsh only danced around the elephant and didn&amp;#8217;t really bring any new advances in think-ability.&lt;/p&gt;

&lt;p&gt;In my mind, the next step for /bin/sh is to make it diagrammatic. Visual Shell. vsh. [&lt;em&gt;Experimental version at &lt;a href=&quot;https://github.com/guitarvydas/vsh&quot;&gt;https://github.com/guitarvydas/vsh&lt;/a&gt;&lt;/em&gt;]&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;https://guitarvydas.github.io/2021/04/23/Failure&amp;#8211;Driven&amp;#8211;Design.html &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Dubdividing Problems</summary></entry><entry><title type="html">Observation why relational programming works</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Observation-Why-Relational-Programming-Works.html" rel="alternate" type="text/html" title="Observation why relational programming works" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Observation%20Why%20Relational%20Programming%20Works</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Observation-Why-Relational-Programming-Works.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Observation Why Relational Programming Works&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;observation:whyrelationalprogrammingworks&quot;&gt;Observation: Why Relational Programming Works&lt;/h1&gt;

&lt;p&gt;Relational programming expresses &amp;#8220;code&amp;#8221; in a declarative manner.&lt;/p&gt;

&lt;p&gt;Relational programming divides &amp;#8220;coding&amp;#8221; into two main tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;relations (code)&lt;/li&gt;
&lt;li&gt;engine.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The relational engine is divorced from the &amp;#8220;code&amp;#8221;.&lt;/p&gt;

&lt;p&gt;A programmer cannot express &amp;#8220;how&amp;#8221; to do something, the engine decides.&lt;/p&gt;

&lt;p&gt;This is the key &amp;#8212; divide a problem into sub-parts, remove all inter-dependencies between the parts.&lt;/p&gt;

&lt;p&gt;Other Examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPUs hide the gory details of how various kinds of rust interact electrically. CPUs are opcode engines, programmers write code in HLLs, and these are divorced from the inner workings of the hardware.&lt;/li&gt;
&lt;li&gt;Peter Lee approached an otherwise hoary notation &amp;#8212; Denotational Semantics &amp;#8212; and managed to build practical compilers using D.S. by subdividing the notation into sub-notations.&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Observation Why Relational Programming Works</summary></entry><entry><title type="html">Exhaustive search</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Exhaustive-Search.html" rel="alternate" type="text/html" title="Exhaustive search" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Exhaustive%20Search</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Exhaustive-Search.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Exhaustive Search&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;exhaustivesearch&quot;&gt;Exhaustive Search&lt;/h1&gt;

&lt;p&gt;We should do exhaustive search everywhere. I suggest using PROLOG (swipl) and Kanren in stunted form - triples only, exhaustive search of triples. I have ported PROLOG (the good parts) to JS using Ohm-JS (from Scheme) and it would take only an afternoon or so to change the text emitter to emit just about any other language (e.g. Python, Haskell, etc.).&lt;/p&gt;

&lt;p&gt;Note that exhaustive search enables relational. Relational enables Haskell et al.&lt;/p&gt;

&lt;p&gt;Note that diagrams enable the breakdown of Software Development into Architecting, Engineering, Implementation, Testing, etc.&lt;/p&gt;

&lt;p&gt;I change my mind and have new revelations daily. I have refined what I said a year ago.&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Exhaustive Search</summary></entry><entry><title type="html">Common lisp complexities</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Common-Lisp-Complexities.html" rel="alternate" type="text/html" title="Common lisp complexities" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Common%20Lisp%20Complexities</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Common-Lisp-Complexities.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Common Lisp Complexities&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;complexitiesofcl&quot;&gt;Complexities of CL&lt;/h1&gt;

&lt;h2 id=&quot;whatwerethecomplexitiesthatwereaddedtocommonlisp&quot;&gt;What were the complexities that were added to Common Lisp?&lt;/h2&gt;

&lt;p&gt;The main complexity was the switch from dynamic scoping to static scoping.&lt;/p&gt;

&lt;p&gt;This allowed Lisp to be compiled. Up until then, many Lisps were only interpreted. One of the biggest knocks against Lisp was that it was interpreted, and, everyone was worried about efficiency and thought that they would write more-efficient code if they used C instead of Lisp. If you squint hard enough, you will see that operating systems are manually-written versions of Lisp and are wildly inefficient (processes instead of closures (in fact, closures weren&amp;#8217;t even necessary in early Lisps - their existence is driven by the goal of compilation)).&lt;/p&gt;

&lt;p&gt;A second complication was the invention of packages. Packages in CL are much more detailed than packages in other languages. In CL, packages are based on symbols instead of being mostly syntactic constructs. The way that packages interact with the reader make it harder to write SCNs&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; in CL.&lt;/p&gt;

&lt;p&gt;C had scoping rules that worked OK. Names (variables and functions) were invisible outside of the boundaries of a compilation unit, by default. C had globals (variables and functions), locals (variables mostly) and parameters (variables mostly).&lt;/p&gt;

&lt;p&gt;A third complication was macros. People were experimenting with writing code that writes code and that was distilled down into macros. Lisp macros are much more powerful than macros in most other languages. Lisp macros are, essentially, the Lisp compiler being exposed to programmers. With that power comes accidental complexity.&lt;/p&gt;

&lt;p&gt;Lisp, originally, addressed all sorts of debugging and quick prototyping issues. Then, Lisp, became schizophrenic with the standardization of CL. It still had many debugging features, but it also had efficiency (premature optimization) features.&lt;/p&gt;

&lt;p&gt;In general, CL dumbed Lisp down by addressing micro-problems instead of addressing the elephant in the room (elephant: why is software so much harder to build correctly than, say, hardware?)&lt;/p&gt;

&lt;p&gt;CL has restarts which are error handlers that are more powerful than what can be found in most languages. This power comes from the fact that Lispers can think in any paradigm they choose &amp;#8212; most languages flog a certain paradigm to exclusion of all else (e.g. Smalltalk and OO, PROLOG and relational, etc.). The multi-paradigmatic nature of Lisp comes from the fact that Lisp has no syntax. A Lisper can invent a syntax (using functions and macros) for any paradigm. OTOH, the lack of syntax in Lisp is very closely related to Assembler. Some people love the power, others hate it. Some programmers loved to program in assembler and others hated it. The circle is being closed again, with the advent of CPS&lt;a href=&quot;#fn:2&quot; id=&quot;fnref:2&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; and WASM&lt;a href=&quot;#fn:3&quot; id=&quot;fnref:3&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;People did not make a distinction between high-level languages for human readability and high-level languages for machine readability (high-level assembler) and debugging (mostly for humans).&lt;/p&gt;

&lt;p&gt;Note that just about every interesting advance in CSC started out life as Lisp (e.g. GHC &amp;#8211;&amp;gt; Haskell, Lisp &amp;#8211;&amp;gt; JavaScript). Researchers should be prohibited from using anything but Lisp and, researchers should be prohibited from providing their &amp;#8220;languages&amp;#8221; to mortal programmers. (E.G. I can&amp;#8217;t imagine a JS programmer using Haskell, nor AGDA, nor Idris, nor PROLOG, nor &amp;#8230; [Research is about defining the Universe of Programming Languages, whereas Programming Language design is about creating a useful compromise (JavaScript ain&amp;#8217;t it ; is HTML+CSS &lt;em&gt;it&lt;/em&gt;?).]).&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;SCN means Solution Centric Notation. &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:2&quot;&gt;
&lt;p&gt;CPS means Continuation Passing Style &amp;#8211; the ultimate GOTO. https://en.wikipedia.org/wiki/Continuation&amp;#8211;passing_style#:~:text=In%20functional%20programming%2C%20continuation%2Dpassing,the%20form%20of%20a%20continuation.&amp;amp;text=When%20the%20CPS%20function%20has,this%20value%20as%20the%20argument. &lt;a href=&quot;#fnref:2&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:3&quot;&gt;
&lt;p&gt;WASM mean Web Assembly. https://webassembly.org/ &lt;a href=&quot;#fnref:3&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Common Lisp Complexities</summary></entry><entry><title type="html">Clojure</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Clojure.html" rel="alternate" type="text/html" title="Clojure" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Clojure</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Clojure.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Clojure&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;clojure&quot;&gt;Clojure&lt;/h1&gt;

&lt;p&gt;[&lt;em&gt;What do you think of Clojure?&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;I like Lisp (and CL) because it is multi-paradigm. Clojure is single-paradigm (FP).&lt;/p&gt;

&lt;p&gt;Again, I like languages that I can write code to write code in.&lt;/p&gt;

&lt;p&gt;Most people want languages that are human-readable. But, that stunts growth in the field of programming - growth stops at what the language designer imagined.&lt;/p&gt;

&lt;p&gt;PEG+Lisp is a powerful combination - multiple syntaxes built on top of HLL assembler (I use the phrase &amp;#8220;toolbox language&amp;#8221; to mean &amp;#8220;HL assembler&amp;#8221;). Syntaxes can be tuned to a specific problem instead of only what Guido van Rossum could imagine (something which doesn&amp;#8217;t fit most problems).&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Clojure</summary></entry><entry><title type="html">Backtracking, mathematics, reversability, garbage collection, time Sharing</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Backtracking,-Mathematics,-Reversability,-Garbage-Collection,-Time-Sharing.html" rel="alternate" type="text/html" title="Backtracking, mathematics, reversability, garbage collection, time Sharing" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Backtracking,%20Mathematics,%20Reversability,%20Garbage%20Collection,%20Time-Sharing</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Backtracking,-Mathematics,-Reversability,-Garbage-Collection,-Time-Sharing.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Backtracking, Mathematics, Reversability, Garbage Collection, Time-Sharing&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;backtracking&quot;&gt;Backtracking&lt;/h1&gt;

&lt;p&gt;I&amp;#8217;ve stopped using the phrase &amp;#8220;backtracking&amp;#8221; and try to use the phrase &amp;#8220;exhaustive search&amp;#8221;. Backtracking is an implementation detail, &amp;#8220;exhaustive search&amp;#8221; is a semantic concept that doesn&amp;#8217;t imply how it&amp;#8217;s implemented.&lt;/p&gt;

&lt;p&gt;Note that Microsoft Word has had &amp;#8220;exhaustive search&amp;#8221; for a loooong time (WordStar had it before Word. Ed/vi/emacs?). Grep could do exhaustive search. We should&amp;#8217;a turned left at Albuquerque (&lt;em&gt;Bugs Bunny&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Mathematics notation employs exhaustive search. The strive for immutability is in aid of exhaustive search.&lt;/p&gt;

&lt;p&gt;Mathematics is 2 things: (1) a pencil-and-paper notation that employs exhaustive search and (2) a body of experience with using that notation.&lt;/p&gt;

&lt;p&gt;Reversability. Who cares? No one asked for reversability, but it was a side-effect of immutability and now has risen to the level of an ideology.&lt;/p&gt;

&lt;p&gt;Reversability can be used to solve one class of problems - UNDO. Should we be forced to bolt UNDO into every app? We seem to force ourselves to bolt time-sharing into every app. Is this a good thing? (If we were allowed to use multiple paradigms, we would be able to choose time-sharing and UNDO when we actually needed it, instead of having it built-into every language we use).&lt;/p&gt;

&lt;p&gt;Garbage collection might have been the latest useful feature that we invented. Is UNDO in that same class? (I don&amp;#8217;t know, this is rhetorical question).&lt;/p&gt;

&lt;p&gt;Time-sharing came about due to premature optimization (we optimized CPU usage instead of believing in Moore&amp;#8217;s Law). Are we making the same mistake again?&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Backtracking, Mathematics, Reversability, Garbage Collection, Time-Sharing</summary></entry><entry><title type="html">Actors</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Actors.html" rel="alternate" type="text/html" title="Actors" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Actors</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Actors.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Actors&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;actors&quot;&gt;Actors&lt;/h1&gt;

&lt;p&gt;Actors are single-paradigm.&lt;/p&gt;

&lt;p&gt;Not all kinds of solutions fit, cleanly, into the Actors paradigm.&lt;/p&gt;

&lt;p&gt;For example, &lt;em&gt;printf&lt;/em&gt; and JS back-tick strings are pretty good at formatting output. OO, FP, Actors, PROLOG, etc.. don&amp;#8217;t make it easier to format output.&lt;/p&gt;

&lt;p&gt;For example, REGEX is pretty good at matching text. OO, FP, Actors, PROLOG, etc., don&amp;#8217;t make it easier to match text. REGEX breaks down into an unreadable mess when patterns become complicated. Maybe there is something better than REGEX for use in such cases? Not OO, not FP, not Actors, et al. PEG comes to mind.&lt;/p&gt;

&lt;h1 id=&quot;scns&quot;&gt;SCNs&lt;/h1&gt;

&lt;p&gt;My emphasis is on solving problems by creating specific notations for specific problem and having a bunch of paradigms in one&amp;#8217;s toolbelt. This attitude is very different from the language, heavy-weight language, design paradigm that is in vogue. Paradigms are interesting and hard to learn. Languages &amp;#8212; syntax &amp;#8212; are noise.&lt;/p&gt;

&lt;p&gt;What if building a compiler was easy?&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What if all notations were as easy-to-use as REGEX?&lt;/p&gt;

&lt;p&gt;Paradigms should not be dumbed down to assembler. Maybe each paradigm could come with a suggested syntax? Maybe we could just mix-and-match paradigms and suggested syntaxes?&lt;/p&gt;

&lt;p&gt;What if we could use many paradigms &amp;#8212; and many syntaxes &amp;#8212; to solve one problem?&lt;/p&gt;

&lt;p&gt;What if SCN-building was so cheap that we could just switch to any paradigm we wanted for a given problem? For example, using REGEX to input line-oriented data, PROLOG to perform queries, and printf to write out reports.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;https://guitarvydas.github.io/2021/04/26/What&amp;#8211;If&amp;#8211;Making&amp;#8211;A&amp;#8211;Compiler&amp;#8211;Was&amp;#8211;Easy.html &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Actors</summary></entry><entry><title type="html">Tokenizing</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Tokenizing.html" rel="alternate" type="text/html" title="Tokenizing" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Tokenizing</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Tokenizing.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Tokenizing&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;tokenizing&quot;&gt;Tokenizing&lt;/h1&gt;

&lt;p&gt;I&amp;#8217;m struggling with this. I think in terms of tokenizing, but Ohm-JS fights me. I was very un-amused to discover that ESRAP only worked with characters (instead of tokens and CL forms).&lt;/p&gt;

&lt;p&gt;You can&amp;#8217;t skip whitespace unless the whitespace has been tokenized. Ohm-JS handles languages, like JS, that use commas (,). Ohm-JS creates bugs (accidental complexity) when parsing comma-less languages.&lt;/p&gt;

&lt;p&gt;My experiments with ASON parsing&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; using Ohm-JS might show how to tokenize using Ohm-JS.&lt;/p&gt;

&lt;h1 id=&quot;isolatedcomponents&quot;&gt;Isolated Components&lt;/h1&gt;

&lt;p&gt;I think in terms of isolated software components.&lt;/p&gt;

&lt;p&gt;I want to &lt;em&gt;build-and-forget&lt;/em&gt; any component.&lt;/p&gt;

&lt;p&gt;Ideally, there are no dependencies between components. Adding new components does not affect the way that old ones work.&lt;/p&gt;

&lt;p&gt;[&lt;em&gt;This is possible, but unlikely with current programming languages.&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Parsing and tokenizing is like that. The first pass should break the input into two kinds of tokens&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;whitespace&lt;/li&gt;
&lt;li&gt;non-whitespace.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then, if we want to delete whitespace, we simple drop tokens of type (1). The rest of the tokens remain the same.&lt;/p&gt;

&lt;p&gt;[&lt;em&gt;For the record, I can&amp;#8217;t bring myself to do something this simple using current languages. When I address (1), I immediately worry about counting newlines. Counting lines should, ideally, be done in another pass.&lt;/em&gt;]&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;https://guitarvydas.github.io/2021/04/10/ASON&amp;#8211;Notation&amp;#8211;Pipeline.html &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Tokenizing</summary></entry><entry><title type="html">Scoping rebol</title><link href="https://computingsimplicity.neocities.org/2021/04/27/Scoping-Rebol.html" rel="alternate" type="text/html" title="Scoping rebol" /><published>2021-04-27T00:00:00-04:00</published><updated>2021-04-27T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/27/Scoping%20Rebol</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/27/Scoping-Rebol.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Scoping Rebol&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;rebolisstaticallyscoped&quot;&gt;Rebol is Statically Scoped&lt;/h1&gt;

&lt;p&gt;Rebol has static scoping,&lt;/p&gt;

&lt;p&gt;but,&lt;/p&gt;

&lt;p&gt;The question is not &amp;#8220;&lt;em&gt;what&lt;/em&gt; scoping does Rebol employ?&amp;#8221;, but, &amp;#8220;&lt;em&gt;when&lt;/em&gt; is Rebol scoping determined, &lt;em&gt;when&lt;/em&gt; is a Rebol program compiled?&amp;#8221;.&lt;/p&gt;

&lt;h1 id=&quot;rebol-statictypingdynamiccompilation&quot;&gt;Rebol - Static Typing, Dynamic Compilation&lt;/h1&gt;

&lt;p&gt;Rebol has static scoping, but dynamic compilation.&lt;/p&gt;

&lt;p&gt;We are accustomed to there being &lt;em&gt;one&lt;/em&gt; compilation time and &lt;em&gt;one&lt;/em&gt; run time.&lt;/p&gt;

&lt;p&gt;Rebol has &lt;em&gt;multiple&lt;/em&gt; compilation times.&lt;/p&gt;

&lt;p&gt;The compilation of Rebol code depends on the &lt;em&gt;context&lt;/em&gt; that exists at the time of compilation.&lt;/p&gt;

&lt;p&gt;Rebol code is compiled at different times, within different contexts. This means that Rebol functions might be compiled differently at different times.&lt;/p&gt;

&lt;h1 id=&quot;appendix-rebolscoping&quot;&gt;Appendix - REBOL Scoping&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/21964110/is-there-a-overall-explanation-about-definitional-scoping-in-rebol-and-red&quot;&gt;https://stackoverflow.com/questions/21964110/is-there-a-overall-explanation-about-definitional-scoping-in-rebol-and-red&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.hostilefork.com/rebol-vs-lisp-macros/&quot;&gt;http://blog.hostilefork.com/rebol-vs-lisp-macros/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.hostilefork.com/core-rebol-concept-flexible-series/&quot;&gt;http://blog.hostilefork.com/core-rebol-concept-flexible-series/&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Scoping Rebol</summary></entry></feed>