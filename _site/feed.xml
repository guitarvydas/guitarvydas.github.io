<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://computingsimplicity.neocities.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://computingsimplicity.neocities.org/" rel="alternate" type="text/html" /><updated>2021-04-28T11:12:40-04:00</updated><id>https://computingsimplicity.neocities.org/feed.xml</id><title type="html">Computing Simplicity</title><subtitle>Various thoughts on making programming simpler, and, breaking programming down into several disciplines: Architecture, Engineering, Implementation.  Concurrency is not parallelism and concurrency is not multitasking.</subtitle><entry><title type="html">Observation why relational programming works</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Observation-Why-Relational-Programming-Works.html" rel="alternate" type="text/html" title="Observation why relational programming works" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Observation%20Why%20Relational%20Programming%20Works</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Observation-Why-Relational-Programming-Works.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Observation Why Relational Programming Works&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;observation:whyrelationalprogrammingworks&quot;&gt;Observation: Why Relational Programming Works&lt;/h1&gt;

&lt;p&gt;Relational programming expresses &amp;#8220;code&amp;#8221; in a declarative manner.&lt;/p&gt;

&lt;p&gt;Relational programming divides &amp;#8220;coding&amp;#8221; into two main tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;relations (code)&lt;/li&gt;
&lt;li&gt;engine.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The relational engine is divorced from the &amp;#8220;code&amp;#8221;.&lt;/p&gt;

&lt;p&gt;A programmer cannot express &amp;#8220;how&amp;#8221; to do something, the engine decides.&lt;/p&gt;

&lt;p&gt;This is the key &amp;#8212; divide a problem into sub-parts, remove all inter-dependencies between the parts.&lt;/p&gt;

&lt;p&gt;Other Examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPUs hide the gory details of how various kinds of rust interact electrically. CPUs are opcode engines, programmers write code in HLLs, and these are divorced from the inner workings of the hardware.&lt;/li&gt;
&lt;li&gt;Peter Lee approached an otherwise hoary notation &amp;#8212; Denotational Semantics &amp;#8212; and managed to build practical compilers using D.S. by subdividing the notation into sub-notations.&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Observation Why Relational Programming Works</summary></entry><entry><title type="html">Mutable variables and flags</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Mutable-Variables-and-Flags.html" rel="alternate" type="text/html" title="Mutable variables and flags" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Mutable%20Variables%20and%20Flags</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Mutable-Variables-and-Flags.html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot;&gt;
  &lt;title&gt;Mutable Variables and Flags&lt;/title&gt;
  &lt;meta name=&quot;CreationTime&quot; content=&quot;2021-04-28T10:51:25Z&quot;&gt;
  &lt;meta name=&quot;ModificationTime&quot; content=&quot;2021-04-28T10:51:25Z&quot;&gt;
  &lt;meta name=&quot;Generator&quot; content=&quot;Cocoa HTML Writer&quot;&gt;
  &lt;meta name=&quot;CocoaVersion&quot; content=&quot;1894.6&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; min-height: 18.0px}
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;width: 600px; margin: 0 auto&quot;&gt;

&lt;p class=&quot;p1&quot;&gt;Programmers use mutable variables, but, the practice causes trouble.&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;One use of mutable variables is to create flags.&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;Wouldn't it be nice if there were a declarative way to express flags?&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;I think that parsers do this.&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;I discuss the issues in &lt;a href=&quot;https://guitarvydas.github.io/2021/04/28/Parsing-vs-FP-Pattern-Matching.html&quot;&gt;https://guitarvydas.github.io/2021/04/28/Parsing-vs-FP-Pattern-Matching.html&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;[&lt;i&gt;Q: What else, if anything, are mutable variables used for?&lt;/i&gt;]&lt;/p&gt;
&lt;/div&gt;
&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Mutable Variables and Flags</summary></entry><entry><title type="html">Function or list?</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Function-or-List.html" rel="alternate" type="text/html" title="Function or list?" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Function%20or%20List</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Function-or-List.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Function or List?&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;lisp&quot;&gt;lisp&lt;/h1&gt;

&lt;p&gt;Is this a function or a list?&lt;/p&gt;

&lt;p&gt;(rectangle id1 nil)&lt;/p&gt;

&lt;p&gt;Actually, it&amp;#8217;s a bit more convoluted than that. Lisp was one of the first (if not first) &amp;#8220;homoiconic languages&amp;#8221;.&lt;/p&gt;

&lt;p&gt;Programs are stored as lists of atoms (and lists, and, &amp;#8230;)&lt;/p&gt;

&lt;p&gt;&amp;#8220;Eval&amp;#8221; (as in Read-Eval-Print-Loop) is used to impart &lt;em&gt;meaning&lt;/em&gt; to the lists.&lt;/p&gt;

&lt;p&gt;So, in actuality, &amp;#8220;(rectangle id1 nil)&amp;#8221; is just a list containing 3 atoms.&lt;/p&gt;

&lt;p&gt;Atoms that look like symbols are hashed, for efficiency. The above list, internally, is a list of 3 hash-codes, e.g. *list(hash-code-for-rectangle,hash-code-for-id1,hash-code-for-nil*).&lt;/p&gt;

&lt;p&gt;Lisps are also classified by their packaging strategy, e.g. Lisp2&amp;#8217;s vs Lisp1&amp;#8217;s. Lisp2&amp;#8217;s have several name-spaces and allow the same symbol (hash-code) to be used in different contexts, while Lisp1&amp;#8217;s have only one namespace into which all symbols are poured (and must be unique from one another). CL is a Lisp2.&lt;/p&gt;

&lt;p&gt;Eval() attempts to interpret the first item of a list as a function. Eval accepts a list, the symbol LAMBDA and any other symbol as the first item. If the first item is a symbol, eval() digs through the properties of the symbol looking for a function thing, and when it finds such a property it applies the function thing to the rest of the list (the args).&lt;/p&gt;

&lt;p&gt;Symbols, like rectangle, have &amp;#8220;1st class&amp;#8221; functions stored in them under their function properties.&lt;/p&gt;

&lt;p&gt;Apply() never really gets to see a symbol, it only gets a 1st-class function and a list of args.&lt;/p&gt;

&lt;p&gt;In JS, we might say something like {name: rectangle, value: xyz, func: function (&amp;#8230;) { &amp;#8230;}}. I.E. &amp;#8220;rectangle&amp;#8221; can have a value AND it can have a function. Which property gets used is determined by the context (and, by the interpretation of the context).&lt;/p&gt;

&lt;p&gt;The &amp;#8220;type&amp;#8221; of &amp;#8220;rectangle&amp;#8221; is SYMBOL, and, things of type SYMBOL have several properties, including VALUE and FUNCTION.&lt;/p&gt;

&lt;h1 id=&quot;prolog&quot;&gt;PROLOG&lt;/h1&gt;

&lt;p&gt;In PROLOG we don&amp;#8217;t need to declare a rectangle type. PROLOG (being one of the early languages, I think it was originally built in Lisp), uses a similar hashing trick.&lt;/p&gt;

&lt;p&gt;rectangle(id1,nil).&lt;/p&gt;

&lt;p&gt;is also a bunch of hash-codes, probably stored as a Lisp-like list (hash-code-of-rectangle hash-code-of-id hash-code-of-nil). The &lt;em&gt;type&lt;/em&gt; of the above thing is &amp;#8220;functor&amp;#8221; (and &amp;#8220;functor&amp;#8221; is a lisp-like list).&lt;/p&gt;

&lt;p&gt;Lisp lists and PROLOG functors are generalized data structures. In a strongly-typed language, we would define a 3-tuple &amp;#8212; {relation, subject, object} &amp;#8212; and, we would implement these kinds of 3-tuples in a more efficient way than generalized Lisp-like lists. [Elsewhere, I argue, that this concern for this kind of efficiency is mis-placed. It&amp;#8217;s very 1960&amp;#8217;s. In 2020, we can burn CPU power to construct data structures at run-time, instead of wasting our own (programmers') time and efficiency. PROLOG is good at constructing (by inference) data structures for us. Our end-goal is always to run queries against data. If we structure our data at compile-time, we end up wasting brain-power, if we let PROLOG infer our data structures, we end up wasting CPU power. Either way, we are wasting &lt;em&gt;&amp;lt;something&amp;gt;&lt;/em&gt;. I believe that wasting CPU power is a better choice tham wasting brain-power.]&lt;/p&gt;

&lt;p&gt;PROLOG stores functors in some data structure, Lisp stores lists in some data structures. With PROLOG, we let the engine decide on the shape of the data structure, whereas in Lisp (and Python, and JS, and etc.) we decide on the shape of the data structure and hard-code it into the program.&lt;/p&gt;

&lt;p&gt;A.T.M. PROLOG is worse at guessing what the best data structure is than humans are. We can usually create data structures that are &amp;#8220;better&amp;#8221; (more efficient) than what PROLOG decides to use under-the-hood.&lt;/p&gt;

&lt;p&gt;But, that&amp;#8217;s what Assembler programmers said until GCC came along. At some point, automation catches up with the best manually-written code created by humans.&lt;/p&gt;

&lt;p&gt;Take-aways:&lt;/p&gt;

&lt;p&gt;(rectangle id1 nil) is just a list of atoms (hash-codes) in Lisp.&lt;/p&gt;

&lt;p&gt;rectangle(id,nil) is just a &amp;#8220;functor&amp;#8221; of atoms (hash-codes) in PROLOG.&lt;/p&gt;

&lt;p&gt;Both are sufficiently general data structures for &amp;#8220;normalization&amp;#8221;.&lt;/p&gt;

&lt;p&gt;PROLOG (and Lisp) are not as good as today&amp;#8217;s programmers, but automation techniques will catch up.&lt;/p&gt;

&lt;p&gt;Let PROLOG do your work for you. Don&amp;#8217;t worry about preemptive efficiency, let them (and their compilers) catch up with what you&amp;#8217;re doing.&lt;/p&gt;

&lt;h1 id=&quot;now&quot;&gt;Now&lt;/h1&gt;

&lt;p&gt;If you need to deliver something today, write a design using factbases, then hire an Optimization Engineer to fixup the inefficiencies (after using a profiler ; (unprofiled Rust code ain&amp;#8217;t gonna be much help)). If you can&amp;#8217;t afford to hire an Optimization Engineer (and/or you don&amp;#8217;t know what that is), then do it all yourself, but, do yourself a favour and create the design in layers. The goals of Architecting and Engineering should be to write as little code as possible (e.g. using an SCN) and to maximize the time allotted to &lt;em&gt;thinking-things-through&lt;/em&gt;. Implementation should use &lt;em&gt;no&lt;/em&gt; thought-time at all - the measure of Implementors is how fast they can create code (keyboarding skill, etc.). Implementors should never have to stop and think about a Design. All Design thinking needs to punted back upwards to Architects and Engineers and whiteboards. (Implementors punt back to Engineers, Engineers either clarify the details or punt back to Architects for clarifications of the Design).&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Function or List?</summary></entry><entry><title type="html">First class functions</title><link href="https://computingsimplicity.neocities.org/2021/04/28/First-Class-Functions.html" rel="alternate" type="text/html" title="First class functions" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/First%20Class%20Functions</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/First-Class-Functions.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;First Class Functions&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;first-classfunctions&quot;&gt;First-Class Functions&lt;/h1&gt;

&lt;p&gt;I don&amp;#8217;t think that mortal programmers should be allowed to use 1st-class. They are no better than C&amp;#8217;s &amp;#8220;(*f)(x, y z)&amp;#8221; stuff. (case in point: the JS-callbacks-using-anonymous-functions disaster)&lt;/p&gt;

&lt;p&gt;CPS is just another kludgy attempt at making 1st-class functions more palatable to human programmers.&lt;/p&gt;

&lt;p&gt;1st class functions *are* incredibly useful in toolbox languages, (aka High Level Assembler). 1st-class functions make it easier to create syntaxes (SCNs) with specific control flows.&lt;/p&gt;

&lt;p&gt;People are &amp;#8220;in love&amp;#8221; with 1st class functions, CPS, promises, etc. They don&amp;#8217;t notice, though that this is the same &amp;#8220;power&amp;#8221; as assembler put in programmers' hands in the '70&amp;#8217;s.&lt;/p&gt;

&lt;p&gt;Case-in-point: most programmers think that &amp;#8220;multitasking is hard&amp;#8221; and throw up their hands and just accept scraps from the dinner table. In fact, multitasking is easy, but you need to use an appropriate notation (SCN). Kids learn multitasking at the age of 5 (e.g. music notation). Only programmers think that multitasking is hard. Square peg, round hole.&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">First Class Functions</summary></entry><entry><title type="html">Exhaustive search</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Exhaustive-Search.html" rel="alternate" type="text/html" title="Exhaustive search" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Exhaustive%20Search</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Exhaustive-Search.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Exhaustive Search&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;exhaustivesearch&quot;&gt;Exhaustive Search&lt;/h1&gt;

&lt;p&gt;We should do exhaustive search everywhere. I suggest using PROLOG (swipl) and Kanren in stunted form - triples only, exhaustive search of triples. I have ported PROLOG (the good parts) to JS using Ohm-JS (from Scheme) and it would take only an afternoon or so to change the text emitter to emit just about any other language (e.g. Python, Haskell, etc.).&lt;/p&gt;

&lt;p&gt;Note that exhaustive search enables relational. Relational enables Haskell et al.&lt;/p&gt;

&lt;p&gt;Note that diagrams enable the breakdown of Software Development into Architecting, Engineering, Implementation, Testing, etc.&lt;/p&gt;

&lt;p&gt;I change my mind and have new revelations daily. I have refined what I said a year ago.&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Exhaustive Search</summary></entry><entry><title type="html">Common lisp complexities</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Common-Lisp-Complexities.html" rel="alternate" type="text/html" title="Common lisp complexities" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Common%20Lisp%20Complexities</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Common-Lisp-Complexities.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Common Lisp Complexities&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;complexitiesofcl&quot;&gt;Complexities of CL&lt;/h1&gt;

&lt;h2 id=&quot;whatwerethecomplexitiesthatwereaddedtocommonlisp&quot;&gt;What were the complexities that were added to Common Lisp?&lt;/h2&gt;

&lt;p&gt;The main complexity was the switch from dynamic scoping to static scoping.&lt;/p&gt;

&lt;p&gt;This allowed Lisp to be compiled. Up until then, many Lisps were only interpreted. One of the biggest knocks against Lisp was that it was interpreted, and, everyone was worried about efficiency and thought that they would write more-efficient code if they used C instead of Lisp. If you squint hard enough, you will see that operating systems are manually-written versions of Lisp and are wildly inefficient (processes instead of closures (in fact, closures weren&amp;#8217;t even necessary in early Lisps - their existence is driven by the goal of compilation)).&lt;/p&gt;

&lt;p&gt;A second complication was the invention of packages. Packages in CL are much more detailed than packages in other languages. In CL, packages are based on symbols instead of being mostly syntactic constructs. The way that packages interact with the reader make it harder to write SCNs&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; in CL.&lt;/p&gt;

&lt;p&gt;C had scoping rules that worked OK. Names (variables and functions) were invisible outside of the boundaries of a compilation unit, by default. C had globals (variables and functions), locals (variables mostly) and parameters (variables mostly).&lt;/p&gt;

&lt;p&gt;A third complication was macros. People were experimenting with writing code that writes code and that was distilled down into macros. Lisp macros are much more powerful than macros in most other languages. Lisp macros are, essentially, the Lisp compiler being exposed to programmers. With that power comes accidental complexity.&lt;/p&gt;

&lt;p&gt;Lisp, originally, addressed all sorts of debugging and quick prototyping issues. Then, Lisp, became schizophrenic with the standardization of CL. It still had many debugging features, but it also had efficiency (premature optimization) features.&lt;/p&gt;

&lt;p&gt;In general, CL dumbed Lisp down by addressing micro-problems instead of addressing the elephant in the room (elephant: why is software so much harder to build correctly than, say, hardware?)&lt;/p&gt;

&lt;p&gt;CL has restarts which are error handlers that are more powerful than what can be found in most languages. This power comes from the fact that Lispers can think in any paradigm they choose &amp;#8212; most languages flog a certain paradigm to exclusion of all else (e.g. Smalltalk and OO, PROLOG and relational, etc.). The multi-paradigmatic nature of Lisp comes from the fact that Lisp has no syntax. A Lisper can invent a syntax (using functions and macros) for any paradigm. OTOH, the lack of syntax in Lisp is very closely related to Assembler. Some people love the power, others hate it. Some programmers loved to program in assembler and others hated it. The circle is being closed again, with the advent of CPS&lt;a href=&quot;#fn:2&quot; id=&quot;fnref:2&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; and WASM&lt;a href=&quot;#fn:3&quot; id=&quot;fnref:3&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;People did not make a distinction between high-level languages for human readability and high-level languages for machine readability (high-level assembler) and debugging (mostly for humans).&lt;/p&gt;

&lt;p&gt;Note that just about every interesting advance in CSC started out life as Lisp (e.g. GHC &amp;#8211;&amp;gt; Haskell, Lisp &amp;#8211;&amp;gt; JavaScript). Researchers should be prohibited from using anything but Lisp and, researchers should be prohibited from providing their &amp;#8220;languages&amp;#8221; to mortal programmers. (E.G. I can&amp;#8217;t imagine a JS programmer using Haskell, nor AGDA, nor Idris, nor PROLOG, nor &amp;#8230; [Research is about defining the Universe of Programming Languages, whereas Programming Language design is about creating a useful compromise (JavaScript ain&amp;#8217;t it ; is HTML+CSS &lt;em&gt;it&lt;/em&gt;?).]).&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;SCN means Solution Centric Notation. &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:2&quot;&gt;
&lt;p&gt;CPS means Continuation Passing Style &amp;#8211; the ultimate GOTO. https://en.wikipedia.org/wiki/Continuation&amp;#8211;passing_style#:~:text=In%20functional%20programming%2C%20continuation%2Dpassing,the%20form%20of%20a%20continuation.&amp;amp;text=When%20the%20CPS%20function%20has,this%20value%20as%20the%20argument. &lt;a href=&quot;#fnref:2&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:3&quot;&gt;
&lt;p&gt;WASM mean Web Assembly. https://webassembly.org/ &lt;a href=&quot;#fnref:3&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Common Lisp Complexities</summary></entry><entry><title type="html">Clojure</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Clojure.html" rel="alternate" type="text/html" title="Clojure" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Clojure</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Clojure.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Clojure&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;clojure&quot;&gt;Clojure&lt;/h1&gt;

&lt;p&gt;[&lt;em&gt;What do you think of Clojure?&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;I like Lisp (and CL) because it is multi-paradigm. Clojure is single-paradigm (FP).&lt;/p&gt;

&lt;p&gt;Again, I like languages that I can write code to write code in.&lt;/p&gt;

&lt;p&gt;Most people want languages that are human-readable. But, that stunts growth in the field of programming - growth stops at what the language designer imagined.&lt;/p&gt;

&lt;p&gt;PEG+Lisp is a powerful combination - multiple syntaxes built on top of HLL assembler (I use the phrase &amp;#8220;toolbox language&amp;#8221; to mean &amp;#8220;HL assembler&amp;#8221;). Syntaxes can be tuned to a specific problem instead of only what Guido van Rossum could imagine (something which doesn&amp;#8217;t fit most problems).&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Clojure</summary></entry><entry><title type="html">Backtracking, mathematics, reversability, garbage collection, time Sharing</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Backtracking,-Mathematics,-Reversability,-Garbage-Collection,-Time-Sharing.html" rel="alternate" type="text/html" title="Backtracking, mathematics, reversability, garbage collection, time Sharing" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Backtracking,%20Mathematics,%20Reversability,%20Garbage%20Collection,%20Time-Sharing</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Backtracking,-Mathematics,-Reversability,-Garbage-Collection,-Time-Sharing.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Backtracking, Mathematics, Reversability, Garbage Collection, Time-Sharing&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;backtracking&quot;&gt;Backtracking&lt;/h1&gt;

&lt;p&gt;I&amp;#8217;ve stopped using the phrase &amp;#8220;backtracking&amp;#8221; and try to use the phrase &amp;#8220;exhaustive search&amp;#8221;. Backtracking is an implementation detail, &amp;#8220;exhaustive search&amp;#8221; is a semantic concept that doesn&amp;#8217;t imply how it&amp;#8217;s implemented.&lt;/p&gt;

&lt;p&gt;Note that Microsoft Word has had &amp;#8220;exhaustive search&amp;#8221; for a loooong time (WordStar had it before Word. Ed/vi/emacs?). Grep could do exhaustive search. We should&amp;#8217;a turned left at Albuquerque (&lt;em&gt;Bugs Bunny&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Mathematics notation employs exhaustive search. The strive for immutability is in aid of exhaustive search.&lt;/p&gt;

&lt;p&gt;Mathematics is 2 things: (1) a pencil-and-paper notation that employs exhaustive search and (2) a body of experience with using that notation.&lt;/p&gt;

&lt;p&gt;Reversability. Who cares? No one asked for reversability, but it was a side-effect of immutability and now has risen to the level of an ideology.&lt;/p&gt;

&lt;p&gt;Reversability can be used to solve one class of problems - UNDO. Should we be forced to bolt UNDO into every app? We seem to force ourselves to bolt time-sharing into every app. Is this a good thing? (If we were allowed to use multiple paradigms, we would be able to choose time-sharing and UNDO when we actually needed it, instead of having it built-into every language we use).&lt;/p&gt;

&lt;p&gt;Garbage collection might have been the latest useful feature that we invented. Is UNDO in that same class? (I don&amp;#8217;t know, this is rhetorical question).&lt;/p&gt;

&lt;p&gt;Time-sharing came about due to premature optimization (we optimized CPU usage instead of believing in Moore&amp;#8217;s Law). Are we making the same mistake again?&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Backtracking, Mathematics, Reversability, Garbage Collection, Time-Sharing</summary></entry><entry><title type="html">Actors</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Actors.html" rel="alternate" type="text/html" title="Actors" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Actors</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Actors.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Actors&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;actors&quot;&gt;Actors&lt;/h1&gt;

&lt;p&gt;Actors are single-paradigm.&lt;/p&gt;

&lt;p&gt;Not all kinds of solutions fit, cleanly, into the Actors paradigm.&lt;/p&gt;

&lt;p&gt;For example, &lt;em&gt;printf&lt;/em&gt; and JS back-tick strings are pretty good at formatting output. OO, FP, Actors, PROLOG, etc.. don&amp;#8217;t make it easier to format output.&lt;/p&gt;

&lt;p&gt;For example, REGEX is pretty good at matching text. OO, FP, Actors, PROLOG, etc., don&amp;#8217;t make it easier to match text. REGEX breaks down into an unreadable mess when patterns become complicated. Maybe there is something better than REGEX for use in such cases? Not OO, not FP, not Actors, et al. PEG comes to mind.&lt;/p&gt;

&lt;h1 id=&quot;scns&quot;&gt;SCNs&lt;/h1&gt;

&lt;p&gt;My emphasis is on solving problems by creating specific notations for specific problem and having a bunch of paradigms in one&amp;#8217;s toolbelt. This attitude is very different from the language, heavy-weight language, design paradigm that is in vogue. Paradigms are interesting and hard to learn. Languages &amp;#8212; syntax &amp;#8212; are noise.&lt;/p&gt;

&lt;p&gt;What if building a compiler was easy?&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What if all notations were as easy-to-use as REGEX?&lt;/p&gt;

&lt;p&gt;Paradigms should not be dumbed down to assembler. Maybe each paradigm could come with a suggested syntax? Maybe we could just mix-and-match paradigms and suggested syntaxes?&lt;/p&gt;

&lt;p&gt;What if we could use many paradigms &amp;#8212; and many syntaxes &amp;#8212; to solve one problem?&lt;/p&gt;

&lt;p&gt;What if SCN-building was so cheap that we could just switch to any paradigm we wanted for a given problem? For example, using REGEX to input line-oriented data, PROLOG to perform queries, and printf to write out reports.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;https://guitarvydas.github.io/2021/04/26/What&amp;#8211;If&amp;#8211;Making&amp;#8211;A&amp;#8211;Compiler&amp;#8211;Was&amp;#8211;Easy.html &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Actors</summary></entry><entry><title type="html">Toolbox languages (2)</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Toolbox-Languages-(2).html" rel="alternate" type="text/html" title="Toolbox languages (2)" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Toolbox%20Languages%20(2)</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Toolbox-Languages-(2).html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot;&gt;
  &lt;title&gt;Toolbox Languages (2)&lt;/title&gt;
  &lt;meta name=&quot;CreationTime&quot; content=&quot;2021-04-28T11:12:31Z&quot;&gt;
  &lt;meta name=&quot;ModificationTime&quot; content=&quot;2021-04-28T11:12:31Z&quot;&gt;
  &lt;meta name=&quot;Generator&quot; content=&quot;Cocoa HTML Writer&quot;&gt;
  &lt;meta name=&quot;CocoaVersion&quot; content=&quot;1894.6&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; min-height: 18.0px}
    li.li4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino}
    span.s1 {font: 9.0px Palatino}
    ol.ol1 {list-style-type: decimal}
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;width: 600px; margin: 0 auto&quot;&gt;

&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Toolbox Languages&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;The thing I call &lt;i&gt;toolbox languages&lt;/i&gt; is a form of high-level assembler (!).&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Toolbox languages strive for &lt;i&gt;machine&lt;/i&gt;-readability instead of &lt;i&gt;human&lt;/i&gt;-readability.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Machine-readability comes from expunging edge-cases.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Machine-&lt;i&gt;writability&lt;/i&gt; comes from expunging edge-cases, too.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;I want to write code that writes code. &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;I want to write comments that write code.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Relational Programming vs. Software Atoms&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;I think that Relational Programming is the &lt;i&gt;atom &lt;/i&gt;of the 1&lt;span class=&quot;s1&quot;&gt;&lt;sup&gt;st&lt;/sup&gt;&lt;/span&gt; step in software design.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;There are only 2 steps:&lt;/p&gt;
&lt;ol class=&quot;ol1&quot;&gt;
  &lt;li class=&quot;li4&quot;&gt;read (gather, breathe-in)&lt;/li&gt;
  &lt;li class=&quot;li4&quot;&gt;write (emit, output, breathe-out).&lt;/li&gt;
&lt;/ol&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Relational programming is well-suited to step (1) but is not well-suited for step (2).&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Yes, it is &lt;i&gt;possible&lt;/i&gt; to perform step (2) using &lt;i&gt;only&lt;/i&gt; relational programming, but it is simpler to express step (2) in some other form, even &lt;i&gt;printf&lt;/i&gt; is better (!) at this.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;I favour choosing the right paradigm for the job, instead of choosing one paradigm for all jobs.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Appendix - Toolbox Languages&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;Further discussion&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/03/16/Toolbox-Languages.html&quot;&gt;https://guitarvydas.github.io/2021/03/16/Toolbox-Languages.html&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Toolbox Languages (2)</summary></entry></feed>