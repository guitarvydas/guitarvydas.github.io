<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://computingsimplicity.neocities.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://computingsimplicity.neocities.org/" rel="alternate" type="text/html" /><updated>2021-05-03T18:30:54-04:00</updated><id>https://computingsimplicity.neocities.org/feed.xml</id><title type="html">Computing Simplicity</title><subtitle>Various thoughts on making programming simpler, and, breaking programming down into several disciplines: Architecture, Engineering, Implementation.  Concurrency is not parallelism and concurrency is not multitasking.</subtitle><entry><title type="html">Software components 101</title><link href="https://computingsimplicity.neocities.org/2021/05/03/Software-Components-101.html" rel="alternate" type="text/html" title="Software components 101" /><published>2021-05-03T00:00:00-04:00</published><updated>2021-05-03T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/03/Software%20Components%20101</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/03/Software-Components-101.html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot;&gt;
  &lt;title&gt;Software Components 101&lt;/title&gt;
  &lt;meta name=&quot;CreationTime&quot; content=&quot;2021-05-03T18:30:43Z&quot;&gt;
  &lt;meta name=&quot;ModificationTime&quot; content=&quot;2021-05-03T18:30:43Z&quot;&gt;
  &lt;meta name=&quot;Generator&quot; content=&quot;Cocoa HTML Writer&quot;&gt;
  &lt;meta name=&quot;CocoaVersion&quot; content=&quot;1894.6&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p7 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo}
    p.p8 {margin: 0.0px 0.0px 0.0px 36.0px; font: 11.0px Menlo; min-height: 13.0px}
    p.p9 {margin: 0.0px 0.0px 0.0px 36.0px; font: 13.0px Palatino; min-height: 18.0px}
    span.s1 {font: 13.0px Palatino}
    span.s2 {font: 11.0px Menlo}
    span.s3 {text-decoration: underline}
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;width: 600px; margin: 0 auto&quot;&gt;

&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Software Components 101&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;This essay introduces some of the concepts of Software Components.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;A full discussion of Software Components is fractal and recursive in nature.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;This essay is an introduction and I choose to skip some of the details.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;The key concept is that Components are &lt;i&gt;relative &lt;/i&gt;to one another and are &lt;i&gt;asynchronous&lt;/i&gt;.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;These concepts are quite different from those of most modern programming languages, but the concepts are subtle.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;I intend to draw components in SVG and I intend to show&lt;a id=&quot;fnlink1&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#fn1&quot;&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt; how to use diagrams, and SVG, as syntax (instead of characters).&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Top Level&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;img src=&quot;/assets/2021-05-03-18-30-43-Images/basic1-basic1.png&quot; width=&quot;150px&quot; height=&quot;99px&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Fig. 1 Basic Component&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Fig. 1 shows a basic software component diagram.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;This diagram represents the top level of a software Component.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;The component's name is &quot;main&quot;.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;The Component has one Input Port — &quot;in&quot; — represented by the green circle (containing the text &quot;in&quot;).&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;The Component has one Output Port — &quot;out&quot; — represented by the yellow circle (containing the text &quot;out&quot;).&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;The Port &quot;in&quot; is connected to the Port &quot;out&quot; by a line representing the flow of Events from &quot;in&quot; to &quot;out&quot;.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;[&lt;i&gt;Most lines begin at a green input and end at a yellow output.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;If we used an arrow, instead of a line, the arrow would point at the yellow output port (the direction of flow).&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;We will see that it is also possible to connect a yellow output to another yellow output and a green input to another green input, later.]&lt;/i&gt;&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;We write the name of the Component as&lt;/p&gt;
&lt;p class=&quot;p7&quot;&gt;[main]&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;the input port as&lt;/p&gt;
&lt;p class=&quot;p7&quot;&gt;(in)&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;and the output port as&lt;/p&gt;
&lt;p class=&quot;p7&quot;&gt;(out).&lt;/p&gt;
&lt;p class=&quot;p8&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;[&lt;i&gt;I.E. Component names are written in brackets, Port names are written in parentheses.&lt;/i&gt;]&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Nested&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;img src=&quot;/assets/2021-05-03-18-30-43-Images/basic1-basic2.png&quot; width=&quot;150px&quot; height=&quot;99px&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Fig. 2 Nested Component&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Fig. 2 shows a component, called &quot;subcomponent&quot; nested inside the component called &quot;main&quot;.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Inner input ports are green rectangles.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Inner output ports are yellow rectangles.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;External ports are circles, inner ports are rectangles.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;The Input Port &quot;in&quot; is connected to the inner Input Port &quot;A&quot;.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;The inner Output Port &quot;B&quot; is connected to the External Output Port &quot;out&quot;.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;[&lt;i&gt;This diagram contains two components and a total of two connections.&lt;/i&gt;]&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Nested Component in a Nested Component&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;img src=&quot;/assets/2021-05-03-18-30-43-Images/basic1-basic3.png&quot; width=&quot;150px&quot; height=&quot;78px&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Fig. 3 Component Nested in a Nested Component&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;This diagram shows 3 components.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;&quot;Component X&quot; is inside component &quot;subcomponent&quot; and component &quot;subcomponent&quot; is, itself, inside the Component &quot;main&quot;.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;The component &quot;subcomponent&quot; has an output port called &quot;#&quot;.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;The Output Port has a shadow&lt;a id=&quot;fnlink2&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#fn2&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/a&gt;.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;The shadow means that the port is connected to all sub-ports with the same name.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;We write this Port name as (*#).&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;[&lt;i&gt;We prefix the component name with *&lt;/i&gt;].&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;In this diagram, there are 3 Components and 4 connections.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;3 connections are explicit (shown as lines) and one connection is implicit ([component X].(#) connected to [subcomponent].(*#)).&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Here, we introduce another syntactical point - names can include spaces and any characters except brackets, parentheses and dots.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;For example the name of the inner-inner component is [component X]. &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Names are &lt;i&gt;relative&lt;/i&gt;.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;See the section Relative Naming below.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;It is easier to think of the above diagram as being subdivided into several layers, eliding the inner details at each layer. &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;The topmost layer might be thought of as:&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;img src=&quot;/assets/2021-05-03-18-30-43-Images/basic1-basic3 (0).png&quot; width=&quot;150px&quot; height=&quot;78px&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Fig. 4 Component Nested in a Nested Component&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;whereas the inner layer might be thought of as:&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;img src=&quot;/assets/2021-05-03-18-30-43-Images/basic1-basic3 (1).png&quot; width=&quot;150px&quot; height=&quot;77px&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Fig. 5 Component Nested in a Nested Component&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;The detail to note is the &lt;i&gt;self [.]&lt;/i&gt; is relative, not absolute.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;Hence, [.] refers to [subcomponent] or to [component X], depending on context.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Copied Component&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;img src=&quot;/assets/2021-05-03-18-30-43-Images/basic1-basic4.png&quot; width=&quot;150px&quot; height=&quot;133px&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Fig. 2 Copied Component&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Fig. 2 shows a simple COPY/PAST of [subcomponent].&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;The Component [main] contains two clones of the component [subcomponent].&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;Relative naming makes this possible and simple and easy.&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Composite vs. Leaf Components&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;Components can contain other components (e.g. &lt;i&gt;composition&lt;/i&gt;).&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Such components are call &lt;i&gt;composite&lt;/i&gt; &lt;i&gt;components&lt;/i&gt;.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Composite Components, once invoked, run until all of their children have subsided.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Components that do not contain other components, or are implemented in some other language (other than &lt;span class=&quot;s2&quot;&gt;dasl&lt;/span&gt;), are called &lt;i&gt;leaf components&lt;/i&gt;.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Leaf Components are like black boxes.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;When they are invoked, they run to completion (one input event only).&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;We do not &quot;see&quot; — at the &lt;span class=&quot;s2&quot;&gt;dasl&lt;/span&gt; level — the inner workings of &lt;i&gt;Leaf Components.&lt;/i&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Asynchronous&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;Components are asynchronous.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Components may only communicate by sending events to their output ports.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Event delivery is, conceptually, not implemented as CALL / RETURN.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Event delivery occurs in two phases,&lt;a id=&quot;fnlink3&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#fn3&quot;&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/a&gt; see &lt;a href=&quot;https://guitarvydas.github.io/2020/12/09/CALL-RETURN-Spaghetti.html&quot;&gt;https://guitarvydas.github.io/2020/12/09/CALL-RETURN-Spaghetti.html&lt;/a&gt;).&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;[&lt;i&gt;It might help to think of closures with input queues and a distinguished routine, called the Dispatcher, that invokes closures that are ready.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;This concept is not very different from processes and scheduling found in most operating systems, but it can be implemented in a more light-weight manner (there is no requirement for full preemption).&lt;/i&gt;]&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Run to Completion&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;Components consume one input event at a time.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Components process each input event to completion before popping another input event from their input queues.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;[&lt;i&gt;Note that components can be broken up into pieces which are coordinated by event arrival.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;Events invoke only one piece of a Component at a time and &quot;running to completion&quot; means that only one piece completes running.&lt;/i&gt;]&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Ready / Busy&lt;/b&gt;&lt;/h2&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Syntax Details&lt;/b&gt;&lt;/h2&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Dot Syntax&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;We write a component / port pair as&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p7&quot;&gt;[ … ] . ( … )&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;I.E. the Component name is enclosed in brackets, the Port name is enclosed in parentheses and the &lt;i&gt;dot&lt;/i&gt; operator joins the two (much like the field operator in most textual OO languages).&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Self Component&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;The &lt;i&gt;self&lt;/i&gt; Component has a special name &quot;.&quot; and is written as&lt;/p&gt;
&lt;p class=&quot;p7&quot;&gt;[.]&lt;/p&gt;
&lt;p class=&quot;p8&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Reference to a Port of a &lt;i&gt;self &lt;/i&gt;Component looks like&lt;/p&gt;
&lt;p class=&quot;p7&quot;&gt;[.].(A)&lt;/p&gt;
&lt;p class=&quot;p8&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;[&lt;i&gt;We want machine readability first, human readability second.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;The important point is that Components and Ports have a different syntax which is always the same.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;The namespace of Input Ports can overlap with the namespace of Output Ports.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;Syntax is easy to change, if you don't like the above&lt;/i&gt;.]&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Green vs. Yellow&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;Green is defined as any colour where the R component is &amp;lt;#80 and the G component is &amp;gt;= #80.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Yellow is defined as any colour where the R component is &amp;gt;= #80 and the G component is &amp;gt;= #80.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Relative Naming&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;Component names are constructed in a relative manner, by prefixing each component name with its parent component, followed by a space followed by the Component's name.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;For example, we would refer to the inner-inner Component of Nested Component in a Nested Component, as&lt;/p&gt;
&lt;p class=&quot;p7&quot;&gt;[main subcomponent component X].&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;This convention does not apply to Port names, since Port names are always internally distinguished by the Component that they belong to, e.g. the Port (c) in Nested Component in a Nested Component is written as:&lt;/p&gt;
&lt;p class=&quot;p7&quot;&gt;[main subcomponent component X].(c)&lt;/p&gt;
&lt;p class=&quot;p9&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Kinds vs. Names&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;What we have been calling Component &lt;i&gt;names&lt;/i&gt; are actually Component &lt;i&gt;kinds&lt;/i&gt; — much like their type or class.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;In most cases, there is only one Component of a given kind on a diagram&lt;a id=&quot;fnlink4&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#fn4&quot;&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;In the cases where there is more than one Component of a given kind, the components are written as digits, starting at 1, in the order of declaration of the Components (component declarations will be discussed elsewhere).&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;For example, in Copied Component, the [main] Component has two copies of [subcomponent].&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;They are written as&lt;/p&gt;
&lt;p class=&quot;p7&quot;&gt;[1]…&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;and&lt;/p&gt;
&lt;p class=&quot;p7&quot;&gt;[2]…&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;(Internally, the components are further distinguished by their (x,y) coordinates and are unique).&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;Note that &lt;span class=&quot;s2&quot;&gt;[subcomponent]&lt;/span&gt; has only one copy of &lt;span class=&quot;s2&quot;&gt;[component X]&lt;/span&gt; inside of it, so &lt;span class=&quot;s2&quot;&gt;[component X]&lt;/span&gt; is &lt;span class=&quot;s3&quot;&gt;not&lt;/span&gt; written in a qualified manner in the implementation of &lt;span class=&quot;s2&quot;&gt;[subcomponent]&lt;/span&gt;.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;[&lt;i&gt;Hopefully this will become more clear with more examples.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;We are using &lt;/i&gt;&lt;span class=&quot;s3&quot;&gt;&lt;i&gt;relative&lt;/i&gt;&lt;/span&gt;&lt;i&gt; naming, whereas most modern programming languages use &lt;/i&gt;&lt;span class=&quot;s3&quot;&gt;&lt;i&gt;absolute&lt;/i&gt;&lt;/span&gt;&lt;i&gt; naming.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;All naming and namespacing is relative to the immediate parent Component.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;Another subtlety is that we are splitting each component up into 3 specifications — signature, children, connections — whereas most modern programming languages attempt to consolidate all code into flat, not relative, specifications&lt;/i&gt;]&lt;/p&gt;
&lt;hr&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;a id=&quot;fn1&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#fnlink1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;In a following essay.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;If one looks at SVG, it should become apparent how to use SVG as syntax.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;Instead of characters, I use a syntax composed of rects, circles, ellipses, lines and text. I call this DaS (Diagrams as Syntax).&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;a id=&quot;fn2&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#fnlink2&quot;&gt;&lt;span class=&quot;s1&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;In fact, I will begin using a stroke-width of 3, which is more easily represented and recognized in SVG.&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;a id=&quot;fn3&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#fnlink3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;Notably, event receivers are not immediately executed once an event arrives.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;It is best to think of events as (1) being placed on input queues and (2) Component execution being coordinated by a Scheduler (separate from event delivery).&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;a id=&quot;fn4&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#fnlink4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;[4]&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;If this seems anti-intuitive, note that diagrams represent Software Architecture, not Code.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;In practice, Architectures tend to have only one of each kind of thing on a diagram.&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;/span&gt;(If you are thinking of &quot;+&quot; Components, then you are thinking about Code, not Architecture).&lt;/p&gt;
&lt;/div&gt;
&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Software Components 101</summary></entry><entry><title type="html">Mutable variables and flags</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Mutable-Variables-and-Flags.html" rel="alternate" type="text/html" title="Mutable variables and flags" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Mutable%20Variables%20and%20Flags</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Mutable-Variables-and-Flags.html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot;&gt;
  &lt;title&gt;Mutable Variables and Flags&lt;/title&gt;
  &lt;meta name=&quot;CreationTime&quot; content=&quot;2021-04-28T10:51:25Z&quot;&gt;
  &lt;meta name=&quot;ModificationTime&quot; content=&quot;2021-04-28T10:51:25Z&quot;&gt;
  &lt;meta name=&quot;Generator&quot; content=&quot;Cocoa HTML Writer&quot;&gt;
  &lt;meta name=&quot;CocoaVersion&quot; content=&quot;1894.6&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; min-height: 18.0px}
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;width: 600px; margin: 0 auto&quot;&gt;

&lt;p class=&quot;p1&quot;&gt;Programmers use mutable variables, but, the practice causes trouble.&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;One use of mutable variables is to create flags.&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;Wouldn't it be nice if there were a declarative way to express flags?&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;I think that parsers do this.&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;I discuss the issues in &lt;a href=&quot;https://guitarvydas.github.io/2021/04/28/Parsing-vs-FP-Pattern-Matching.html&quot;&gt;https://guitarvydas.github.io/2021/04/28/Parsing-vs-FP-Pattern-Matching.html&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;[&lt;i&gt;Q: What else, if anything, are mutable variables used for?&lt;/i&gt;]&lt;/p&gt;
&lt;/div&gt;
&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Mutable Variables and Flags</summary></entry><entry><title type="html">Function or list?</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Function-or-List.html" rel="alternate" type="text/html" title="Function or list?" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Function%20or%20List</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Function-or-List.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Function or List?&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;lisp&quot;&gt;lisp&lt;/h1&gt;

&lt;p&gt;Is this a function or a list?&lt;/p&gt;

&lt;p&gt;(rectangle id1 nil)&lt;/p&gt;

&lt;p&gt;Actually, it&amp;#8217;s a bit more convoluted than that. Lisp was one of the first (if not first) &amp;#8220;homoiconic languages&amp;#8221;.&lt;/p&gt;

&lt;p&gt;Programs are stored as lists of atoms (and lists, and, &amp;#8230;)&lt;/p&gt;

&lt;p&gt;&amp;#8220;Eval&amp;#8221; (as in Read-Eval-Print-Loop) is used to impart &lt;em&gt;meaning&lt;/em&gt; to the lists.&lt;/p&gt;

&lt;p&gt;So, in actuality, &amp;#8220;(rectangle id1 nil)&amp;#8221; is just a list containing 3 atoms.&lt;/p&gt;

&lt;p&gt;Atoms that look like symbols are hashed, for efficiency. The above list, internally, is a list of 3 hash-codes, e.g. *list(hash-code-for-rectangle,hash-code-for-id1,hash-code-for-nil*).&lt;/p&gt;

&lt;p&gt;Lisps are also classified by their packaging strategy, e.g. Lisp2&amp;#8217;s vs Lisp1&amp;#8217;s. Lisp2&amp;#8217;s have several name-spaces and allow the same symbol (hash-code) to be used in different contexts, while Lisp1&amp;#8217;s have only one namespace into which all symbols are poured (and must be unique from one another). CL is a Lisp2.&lt;/p&gt;

&lt;p&gt;Eval() attempts to interpret the first item of a list as a function. Eval accepts a list, the symbol LAMBDA and any other symbol as the first item. If the first item is a symbol, eval() digs through the properties of the symbol looking for a function thing, and when it finds such a property it applies the function thing to the rest of the list (the args).&lt;/p&gt;

&lt;p&gt;Symbols, like rectangle, have &amp;#8220;1st class&amp;#8221; functions stored in them under their function properties.&lt;/p&gt;

&lt;p&gt;Apply() never really gets to see a symbol, it only gets a 1st-class function and a list of args.&lt;/p&gt;

&lt;p&gt;In JS, we might say something like {name: rectangle, value: xyz, func: function (&amp;#8230;) { &amp;#8230;}}. I.E. &amp;#8220;rectangle&amp;#8221; can have a value AND it can have a function. Which property gets used is determined by the context (and, by the interpretation of the context).&lt;/p&gt;

&lt;p&gt;The &amp;#8220;type&amp;#8221; of &amp;#8220;rectangle&amp;#8221; is SYMBOL, and, things of type SYMBOL have several properties, including VALUE and FUNCTION.&lt;/p&gt;

&lt;h1 id=&quot;prolog&quot;&gt;PROLOG&lt;/h1&gt;

&lt;p&gt;In PROLOG we don&amp;#8217;t need to declare a rectangle type. PROLOG (being one of the early languages, I think it was originally built in Lisp), uses a similar hashing trick.&lt;/p&gt;

&lt;p&gt;rectangle(id1,nil).&lt;/p&gt;

&lt;p&gt;is also a bunch of hash-codes, probably stored as a Lisp-like list (hash-code-of-rectangle hash-code-of-id hash-code-of-nil). The &lt;em&gt;type&lt;/em&gt; of the above thing is &amp;#8220;functor&amp;#8221; (and &amp;#8220;functor&amp;#8221; is a lisp-like list).&lt;/p&gt;

&lt;p&gt;Lisp lists and PROLOG functors are generalized data structures. In a strongly-typed language, we would define a 3-tuple &amp;#8212; {relation, subject, object} &amp;#8212; and, we would implement these kinds of 3-tuples in a more efficient way than generalized Lisp-like lists. [Elsewhere, I argue, that this concern for this kind of efficiency is mis-placed. It&amp;#8217;s very 1960&amp;#8217;s. In 2020, we can burn CPU power to construct data structures at run-time, instead of wasting our own (programmers') time and efficiency. PROLOG is good at constructing (by inference) data structures for us. Our end-goal is always to run queries against data. If we structure our data at compile-time, we end up wasting brain-power, if we let PROLOG infer our data structures, we end up wasting CPU power. Either way, we are wasting &lt;em&gt;&amp;lt;something&amp;gt;&lt;/em&gt;. I believe that wasting CPU power is a better choice tham wasting brain-power.]&lt;/p&gt;

&lt;p&gt;PROLOG stores functors in some data structure, Lisp stores lists in some data structures. With PROLOG, we let the engine decide on the shape of the data structure, whereas in Lisp (and Python, and JS, and etc.) we decide on the shape of the data structure and hard-code it into the program.&lt;/p&gt;

&lt;p&gt;A.T.M. PROLOG is worse at guessing what the best data structure is than humans are. We can usually create data structures that are &amp;#8220;better&amp;#8221; (more efficient) than what PROLOG decides to use under-the-hood.&lt;/p&gt;

&lt;p&gt;But, that&amp;#8217;s what Assembler programmers said until GCC came along. At some point, automation catches up with the best manually-written code created by humans.&lt;/p&gt;

&lt;p&gt;Take-aways:&lt;/p&gt;

&lt;p&gt;(rectangle id1 nil) is just a list of atoms (hash-codes) in Lisp.&lt;/p&gt;

&lt;p&gt;rectangle(id,nil) is just a &amp;#8220;functor&amp;#8221; of atoms (hash-codes) in PROLOG.&lt;/p&gt;

&lt;p&gt;Both are sufficiently general data structures for &amp;#8220;normalization&amp;#8221;.&lt;/p&gt;

&lt;p&gt;PROLOG (and Lisp) are not as good as today&amp;#8217;s programmers, but automation techniques will catch up.&lt;/p&gt;

&lt;p&gt;Let PROLOG do your work for you. Don&amp;#8217;t worry about preemptive efficiency, let them (and their compilers) catch up with what you&amp;#8217;re doing.&lt;/p&gt;

&lt;h1 id=&quot;now&quot;&gt;Now&lt;/h1&gt;

&lt;p&gt;If you need to deliver something today, write a design using factbases, then hire an Optimization Engineer to fixup the inefficiencies (after using a profiler ; (unprofiled Rust code ain&amp;#8217;t gonna be much help)). If you can&amp;#8217;t afford to hire an Optimization Engineer (and/or you don&amp;#8217;t know what that is), then do it all yourself, but, do yourself a favour and create the design in layers. The goals of Architecting and Engineering should be to write as little code as possible (e.g. using an SCN) and to maximize the time allotted to &lt;em&gt;thinking-things-through&lt;/em&gt;. Implementation should use &lt;em&gt;no&lt;/em&gt; thought-time at all - the measure of Implementors is how fast they can create code (keyboarding skill, etc.). Implementors should never have to stop and think about a Design. All Design thinking needs to punted back upwards to Architects and Engineers and whiteboards. (Implementors punt back to Engineers, Engineers either clarify the details or punt back to Architects for clarifications of the Design).&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Function or List?</summary></entry><entry><title type="html">First class functions</title><link href="https://computingsimplicity.neocities.org/2021/04/28/First-Class-Functions.html" rel="alternate" type="text/html" title="First class functions" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/First%20Class%20Functions</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/First-Class-Functions.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;First Class Functions&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;first-classfunctions&quot;&gt;First-Class Functions&lt;/h1&gt;

&lt;p&gt;I don&amp;#8217;t think that mortal programmers should be allowed to use 1st-class. They are no better than C&amp;#8217;s &amp;#8220;(*f)(x, y z)&amp;#8221; stuff. (case in point: the JS-callbacks-using-anonymous-functions disaster)&lt;/p&gt;

&lt;p&gt;CPS is just another kludgy attempt at making 1st-class functions more palatable to human programmers.&lt;/p&gt;

&lt;p&gt;1st class functions *are* incredibly useful in toolbox languages, (aka High Level Assembler). 1st-class functions make it easier to create syntaxes (SCNs) with specific control flows.&lt;/p&gt;

&lt;p&gt;People are &amp;#8220;in love&amp;#8221; with 1st class functions, CPS, promises, etc. They don&amp;#8217;t notice, though that this is the same &amp;#8220;power&amp;#8221; as assembler put in programmers' hands in the '70&amp;#8217;s.&lt;/p&gt;

&lt;p&gt;Case-in-point: most programmers think that &amp;#8220;multitasking is hard&amp;#8221; and throw up their hands and just accept scraps from the dinner table. In fact, multitasking is easy, but you need to use an appropriate notation (SCN). Kids learn multitasking at the age of 5 (e.g. music notation). Only programmers think that multitasking is hard. Square peg, round hole.&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">First Class Functions</summary></entry><entry><title type="html">Exhaustive search</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Exhaustive-Search.html" rel="alternate" type="text/html" title="Exhaustive search" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Exhaustive%20Search</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Exhaustive-Search.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Exhaustive Search&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;exhaustivesearch&quot;&gt;Exhaustive Search&lt;/h1&gt;

&lt;p&gt;We should do exhaustive search everywhere. I suggest using PROLOG (swipl) and Kanren in stunted form - triples only, exhaustive search of triples. I have ported PROLOG (the good parts) to JS using Ohm-JS (from Scheme) and it would take only an afternoon or so to change the text emitter to emit just about any other language (e.g. Python, Haskell, etc.).&lt;/p&gt;

&lt;p&gt;Note that exhaustive search enables relational. Relational enables Haskell et al.&lt;/p&gt;

&lt;p&gt;Note that diagrams enable the breakdown of Software Development into Architecting, Engineering, Implementation, Testing, etc.&lt;/p&gt;

&lt;p&gt;I change my mind and have new revelations daily. I have refined what I said a year ago.&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Exhaustive Search</summary></entry><entry><title type="html">Common lisp complexities</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Common-Lisp-Complexities.html" rel="alternate" type="text/html" title="Common lisp complexities" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Common%20Lisp%20Complexities</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Common-Lisp-Complexities.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Common Lisp Complexities&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;complexitiesofcl&quot;&gt;Complexities of CL&lt;/h1&gt;

&lt;h2 id=&quot;whatwerethecomplexitiesthatwereaddedtocommonlisp&quot;&gt;What were the complexities that were added to Common Lisp?&lt;/h2&gt;

&lt;p&gt;The main complexity was the switch from dynamic scoping to static scoping.&lt;/p&gt;

&lt;p&gt;This allowed Lisp to be compiled. Up until then, many Lisps were only interpreted. One of the biggest knocks against Lisp was that it was interpreted, and, everyone was worried about efficiency and thought that they would write more-efficient code if they used C instead of Lisp. If you squint hard enough, you will see that operating systems are manually-written versions of Lisp and are wildly inefficient (processes instead of closures (in fact, closures weren&amp;#8217;t even necessary in early Lisps - their existence is driven by the goal of compilation)).&lt;/p&gt;

&lt;p&gt;A second complication was the invention of packages. Packages in CL are much more detailed than packages in other languages. In CL, packages are based on symbols instead of being mostly syntactic constructs. The way that packages interact with the reader make it harder to write SCNs&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; in CL.&lt;/p&gt;

&lt;p&gt;C had scoping rules that worked OK. Names (variables and functions) were invisible outside of the boundaries of a compilation unit, by default. C had globals (variables and functions), locals (variables mostly) and parameters (variables mostly).&lt;/p&gt;

&lt;p&gt;A third complication was macros. People were experimenting with writing code that writes code and that was distilled down into macros. Lisp macros are much more powerful than macros in most other languages. Lisp macros are, essentially, the Lisp compiler being exposed to programmers. With that power comes accidental complexity.&lt;/p&gt;

&lt;p&gt;Lisp, originally, addressed all sorts of debugging and quick prototyping issues. Then, Lisp, became schizophrenic with the standardization of CL. It still had many debugging features, but it also had efficiency (premature optimization) features.&lt;/p&gt;

&lt;p&gt;In general, CL dumbed Lisp down by addressing micro-problems instead of addressing the elephant in the room (elephant: why is software so much harder to build correctly than, say, hardware?)&lt;/p&gt;

&lt;p&gt;CL has restarts which are error handlers that are more powerful than what can be found in most languages. This power comes from the fact that Lispers can think in any paradigm they choose &amp;#8212; most languages flog a certain paradigm to exclusion of all else (e.g. Smalltalk and OO, PROLOG and relational, etc.). The multi-paradigmatic nature of Lisp comes from the fact that Lisp has no syntax. A Lisper can invent a syntax (using functions and macros) for any paradigm. OTOH, the lack of syntax in Lisp is very closely related to Assembler. Some people love the power, others hate it. Some programmers loved to program in assembler and others hated it. The circle is being closed again, with the advent of CPS&lt;a href=&quot;#fn:2&quot; id=&quot;fnref:2&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; and WASM&lt;a href=&quot;#fn:3&quot; id=&quot;fnref:3&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;People did not make a distinction between high-level languages for human readability and high-level languages for machine readability (high-level assembler) and debugging (mostly for humans).&lt;/p&gt;

&lt;p&gt;Note that just about every interesting advance in CSC started out life as Lisp (e.g. GHC &amp;#8211;&amp;gt; Haskell, Lisp &amp;#8211;&amp;gt; JavaScript). Researchers should be prohibited from using anything but Lisp and, researchers should be prohibited from providing their &amp;#8220;languages&amp;#8221; to mortal programmers. (E.G. I can&amp;#8217;t imagine a JS programmer using Haskell, nor AGDA, nor Idris, nor PROLOG, nor &amp;#8230; [Research is about defining the Universe of Programming Languages, whereas Programming Language design is about creating a useful compromise (JavaScript ain&amp;#8217;t it ; is HTML+CSS &lt;em&gt;it&lt;/em&gt;?).]).&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;SCN means Solution Centric Notation. &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:2&quot;&gt;
&lt;p&gt;CPS means Continuation Passing Style &amp;#8211; the ultimate GOTO. https://en.wikipedia.org/wiki/Continuation&amp;#8211;passing_style#:~:text=In%20functional%20programming%2C%20continuation%2Dpassing,the%20form%20of%20a%20continuation.&amp;amp;text=When%20the%20CPS%20function%20has,this%20value%20as%20the%20argument. &lt;a href=&quot;#fnref:2&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:3&quot;&gt;
&lt;p&gt;WASM mean Web Assembly. https://webassembly.org/ &lt;a href=&quot;#fnref:3&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Common Lisp Complexities</summary></entry><entry><title type="html">Clojure</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Clojure.html" rel="alternate" type="text/html" title="Clojure" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Clojure</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Clojure.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Clojure&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;clojure&quot;&gt;Clojure&lt;/h1&gt;

&lt;p&gt;[&lt;em&gt;What do you think of Clojure?&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;I like Lisp (and CL) because it is multi-paradigm. Clojure is single-paradigm (FP).&lt;/p&gt;

&lt;p&gt;Again, I like languages that I can write code to write code in.&lt;/p&gt;

&lt;p&gt;Most people want languages that are human-readable. But, that stunts growth in the field of programming - growth stops at what the language designer imagined.&lt;/p&gt;

&lt;p&gt;PEG+Lisp is a powerful combination - multiple syntaxes built on top of HLL assembler (I use the phrase &amp;#8220;toolbox language&amp;#8221; to mean &amp;#8220;HL assembler&amp;#8221;). Syntaxes can be tuned to a specific problem instead of only what Guido van Rossum could imagine (something which doesn&amp;#8217;t fit most problems).&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Clojure</summary></entry><entry><title type="html">Backtracking, mathematics, reversability, garbage collection, time Sharing</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Backtracking,-Mathematics,-Reversability,-Garbage-Collection,-Time-Sharing.html" rel="alternate" type="text/html" title="Backtracking, mathematics, reversability, garbage collection, time Sharing" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Backtracking,%20Mathematics,%20Reversability,%20Garbage%20Collection,%20Time-Sharing</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Backtracking,-Mathematics,-Reversability,-Garbage-Collection,-Time-Sharing.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Backtracking, Mathematics, Reversability, Garbage Collection, Time-Sharing&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;backtracking&quot;&gt;Backtracking&lt;/h1&gt;

&lt;p&gt;I&amp;#8217;ve stopped using the phrase &amp;#8220;backtracking&amp;#8221; and try to use the phrase &amp;#8220;exhaustive search&amp;#8221;. Backtracking is an implementation detail, &amp;#8220;exhaustive search&amp;#8221; is a semantic concept that doesn&amp;#8217;t imply how it&amp;#8217;s implemented.&lt;/p&gt;

&lt;p&gt;Note that Microsoft Word has had &amp;#8220;exhaustive search&amp;#8221; for a loooong time (WordStar had it before Word. Ed/vi/emacs?). Grep could do exhaustive search. We should&amp;#8217;a turned left at Albuquerque (&lt;em&gt;Bugs Bunny&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Mathematics notation employs exhaustive search. The strive for immutability is in aid of exhaustive search.&lt;/p&gt;

&lt;p&gt;Mathematics is 2 things: (1) a pencil-and-paper notation that employs exhaustive search and (2) a body of experience with using that notation.&lt;/p&gt;

&lt;p&gt;Reversability. Who cares? No one asked for reversability, but it was a side-effect of immutability and now has risen to the level of an ideology.&lt;/p&gt;

&lt;p&gt;Reversability can be used to solve one class of problems - UNDO. Should we be forced to bolt UNDO into every app? We seem to force ourselves to bolt time-sharing into every app. Is this a good thing? (If we were allowed to use multiple paradigms, we would be able to choose time-sharing and UNDO when we actually needed it, instead of having it built-into every language we use).&lt;/p&gt;

&lt;p&gt;Garbage collection might have been the latest useful feature that we invented. Is UNDO in that same class? (I don&amp;#8217;t know, this is rhetorical question).&lt;/p&gt;

&lt;p&gt;Time-sharing came about due to premature optimization (we optimized CPU usage instead of believing in Moore&amp;#8217;s Law). Are we making the same mistake again?&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Backtracking, Mathematics, Reversability, Garbage Collection, Time-Sharing</summary></entry><entry><title type="html">Actors</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Actors.html" rel="alternate" type="text/html" title="Actors" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Actors</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Actors.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Actors&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;actors&quot;&gt;Actors&lt;/h1&gt;

&lt;p&gt;Actors are single-paradigm.&lt;/p&gt;

&lt;p&gt;Not all kinds of solutions fit, cleanly, into the Actors paradigm.&lt;/p&gt;

&lt;p&gt;For example, &lt;em&gt;printf&lt;/em&gt; and JS back-tick strings are pretty good at formatting output. OO, FP, Actors, PROLOG, etc.. don&amp;#8217;t make it easier to format output.&lt;/p&gt;

&lt;p&gt;For example, REGEX is pretty good at matching text. OO, FP, Actors, PROLOG, etc., don&amp;#8217;t make it easier to match text. REGEX breaks down into an unreadable mess when patterns become complicated. Maybe there is something better than REGEX for use in such cases? Not OO, not FP, not Actors, et al. PEG comes to mind.&lt;/p&gt;

&lt;h1 id=&quot;scns&quot;&gt;SCNs&lt;/h1&gt;

&lt;p&gt;My emphasis is on solving problems by creating specific notations for specific problem and having a bunch of paradigms in one&amp;#8217;s toolbelt. This attitude is very different from the language, heavy-weight language, design paradigm that is in vogue. Paradigms are interesting and hard to learn. Languages &amp;#8212; syntax &amp;#8212; are noise.&lt;/p&gt;

&lt;p&gt;What if building a compiler was easy?&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What if all notations were as easy-to-use as REGEX?&lt;/p&gt;

&lt;p&gt;Paradigms should not be dumbed down to assembler. Maybe each paradigm could come with a suggested syntax? Maybe we could just mix-and-match paradigms and suggested syntaxes?&lt;/p&gt;

&lt;p&gt;What if we could use many paradigms &amp;#8212; and many syntaxes &amp;#8212; to solve one problem?&lt;/p&gt;

&lt;p&gt;What if SCN-building was so cheap that we could just switch to any paradigm we wanted for a given problem? For example, using REGEX to input line-oriented data, PROLOG to perform queries, and printf to write out reports.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;https://guitarvydas.github.io/2021/04/26/What&amp;#8211;If&amp;#8211;Making&amp;#8211;A&amp;#8211;Compiler&amp;#8211;Was&amp;#8211;Easy.html &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Actors</summary></entry><entry><title type="html">Tokenizing</title><link href="https://computingsimplicity.neocities.org/2021/04/28/Tokenizing.html" rel="alternate" type="text/html" title="Tokenizing" /><published>2021-04-28T00:00:00-04:00</published><updated>2021-04-28T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/28/Tokenizing</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/28/Tokenizing.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Tokenizing&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;tokenizing&quot;&gt;Tokenizing&lt;/h1&gt;

&lt;p&gt;I&amp;#8217;m struggling with this. I think in terms of tokenizing, but Ohm-JS fights me. I was very un-amused to discover that ESRAP only worked with characters (instead of tokens and CL forms).&lt;/p&gt;

&lt;p&gt;You can&amp;#8217;t skip whitespace unless the whitespace has been tokenized. Ohm-JS handles languages, like JS, that use commas (,). Ohm-JS creates bugs (accidental complexity) when parsing comma-less languages.&lt;/p&gt;

&lt;p&gt;My experiments with ASON parsing&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; using Ohm-JS might show how to tokenize using Ohm-JS.&lt;/p&gt;

&lt;h1 id=&quot;isolatedcomponents&quot;&gt;Isolated Components&lt;/h1&gt;

&lt;p&gt;I think in terms of isolated software components.&lt;/p&gt;

&lt;p&gt;I want to &lt;em&gt;build-and-forget&lt;/em&gt; any component.&lt;/p&gt;

&lt;p&gt;Ideally, there are no dependencies between components. Adding new components does not affect the way that old ones work.&lt;/p&gt;

&lt;p&gt;[&lt;em&gt;This is possible, but unlikely with current programming languages.&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Parsing and tokenizing is like that. The first pass should break the input into two kinds of tokens&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;whitespace&lt;/li&gt;
&lt;li&gt;non-whitespace.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then, if we want to delete whitespace, we simple drop tokens of type (1). The rest of the tokens remain the same.&lt;/p&gt;

&lt;p&gt;[&lt;em&gt;For the record, I can&amp;#8217;t bring myself to do something this simple using current languages. When I address (1), I immediately worry about counting newlines. Counting lines should, ideally, be done in another pass.&lt;/em&gt;]&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;https://guitarvydas.github.io/2021/04/10/ASON&amp;#8211;Notation&amp;#8211;Pipeline.html &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Tokenizing</summary></entry></feed>