<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://computingsimplicity.neocities.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://computingsimplicity.neocities.org/" rel="alternate" type="text/html" /><updated>2022-01-21T16:38:23-05:00</updated><id>https://computingsimplicity.neocities.org/feed.xml</id><title type="html">Computing Simplicity</title><subtitle>Various thoughts on making programming simpler, and, breaking programming down into several disciplines: Architecture, Engineering, Implementation.  Concurrency is not parallelism and concurrency is not multitasking.</subtitle><entry><title type="html">PREP Tool</title><link href="https://computingsimplicity.neocities.org/2022/01/20/PREP-Tool.html" rel="alternate" type="text/html" title="PREP Tool" /><published>2022-01-20T00:00:00-05:00</published><updated>2022-01-20T00:00:00-05:00</updated><id>https://computingsimplicity.neocities.org/2022/01/20/PREP%20Tool</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2022/01/20/PREP-Tool.html">&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prep&lt;/code&gt; is a tool for software developers.&lt;/p&gt;

&lt;p&gt;It performs batch-edits on blocks of text, bracketed by REGEXPs.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prep&lt;/code&gt; edit patterns can do things that REGEXP can’t do.&lt;/p&gt;

&lt;p&gt;For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prep&lt;/code&gt; can match and edit software source programs.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/t3dwGckJUDk&quot;&gt;Prep Tool&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/12/10/Table-of-Contents-Dec-01-2021.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">Prep is a tool for software developers.</summary></entry><entry><title type="html">Ohm in Ohm</title><link href="https://computingsimplicity.neocities.org/2022/01/18/Ohm-In-Ohm.html" rel="alternate" type="text/html" title="Ohm in Ohm" /><published>2022-01-18T00:00:00-05:00</published><updated>2022-01-18T00:00:00-05:00</updated><id>https://computingsimplicity.neocities.org/2022/01/18/Ohm-In-Ohm</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2022/01/18/Ohm-In-Ohm.html">&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;I share a grammar for Ohm and a diagram to go with it.&lt;/p&gt;

&lt;h1 id=&quot;make-work&quot;&gt;Make-Work&lt;/h1&gt;
&lt;p&gt;This grammar - ohm in Ohm - already exists in the source code for the Ohm-JS compiler.  For reasons not well understood, I backed into creating my own grammar from scratch.&lt;/p&gt;

&lt;h1 id=&quot;diagram-of-the-grammar&quot;&gt;Diagram of the Grammar&lt;/h1&gt;
&lt;p&gt;In the process, I drew myself a diagram (using draw.io) which can be seen in the &lt;a href=&quot;https://github.com/guitarvydas/ohm-parse/blob/main/ohm-grammar.svg&quot;&gt;SVG Diagram&lt;/a&gt; and in the README of the &lt;a href=&quot;https://github.com/guitarvydas/ohm-parse&quot;&gt;ohm-parse github&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;diagram-notation-for-grammars&quot;&gt;Diagram Notation for Grammars&lt;/h1&gt;
&lt;p&gt;I think that I found a consistent diagrammatic notation for all constructs in the grammar.&lt;/p&gt;

&lt;h1 id=&quot;transpiler&quot;&gt;Transpiler&lt;/h1&gt;

&lt;p&gt;I went on to build a transpiler using this grammar.&lt;/p&gt;

&lt;p&gt;I used my &lt;em&gt;glue&lt;/em&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; DSL for the transpiler.&lt;/p&gt;

&lt;h1 id=&quot;testing&quot;&gt;Testing&lt;/h1&gt;
&lt;h3 id=&quot;identity-transform&quot;&gt;Identity Transform&lt;/h3&gt;
&lt;p&gt;I began by creating an &lt;a href=&quot;https://github.com/guitarvydas/ohm-parse/blob/main/identity-ohm.glue&quot;&gt;identity transformation&lt;/a&gt; which sanity-checks the glue file by outputting the input after parsing it (a big fat no-op, but satisfying nonetheless).&lt;/p&gt;

&lt;h3 id=&quot;grammar-checking&quot;&gt;Grammar Checking&lt;/h3&gt;

&lt;p&gt;Sanity-checking the grammar was done using the &lt;a href=&quot;https://ohmlang.github.io/editor/&quot;&gt;Ohm editor&lt;/a&gt; and various test samples, culminating in testing the whole of the grammar on itself.&lt;/p&gt;

&lt;h1 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h1&gt;
&lt;p&gt;This stuff is dripping fresh and probably contains errors, but, I hope that it will be of use to someone in understanding how to create a grammar (or, at least, understanding how I do it).&lt;/p&gt;

&lt;h1 id=&quot;future&quot;&gt;Future&lt;/h1&gt;
&lt;p&gt;I intend to use this grammar to do &lt;em&gt;some&lt;/em&gt; of my editing work for me - just enough to trade off the development time against the boring task of typing a &lt;em&gt;glue&lt;/em&gt; specification for another project.&lt;/p&gt;

&lt;p&gt;The beginnings of this partial-editor can be seen in &lt;a href=&quot;https://github.com/guitarvydas/ohm-parse/blob/main/emitglue.ohm&quot;&gt;emitglue.ohm&lt;/a&gt; and &lt;a href=&quot;https://github.com/guitarvydas/ohm-parse/blob/main/emitglue.glue&quot;&gt;emitglue.glue&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I don’t intend to make the partial-editor complete.  I will stop working on it when I think that editing the result manually will take less time that tweaking emitglue.glue.&lt;/p&gt;

&lt;h2 id=&quot;cannot-use-sed-and-awk-and-regexs&quot;&gt;Cannot Use Sed and Awk and REGEXs&lt;/h2&gt;
&lt;p&gt;Normally, I would use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sed&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awk&lt;/code&gt; or regular expressions to hack code for me, but, in this case, I needed to match structured blobs of code that would be best done with something better than REGEX, i.e. by using a parser.&lt;/p&gt;

&lt;h2 id=&quot;prep&quot;&gt;Prep&lt;/h2&gt;
&lt;p&gt;I intend to use my &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prep&lt;/code&gt; &lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; tool in combination with the .ohm and .glue files to give me a command-line code hacking utility.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prep&lt;/code&gt; uses Ohm-JS to parse text code from stdin and uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;glue&lt;/code&gt;  to reformat the text code.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prep&lt;/code&gt; is also dripping fresh, but, is based on experience with previous tools like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pfr&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/12/10/Table-of-Contents-Dec-01-2021.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/04/11/Glue-Tool.html&quot;&gt;glue&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://github.com/guitarvydas/prep&quot;&gt;prep github&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">Summary I share a grammar for Ohm and a diagram to go with it.</summary></entry><entry><title type="html">Two Parts of Mathematics</title><link href="https://computingsimplicity.neocities.org/2022/01/14/Two-Parts-of-Mathematics.html" rel="alternate" type="text/html" title="Two Parts of Mathematics" /><published>2022-01-14T00:00:00-05:00</published><updated>2022-01-14T00:00:00-05:00</updated><id>https://computingsimplicity.neocities.org/2022/01/14/Two%20Parts%20of%20Mathematics</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2022/01/14/Two-Parts-of-Mathematics.html">&lt;p&gt;Mathematics consists of 2 main parts:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;the mechanics of manipulating symbols&lt;/li&gt;
  &lt;li&gt;the hard-won knowledge of what works and what doesn’t (algorithms, laws, principles, etc.).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Part 1 is simple text manipulation.&lt;/p&gt;

&lt;p&gt;Mathematics was invented when the only tools were pen and paper.&lt;/p&gt;

&lt;p&gt;The UNIX people &lt;em&gt;almost&lt;/em&gt; got part 1 by producing a set of utilities for manipulating symbols in the form of text.&lt;/p&gt;

&lt;p&gt;The “problem” with the UNIX notation was that text was only text up to end-of-line.&lt;/p&gt;

&lt;p&gt;Newline is &lt;em&gt;special&lt;/em&gt; in UNIX&lt;/p&gt;

&lt;p&gt;Lisp &lt;em&gt;almost&lt;/em&gt; got part 1, except that the symbols must be arranged as lists (CONS cells).&lt;/p&gt;

&lt;h1 id=&quot;new-math-manipulation&quot;&gt;New Math Manipulation&lt;/h1&gt;
&lt;p&gt;We need a way to manipulate symbols in a way that doesn’t make newlines and CONS cells special.&lt;/p&gt;

&lt;p&gt;Computers like to think in terms of bytes.&lt;/p&gt;

&lt;h1 id=&quot;peg&quot;&gt;PEG&lt;/h1&gt;

&lt;p&gt;How can we manipulate raw bytes?&lt;/p&gt;

&lt;p&gt;Parsers.&lt;/p&gt;

&lt;p&gt;PEG parsing makes parsing easier.&lt;/p&gt;

&lt;p&gt;PEG is a DSL for parsing.&lt;/p&gt;

&lt;p&gt;Ohm-JS is improved PEG.&lt;/p&gt;

&lt;h1 id=&quot;diagrams&quot;&gt;Diagrams&lt;/h1&gt;
&lt;p&gt;Why stop at characters?&lt;/p&gt;

&lt;p&gt;We can manipulate diagrams using computers.&lt;/p&gt;

&lt;p&gt;How can we draw diagrams and then manipulate them?&lt;/p&gt;

&lt;p&gt;A beginning might be:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;draw.io&lt;/li&gt;
  &lt;li&gt;SVG&lt;/li&gt;
  &lt;li&gt;d2f.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2022/01/14/D2F.html&quot;&gt;d2f - Diagram to Text Converter&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.npmjs.com/package/ohm-js&quot;&gt;Ohm-JS&lt;/a&gt; (see, also, my articles on PEG and Ohm-JS)&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/12/10/Table-of-Contents-Dec-01-2021.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">Mathematics consists of 2 main parts: the mechanics of manipulating symbols the hard-won knowledge of what works and what doesn’t (algorithms, laws, principles, etc.).</summary></entry><entry><title type="html">D2F - Diagram to Factbase Compiler</title><link href="https://computingsimplicity.neocities.org/2022/01/14/D2F.html" rel="alternate" type="text/html" title="D2F - Diagram to Factbase Compiler" /><published>2022-01-14T00:00:00-05:00</published><updated>2022-01-14T00:00:00-05:00</updated><id>https://computingsimplicity.neocities.org/2022/01/14/D2F</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2022/01/14/D2F.html">&lt;p&gt;This code compiles .drawio diagrams to a factbase (.pl).&lt;/p&gt;

&lt;p&gt;It does not “parse” the diagram - see d2py for that.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/F17x3lONHjY&quot;&gt;video&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/12/10/Table-of-Contents-Dec-01-2021.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">This code compiles .drawio diagrams to a factbase (.pl).</summary></entry><entry><title type="html">GC in SectorLisp</title><link href="https://computingsimplicity.neocities.org/2022/01/13/GC-in-SectorLisp.html" rel="alternate" type="text/html" title="GC in SectorLisp" /><published>2022-01-13T00:00:00-05:00</published><updated>2022-01-13T00:00:00-05:00</updated><id>https://computingsimplicity.neocities.org/2022/01/13/GC%20in%20SectorLisp</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2022/01/13/GC-in-SectorLisp.html">&lt;p&gt;Another attempt to describe the behaviour of GC in SectorLisp.&lt;/p&gt;

&lt;p&gt;This time as an animation (video without sound).&lt;/p&gt;

&lt;p&gt;Feel free to fast-forward…&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/TF0FzcBkV60&quot;&gt;GC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thanks for the feedback…&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/12/10/Table-of-Contents-Dec-01-2021.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">Another attempt to describe the behaviour of GC in SectorLisp.</summary></entry><entry><title type="html">SectorLisp</title><link href="https://computingsimplicity.neocities.org/2022/01/11/SectorLisp.html" rel="alternate" type="text/html" title="SectorLisp" /><published>2022-01-11T00:00:00-05:00</published><updated>2022-01-11T00:00:00-05:00</updated><id>https://computingsimplicity.neocities.org/2022/01/11/SectorLisp</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2022/01/11/SectorLisp.html">&lt;p&gt;&lt;a href=&quot;https://youtu.be/nZWR2ftBoA0&quot;&gt;A youtube of my description of SectorLisp&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://justine.lol/sectorlisp2/&quot;&gt;SectorLisp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/guitarvydas/sectorlisp&quot;&gt;My github SectorLisp&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">A youtube of my description of SectorLisp SectorLisp</summary></entry><entry><title type="html">Software Atoms</title><link href="https://computingsimplicity.neocities.org/2022/01/01/Software-Atoms.html" rel="alternate" type="text/html" title="Software Atoms" /><published>2022-01-01T00:00:00-05:00</published><updated>2022-01-01T00:00:00-05:00</updated><id>https://computingsimplicity.neocities.org/2022/01/01/Software%20Atoms</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2022/01/01/Software-Atoms.html">&lt;p&gt;This is WIP.&lt;/p&gt;

&lt;p&gt;I am “thinking aloud” about the primitive elements of software.&lt;/p&gt;

&lt;p&gt;I expect that the contents of this note will change with feedback and further thought.&lt;/p&gt;

&lt;p&gt;I do, though, believe in “showing my work”.  Showing intermediate results, no matter how rough.&lt;/p&gt;

&lt;p&gt;Although this article is fresh, these ideas have been percolating for several decades, influenced by my experiences in running a small software consultancy.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/guitarvydas/softwareatoms&quot;&gt;Notes in Obsidian Format&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Brief overview, follows…&lt;/p&gt;

&lt;h1 id=&quot;atoms&quot;&gt;Atoms&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Case on Type&lt;/li&gt;
  &lt;li&gt;Case on State&lt;/li&gt;
  &lt;li&gt;Case on Data Pattern&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;iteration&quot;&gt;Iteration&lt;/h1&gt;

&lt;h1 id=&quot;molecules&quot;&gt;Molecules&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;nested&lt;/li&gt;
  &lt;li&gt;spaghetti&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;energy&quot;&gt;Energy&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Control Flow
    &lt;ul&gt;
      &lt;li&gt;Synchronous Transfer of Control Flow&lt;/li&gt;
      &lt;li&gt;Asynchronous Transfer of Control Flow&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;composition-molecules&quot;&gt;Composition (Molecules)&lt;/h1&gt;

&lt;h1 id=&quot;data&quot;&gt;Data&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Datum (singular)&lt;/li&gt;
  &lt;li&gt;Bag (plural, unordered)&lt;/li&gt;
  &lt;li&gt;Proc (unit of execution, aka lambda w/o parameters and w/o retaddr)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;control-flow-composition&quot;&gt;Control Flow Composition&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;sync&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;async&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;nested&lt;/li&gt;
  &lt;li&gt;spaghetti&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">This is WIP.</summary></entry><entry><title type="html">FDD In Action</title><link href="https://computingsimplicity.neocities.org/2021/12/24/FDD-In-Action.html" rel="alternate" type="text/html" title="FDD In Action" /><published>2021-12-24T00:00:00-05:00</published><updated>2021-12-24T00:00:00-05:00</updated><id>https://computingsimplicity.neocities.org/2021/12/24/FDD-In-Action</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/12/24/FDD-In-Action.html">&lt;p&gt;“FDD” means “Failure Driven Design”.&lt;/p&gt;

&lt;p&gt;FDD can prevent future bugs.&lt;/p&gt;

&lt;p&gt;FDD is like “design rule” checking built into the dev app.&lt;/p&gt;

&lt;p&gt;I spent hours tracking down a hoary bug in my logic.&lt;/p&gt;

&lt;p&gt;I wrote:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;… (Kind, Edge, edge)
… sourceof(Edge, Sender)
… targetof(Edge, Receiver)
… (direct_contains, Parent, Edge)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Which failed silently using PROLOG rules.&lt;/p&gt;

&lt;p&gt;The final clause “… (direct_contains, Parent, Edge)” was not fulfufilled due to a bug in my logic - the outer-most container did not have a Parent.&lt;/p&gt;

&lt;p&gt;Nothing could prevent me from making this mistake, but, it is possible to prevent &lt;em&gt;other&lt;/em&gt; errors of this kind.&lt;/p&gt;

&lt;h1 id=&quot;what-i-wanted-to-say&quot;&gt;What I Wanted to Say&lt;/h1&gt;
&lt;p&gt;I wanted to say:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Forall “… (kind, Edge, edge)”, and, 
 There must be a fact “… sourceof(Edge, Sender)”, and,
 There must be a fact “… targetof(Edge, Receiver)”, and,
 There must be a fact “… (direct_contains, Parent, Edge)”
else
 fail loudly
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;what-i-really-said&quot;&gt;What I Really Said&lt;/h1&gt;

&lt;p&gt;But, I wrote:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Forall “… (Kind, Edge, edge)”
 And, if there is a fact “… sourceof(Edge, Sender)”,
 And, if there is a fact “… targetof(Edge, Receiver)”,
 And, ifthere is a fact “… (direct_contains, Parent, Edge)”
 succeed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;whats-the-difference&quot;&gt;What’s the Difference?&lt;/h1&gt;
&lt;p&gt;A subtle difference.&lt;/p&gt;

&lt;p&gt;The And version silently fails if ANY of the 4 clauses is false.&lt;/p&gt;

&lt;p&gt;Subtle bugs are the hardest to find.&lt;/p&gt;

&lt;h1 id=&quot;preventing-errors-using-fdd&quot;&gt;Preventing Errors Using FDD&lt;/h1&gt;

&lt;p&gt;Using FDD mentality, I can change the meaning of:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;… (kind, Edge, edge)
… sourceof(Edge, Sender)
… targetof(Edge, Receiver)
… (direct_contains, Parent, Edge)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To mean what I wanted and simply push a button to regenerate the whole shebang, and, raise errors for any other latent bugs of this nature.&lt;/p&gt;

&lt;h2 id=&quot;example-design-rule-check&quot;&gt;Example Design Rule Check&lt;/h2&gt;

&lt;p&gt;I can choose syntax to map to meaning - I might change the generated code to match what I wanted to say.&lt;/p&gt;

&lt;p&gt;For example, I might generate code that matched the first clause, then asserted the rest of the clauses (with appropriate error messages), e.g.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;… (kind, Edge, edge)
(… sourceof(Edge, Sender)” -&amp;gt; true ; format(user_error, “FAILURE sourceof(Edge,Sender) failed on ~w~n)”, [Edge])
(… (targetof(Edge, Receiver) -&amp;gt; true ; format(user_error, &quot;FAILURE:targetof(Edge, Receiver) ~w~n)&quot;, [Edge])
(… (direct_contains, Parent, Edge)” -&amp;gt; true ; format(user_error, &quot;FAILURE: direct_contains, Parent, Edge) ~w~n)&quot;, [Edge])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The above code looks horrible and hides the true essence of what I want to say, but, the machine doesn’t care and will check my other code for errors.&lt;/p&gt;

&lt;p&gt;I’m using PROLOG (swipl) as &lt;em&gt;assembler&lt;/em&gt; and I’m emitting assembler code (PROLOG) to do what I want.&lt;/p&gt;

&lt;p&gt;I can modify the DSL syntax, push a button, and have ALL of my code checked.&lt;/p&gt;

&lt;p&gt;I don’t need to look at the generated assembler code (PROLOG)&lt;sup id=&quot;fnref:30&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:30&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Yes, there might be cases where I want to say AND instead of “there must be a fact”.  I will modify (invent) the syntax to handle such cases.  I expect that most of my code is based on “there must be a fact” rules, with AND rules being the exception.  I intend to invent a syntax to express AND rules, and, I will use the FDD transpiler to find those cases for me (in the current code base).&lt;/p&gt;

&lt;p&gt;FDD lets me make sweeping changes such as this.&lt;/p&gt;

&lt;p&gt;I need to modify the transpiler, then I need to push a button (or invoke &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./run.bash&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Not a lot of work, but it captures one of my pervasive errors in logic…&lt;/p&gt;

&lt;p&gt;Yes, I &lt;em&gt;could&lt;/em&gt; have written the code correctly in the first place, but that would require a lot more thinking on my part (and, probably, a PhD degree).&lt;/p&gt;

&lt;p&gt;I said what I wanted to say.  Now, using FDD, my only task is to make the computer (transpiler) &lt;em&gt;do&lt;/em&gt; what I wanted…&lt;/p&gt;
&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/04/23/Failure-Driven-Design.html&quot;&gt;FDD - Failure Driven Design&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:30&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The only reason to look at the generated assembler is to debug the transpiler.  Once debugged, no one needs to look at the assembler. &lt;a href=&quot;#fnref:30&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">“FDD” means “Failure Driven Design”.</summary></entry><entry><title type="html">Project Overview</title><link href="https://computingsimplicity.neocities.org/2021/12/23/Project-Overview.html" rel="alternate" type="text/html" title="Project Overview" /><published>2021-12-23T00:00:00-05:00</published><updated>2021-12-23T00:00:00-05:00</updated><id>https://computingsimplicity.neocities.org/2021/12/23/Project%20Overview</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/12/23/Project-Overview.html">&lt;h1 id=&quot;synopsis&quot;&gt;Synopsis&lt;/h1&gt;
&lt;p&gt;This note introduces some of the projects that I am working on.&lt;/p&gt;

&lt;p&gt;I mostly work on programmer-tools and lean towards:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DaS - Diagrams as Syntax (in between textual programming and full-blown VPL)&lt;/li&gt;
  &lt;li&gt;Ohm-JS - syntax is cheap&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;video&quot;&gt;Video&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/guitarvydas/Overview&quot;&gt;for now: pull and watch video in README.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As of Dec. 23, 2021.&lt;/p&gt;

&lt;p&gt;There has been progress since then.  For example shu-das2py compiles helloworld.drawio to python code and runs it ()&lt;/p&gt;
&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">Synopsis This note introduces some of the projects that I am working on.</summary></entry><entry><title type="html">IDEs Instead of Programming Languages and Operating Systems</title><link href="https://computingsimplicity.neocities.org/2021/12/18/IDEs-Instead-of-Programming-Languages-and-Operating-Systems.html" rel="alternate" type="text/html" title="IDEs Instead of Programming Languages and Operating Systems" /><published>2021-12-18T00:00:00-05:00</published><updated>2021-12-18T00:00:00-05:00</updated><id>https://computingsimplicity.neocities.org/2021/12/18/IDEs%20Instead%20of%20Programming%20Languages%20and%20Operating%20Systems</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/12/18/IDEs-Instead-of-Programming-Languages-and-Operating-Systems.html">&lt;h1 id=&quot;the-goal&quot;&gt;The Goal&lt;/h1&gt;
&lt;p&gt;The goal of programming is to control a computer.&lt;/p&gt;
&lt;h2 id=&quot;secondary-goals&quot;&gt;Secondary Goals&lt;/h2&gt;
&lt;h3 id=&quot;secondary-goal-describe-architecture-to-other-people&quot;&gt;Secondary Goal: Describe Architecture to Other People&lt;/h3&gt;
&lt;p&gt;It is desirable to describe designs to other people.&lt;/p&gt;

&lt;p&gt;For example, in the construction industry,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Architects use drawings and 3D models to describe designs to Engineers&lt;/li&gt;
  &lt;li&gt;Engineers use blueprints to describe design details to Construction Workers (Implementors).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both of these kinds of communication - drawings, models - are used to describe aspects of the design to other people.&lt;/p&gt;

&lt;h4 id=&quot;tertiary-goal-automated-checking-of-descriptions&quot;&gt;Tertiary Goal: Automated Checking of Descriptions&lt;/h4&gt;

&lt;p&gt;In the Construction Industry, drawings are checked manually.&lt;/p&gt;

&lt;p&gt;Using computers, it becomes possible to write software that checks aspects of design documentation.&lt;/p&gt;

&lt;p&gt;Programmers and programming language designers strive to write software that checks design documents (usually in the form of textual “code”).&lt;/p&gt;

&lt;p&gt;IMO, language designers miss the fact that automated checking is only a tertiary goal.&lt;/p&gt;

&lt;h3 id=&quot;secondary-goal-production-engineering&quot;&gt;Secondary Goal: Production Engineering&lt;/h3&gt;

&lt;p&gt;Once a design has been vetted (by Architects, Engineers, Testers, etc.), the design can be optimized along a number of dimensions - this is called Production Engineering.&lt;/p&gt;

&lt;p&gt;Typically, Production Engineering in software tends towards making a low-cost version of the software, usually taking into account hardware costs that the software is to run on.&lt;/p&gt;

&lt;p&gt;Most popular so-called General Purpose programming Languages are actually DSLs for Production Engineering.  I include Haskell, Python, JavaScript, etc., etc., in this list of popular GPLs.&lt;/p&gt;

&lt;p&gt;In fact, any programming language that provides the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; operator, or, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arrays&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lists&lt;/code&gt;, or, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user-defined types&lt;/code&gt;, is usually designed as a DSL for Production Engineering.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Compilation&lt;/code&gt; is geared towards Production Engineering.  All languages can be interpreted, but, only some languages can be compiled, after making various trade-offs in the languages themselves.  Interpretation helps with Design and Vetting, Compilation helps with Production Engineering. [Note that, neither is actually geared towards only DI&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; - communicating designs to other people.]&lt;/p&gt;

&lt;h1 id=&quot;programming-languages-are-ide-wannabes&quot;&gt;Programming Languages Are IDE Wannabes&lt;/h1&gt;
&lt;p&gt;Programming languages (GPLs&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;) are only the tip of the iceberg for controlling computers.&lt;/p&gt;

&lt;h1 id=&quot;operating-systems-are-ide-wannabes&quot;&gt;Operating Systems Are IDE Wannabes&lt;/h1&gt;
&lt;p&gt;Operating systems are the only tip of the iceberg for controlling computers.&lt;/p&gt;

&lt;h1 id=&quot;ide-evolution&quot;&gt;IDE Evolution&lt;/h1&gt;
&lt;p&gt;What do we want in an IDE?&lt;/p&gt;

&lt;p&gt;Given that the primary purpose of programming is controlling computers, we want &lt;em&gt;anything&lt;/em&gt; that helps us program computers.&lt;/p&gt;

&lt;p&gt;We &lt;em&gt;don’t&lt;/em&gt; want to use only one-thing in a one-size-fits-all manner.&lt;/p&gt;

&lt;p&gt;We see this kind of desire leaking into GPL designs.&lt;/p&gt;

&lt;p&gt;For example, REGEXs&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; have leaked into some GPLs, giving those GPLs two (2) syntaxes.&lt;/p&gt;

&lt;p&gt;As an example of the evolution of IDEs, consider technologies that we already know: C++ and REGEXs.&lt;/p&gt;

&lt;p&gt;We want an IDE that has multiple windows that can produce an executable module at the push of a button.&lt;/p&gt;

&lt;p&gt;Using only the above already-known technologies, we might expect:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a window for writing REGEXs, in REGEX DSL syntax,&lt;/li&gt;
  &lt;li&gt;a window for writing replacements after REGEX matching has been successful, in REGEX replacement DSL syntax&lt;/li&gt;
  &lt;li&gt;a window for writing Production Engineering code in C++ syntax, with some sort of bauble to show where the REGEX pattern matchers pattern replacers are to be inserted.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To illustrate the point, imagine that we want to write a REGEX that replaces all “A”s with “AB”s&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;we might write /(A)/ in window 1&lt;/li&gt;
  &lt;li&gt;we might write /\1B/ in window 2&lt;/li&gt;
  &lt;li&gt;we might write some C++ in window 3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In fact, we would probably drop the “/” characters in windows 1 and 2.&lt;/p&gt;

&lt;p&gt;In the above example, parentheses are use to “remember” parts of the match, e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(A)&lt;/code&gt; remembers “A” (if matched) and gives it the name &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\1&lt;/code&gt;&lt;sup id=&quot;fnref:6&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;A simple example of a REGEX visualizer is &lt;a href=&quot;https://regex101.com&quot;&gt;regex101&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We want something like the REGEX visualizer to become our windows 1 and 2 in our progamming IDE.&lt;/p&gt;

&lt;p&gt;Of course, one could re-imagine the above using languages, like Python and JavaScript, that have REGEXs built into them.&lt;/p&gt;

&lt;h2 id=&quot;further-ideas&quot;&gt;Further Ideas:&lt;/h2&gt;

&lt;p&gt;I believe that Ohm-JS is better than REGEX.&lt;/p&gt;

&lt;p&gt;If we look at the &lt;a href=&quot;https://ohmlang.github.io/editor/&quot;&gt;Ohm-JS IDE&lt;/a&gt;, we see the beginnings of what we want in one of the windows of our futuristic IDE.&lt;/p&gt;

&lt;p&gt;We would want to augment the IDE with an Ohm-JS replacement window (a replacement rule for every grammar rule in Ohm-JS.  See the &lt;a href=&quot;https://guitarvydas.github.io/2021/04/11/Glue-Tool.html&quot;&gt;glue tool&lt;/a&gt; for POC-level ideas for a replacement DSL for Ohm-JS programs.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://guitarvydas.github.io/2021/07/30/Parsing-Diagrams-DaS-Workbench-Overview.html&quot;&gt;DaS Workbench&lt;/a&gt; for POC-level ideas on multi-window, heads-up displays for pattern matching and replacement.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://guitarvydas.github.io/2021/07/12/Transpilation.html&quot;&gt;Transpilation&lt;/a&gt; for POC-level ideas on how to transmogrify PEG into two separate parts &lt;br /&gt;
((1) grammar (2) formatting)&lt;/p&gt;

&lt;h1 id=&quot;appendix---see-also&quot;&gt;Appendix - See Also&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io&quot;&gt;Blog&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/12/01/Table-of-Contents-December-01-2021.html&quot;&gt;Table of Contents as of Dec. 01, 2021&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.youtube.com/channel/UC2bdO9l84VWGlRdeNy5&quot;&gt;Videos&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;DI means Design Intent &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;GPL means General Purpose programming Language. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;REGEX means REGular EXpression.  A technology lifted from compiler design and made popular in languages like PERL, JavaScript, etc., etc. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Standard REGEX syntax is obtuse and, IMO, write-only.  I would suggest replacements to this syntax, but, I believe that REGEX will be superceded by PEG (Ohm-JS), and, it is not worth expending time on improving the syntax. &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">The Goal The goal of programming is to control a computer. Secondary Goals Secondary Goal: Describe Architecture to Other People It is desirable to describe designs to other people.</summary></entry></feed>