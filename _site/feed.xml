<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://computingsimplicity.neocities.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://computingsimplicity.neocities.org/" rel="alternate" type="text/html" /><updated>2021-05-24T12:52:39-04:00</updated><id>https://computingsimplicity.neocities.org/feed.xml</id><title type="html">Computing Simplicity</title><subtitle>Various thoughts on making programming simpler, and, breaking programming down into several disciplines: Architecture, Engineering, Implementation.  Concurrency is not parallelism and concurrency is not multitasking.</subtitle><entry><title type="html"></title><link href="https://computingsimplicity.neocities.org/2021/05/24/2021-05-22-Software-Components-101-Part-13-Identity-Grammar-Before-Creating-Factbase.html" rel="alternate" type="text/html" title="" /><published>2021-05-24T12:52:39-04:00</published><updated>2021-05-24T12:52:39-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/24/2021-05-22-Software%20Components%20101%20Part%2013%20Identity%20Grammar%20Before%20Creating%20Factbase</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/24/2021-05-22-Software-Components-101-Part-13-Identity-Grammar-Before-Creating-Factbase.html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;We create a factbase from the nested documents&lt;/p&gt;
&lt;h2 id=&quot;identity-grammar&quot;&gt;Identity Grammar&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BRACES2FB {
  topLevel = ws+ tBEGIN rect tEND


  nestedAttributesOrObjects = tBEGIN attributeOrObject+ tEND
  attributeOrObject = attribute | object

  object = rect | ellipse | circle | arrow
  rect = tRECT synonym nestedAttributesOrObjects? ws*
  circle = tCIRCLE synonym nestedAttributesOrObjects? ws*
  ellipse = tELLIPSE synonym nestedAttributesOrObjects? ws*
  arrow = tARROW sender receiver ws*

  attribute = shapeAttribute | colorAttribute | strokeWidthAttribute
  shapeAttribute = &quot;shape&quot; ws* &quot;rounded&quot; ws*
  colorAttribute = &quot;color&quot; ws* color ws*
  strokeWidthAttribute = &quot;stroke-width&quot; ws* number ws*

  sender = qualident ws*
  receiver = qualident ws*

  synonym = qualident ws*

    /* mid-level */
    tRECT = &quot;rect&quot; ws*
    tCIRCLE = &quot;circle&quot; ws*
    tELLIPSE = &quot;ellipse&quot; ws*
    tARROW = &quot;arrow&quot; ws*

    tBEGIN = &quot;{&quot; ws*
    tEND = &quot;}&quot; ws*

      /* low-level */
      color = rgba | &quot;green&quot; | &quot;yellow&quot; | &quot;red&quot;

      keyword = color

      flat_ident = ~keyword flat_ident_char+ 
      flat_ident_char = &quot;a&quot; .. &quot;z&quot;
      qualident = qualident_recursive | flat_ident
      qualident_recursive = flat_ident &quot;/&quot; qualident

      number = dig+
      dig = &quot;0&quot; .. &quot;9&quot;
      rgba = hex hex hex hex
      hex = hd hd
      hd = dig | &quot;A&quot; .. &quot;F&quot;
 
      ws = &quot; &quot; | &quot;\t&quot; | newline
      newline = &quot;\n&quot;
}



  topLevel [@ws begin rect end] = [[${ws}${begin}${rect}${end}]]


  nestedAttributesOrObjects [begin @aorobj end] = [[${begin}${aorobj}${end}]]
  attributeOrObject [aorobj] = [[${aorobj}]]

  object [obj] = [[${obj}]]
  rect [rect syn @nested @ws] = [[${rect}${syn}${nested}${ws}]]
  circle [circle syn @nested @ws] = [[${circle}${syn}${nested}${ws}]]
  ellipse [ellipse syn @nested @ws] = [[${ellipse}${syn}${nested}${ws}]]
  arrow [arrow sender receiver @ws] = [[${arrow}${sender}${receiver}${ws}]]

  attribute [attr] = [[${attr}]]
  shapeAttribute [shape @ws1 rounded @ws2] = [[${shape}${ws1}${rounded}${ws2}]]
  colorAttribute [k @ws1 color @ws2] = [[${k}${ws1}${color}${ws2}]]
  strokeWidthAttribute [sw @ws1 n @ws2] = [[${sw}${ws1}${n}${ws2}]]

  sender [ident @ws] = [[${ident}${ws}]]
  receiver [ident @ws] = [[${ident}${ws}]]

  synonym [ident @ws] = [[${ident}${ws}]]

    tRECT [t @ws] = [[${t}${ws}]]
    tCIRCLE [t @ws] = [[${t}${ws}]]
    tELLIPSE [t @ws] = [[${t}${ws}]]
    tARROW [t @ws] = [[${t}${ws}]]

    tBEGIN [t @ws] = [[${t}${ws}]]
    tEND [t @ws] = [[${t}${ws}]]

      color [cl] = [[${cl}]]

      keyword [kw] = [[${kw}]]

      flat_ident [@cs] = [[${cs}]]
      flat_ident_char [c] = [[${c}]]
      qualident [ident] = [[${ident}]]
      qualident_recursive [flatident slash recursiveident] = [[${flatident}${slash}${recursiveident}]]

      number [num] = [[${num}]]
      dig [digit] = [[${digit}]]
      rgba [h1 h2 h3 h4] = [[${h1}${h2}${h3}${h4}]]
      hex [h1 h2] = [[${h1}${h2}]]
      hd [c] = [[${c}]]
 
      ws [c] = [[${c}]]
      newline [c] = [[${c}]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The identity grammar should produce output that is the same as the input.&lt;/p&gt;

&lt;p&gt;Check that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v.fb&lt;/code&gt; is the same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v.brace&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Eye-ball or use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diff&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Look for low-hanging fruit.&lt;/p&gt;

&lt;p&gt;[We can always come back and fix errors, so this doesn’t need to be perfect.  The only test will be if the app is good enough for its purposes.  Everything is a fractal, everything is relative, nothing is absolute.  Absolute perfection is not possible.  Trying to attain absolute perfection will retard higher-level learning and progress.  Waterfall design is the process of closing doors behind you, whereas FDD[^fdd] leaves doors open on the assumption that iteration will be needed (design iteration as well as code iteration)].&lt;/p&gt;

&lt;p&gt;[^fdd] FDD means Failure Driven Design.&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author></entry><entry><title type="html">Table of contents since may 13, 2013</title><link href="https://computingsimplicity.neocities.org/2021/05/24/Table-of-Contents-Since-May-13,-2013.html" rel="alternate" type="text/html" title="Table of contents since may 13, 2013" /><published>2021-05-24T00:00:00-04:00</published><updated>2021-05-24T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/24/Table%20of%20Contents%20Since%20May%2013,%202013</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/24/Table-of-Contents-Since-May-13,-2013.html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot;&gt;
  &lt;title&gt;Table of Contents Since May 13, 2013&lt;/title&gt;
  &lt;meta name=&quot;CreationTime&quot; content=&quot;2021-05-24T12:52:29Z&quot;&gt;
  &lt;meta name=&quot;ModificationTime&quot; content=&quot;2021-05-24T12:52:29Z&quot;&gt;
  &lt;meta name=&quot;Generator&quot; content=&quot;Cocoa HTML Writer&quot;&gt;
  &lt;meta name=&quot;CocoaVersion&quot; content=&quot;2022.44&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div style=&quot;width: 600px; margin: 0 auto&quot;&gt;

&lt;h2 style=&quot;margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica&quot;&gt;&lt;b&gt;Table Of Contents Since May 15 2021&lt;/b&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/22/Java-Takeaways.html&quot;&gt;Java Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/22/Functional-Programming-Takeaways.html&quot;&gt;Functional Programming - Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/22/First-Class-Functions-Takeaways.html&quot;&gt;First Class Functions - Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/21/Functional-Programming-vs-Parsing.html&quot;&gt;Functional programming vs parsing&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Compiler-Technology-Takeaways.html&quot;&gt;Compiler Technology Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/21/Diagram-Conventions.html&quot;&gt;Diagram Conventions&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Compiler-Technology-Takeaways-3.html&quot;&gt;Compiler Technology Takeaways 3&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/20/Thinking-Is-Hard-Coding-Is-Easy.html&quot;&gt;Thinking is Hard, Coding is Easy&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Compiler-Technology-Takeaways-2.html&quot;&gt;Compiler Technology Takeaways 2&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/API-Takeaways.html&quot;&gt;API Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/15/Software-Components-101-Part-6-Recap.html&quot;&gt;Software Components 101 Part 6 Recap&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/15/Software-Components-101-Part-7-Visual-Inspection.html&quot;&gt;Software Components 101 Part 7 - Visual Inspection&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/15/WASM-Arithmetic-Transpiler.html&quot;&gt;WASM Transpiler Example&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/DRY-vs-RY.html&quot;&gt;DRY vs. RY&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/16/Refactoring.html&quot;&gt;Refactoring&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Data-Descriptors-Takeaways.html&quot;&gt;Data Descriptors Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/16/Software-Components-101-Part-8-Ports.html&quot;&gt;Software Components 101 Part 8 - Ports&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Dataless-Language.html&quot;&gt;Dataless Language&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Denotational-Semantics-Takeaways.html&quot;&gt;Denotational Semantics Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/16/Software-Components-101-Part-9-What-Is-Next.html&quot;&gt;Software Components 101 - Part 9 - What's Next?&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Diagram-Notation.html&quot;&gt;Diagram Notation&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/20/Less-Code.html&quot;&gt;Less Code&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Layers.html&quot;&gt;Layers&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/22/Software-Components-101-Part-11-Starting-Over.html&quot;&gt;Software Components 101 - Part 11 Starting Over&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/22/Software-Components-101-Part-12-Converting-Indentation-to-Nesting.html&quot;&gt;Software Components 101 Part 12 Converting Indentation to Nesting&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/20/Software-Components-101-Part-10-Tweaking-The-Grammar-to-Provide-More-Information.html&quot;&gt;Software Components 101 - Part 10 Tweaking the Grammar to Provide More Information&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Lisp-Takeaways.html&quot;&gt;Lisp Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Normalization.html&quot;&gt;Normalization&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Object-Oriented-Takeaways.html&quot;&gt;Object Oriented Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Pattern-Matching-Takeaways.html&quot;&gt;Pattern Matching Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Relational-Programming-Takeaways.html&quot;&gt;Relational Programming Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/SSL-Takeaways.html&quot;&gt;Ssl takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Scalability-Takeaways-2.html&quot;&gt;Scalability 2&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Scalability-Takeaways.html&quot;&gt;Scalability Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/Structured-Programming-Takeaways.html&quot;&gt;Structured Programming Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/UNIX-Takeaways-2.html&quot;&gt;UNIX Takeaways 2&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/23/UNIX-Takeaways.html&quot;&gt;UNIX Takeaways&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;br&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/05/24/Componentization-Measuring-Success.html&quot;&gt;Componentization: Measuring Success&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Table of Contents Since May 13, 2013</summary></entry><entry><title type="html">Componentization: Measuring Success</title><link href="https://computingsimplicity.neocities.org/2021/05/24/Componentization-Measuring-Success.html" rel="alternate" type="text/html" title="Componentization: Measuring Success" /><published>2021-05-24T00:00:00-04:00</published><updated>2021-05-24T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/24/Componentization%20-%20Measuring%20Success</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/24/Componentization-Measuring-Success.html">&lt;h1 id=&quot;the-elephant-in-the-room&quot;&gt;The Elephant In The Room&lt;/h1&gt;
&lt;p&gt;The fundamental problem is that programmers don’t build software components that are completely isolated.&lt;/p&gt;

&lt;p&gt;Most PLs, package managers and Docker, nip at the heels of the problem but don’t address the fundamental problem.&lt;/p&gt;

&lt;h1 id=&quot;how-would-we-measure-success-at-componentization&quot;&gt;How Would We Measure Success at Componentization?&lt;/h1&gt;

&lt;p&gt;Success:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;everything becomes simpler&lt;/li&gt;
  &lt;li&gt;everything becomes “obvious” (aka easy to understand).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">The Elephant In The Room The fundamental problem is that programmers don’t build software components that are completely isolated.</summary></entry><entry><title type="html">Compiler Technology Takeaways</title><link href="https://computingsimplicity.neocities.org/2021/05/23/Compiler-Technology-Takeaways.html" rel="alternate" type="text/html" title="Compiler Technology Takeaways" /><published>2021-05-23T00:00:00-04:00</published><updated>2021-05-23T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/23/Compiler%20Technology%20Takeaways</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/23/Compiler-Technology-Takeaways.html">&lt;ul&gt;
  &lt;li&gt;REGEX&lt;/li&gt;
  &lt;li&gt;Parsing&lt;/li&gt;
  &lt;li&gt;Normalization&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;regex&quot;&gt;REGEX&lt;/h1&gt;
&lt;h1 id=&quot;parsing-peg&quot;&gt;Parsing, PEG&lt;/h1&gt;
&lt;h1 id=&quot;normalization&quot;&gt;Normalization&lt;/h1&gt;
&lt;p&gt;Opcodes are triples.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MOV R0,R1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Triples =&amp;gt; normalization.&lt;/p&gt;

&lt;p&gt;CPUs are horribly complex under-the-hood&lt;sup id=&quot;fnref:rust&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:rust&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.  Opcodes provide a normalized view of this complexity.&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;PEG&lt;/li&gt;
  &lt;li&gt;Ohm-JS&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=w_znRopGtbE&quot;&gt;Jeri Homebrew NMOS Transistor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:rust&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Transistors are built using oxides, e.g. various forms of rust.  Most programmers don’t care about what is inside those little black boxes we call ICs.  Triples provide the interface between physical rust and software. &lt;a href=&quot;#fnref:rust&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">REGEX Parsing Normalization</summary></entry><entry><title type="html">Compiler Technology Takeaways 3</title><link href="https://computingsimplicity.neocities.org/2021/05/23/Compiler-Technology-Takeaways-3.html" rel="alternate" type="text/html" title="Compiler Technology Takeaways 3" /><published>2021-05-23T00:00:00-04:00</published><updated>2021-05-23T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/23/Compiler%20Technology%20Takeaways%203</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/23/Compiler-Technology-Takeaways-3.html">&lt;ul&gt;
  &lt;li&gt;optimization&lt;/li&gt;
  &lt;li&gt;portability&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;optimization&quot;&gt;Optimization&lt;/h1&gt;

&lt;p&gt;Make a program boring.&lt;/p&gt;

&lt;p&gt;Someone else will, later, optimize it under-the-hood.&lt;/p&gt;

&lt;h1 id=&quot;portability&quot;&gt;Portability&lt;/h1&gt;

&lt;p&gt;Forget about addressing portability directly.&lt;/p&gt;

&lt;p&gt;Portabilty is a subset of optimization.&lt;/p&gt;

&lt;p&gt;Normalize the program.  Optimization techniques can be used to port the program to other architectures.&lt;/p&gt;

&lt;p&gt;RTL ports programs to disparate CPU architectures using normalization (“everything is a register”).&lt;/p&gt;

&lt;p&gt;OCG ports programs to disparate CPU architectures using normalization (“everything is a lower-level operation using Data Descriptors”).&lt;/p&gt;

&lt;p&gt;OCG provides a declarative syntax for describing portability decision trees.&lt;/p&gt;

&lt;p&gt;Portability is a subset of Projectional Editing.  Projectional Editing is a subset of Normalization.&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">optimization portability</summary></entry><entry><title type="html">Compiler Technology Takeaways 2</title><link href="https://computingsimplicity.neocities.org/2021/05/23/Compiler-Technology-Takeaways-2.html" rel="alternate" type="text/html" title="Compiler Technology Takeaways 2" /><published>2021-05-23T00:00:00-04:00</published><updated>2021-05-23T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/23/Compiler%20Technology%20Takeaways%202</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/23/Compiler-Technology-Takeaways-2.html">&lt;ul&gt;
  &lt;li&gt;normalization&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;gcc&quot;&gt;gcc&lt;/h1&gt;

&lt;p&gt;The Gnu C compiler uses RTL invented as a peepholing technology by Fraser-Davidson.&lt;/p&gt;

&lt;h1 id=&quot;ocg&quot;&gt;OCG&lt;/h1&gt;
&lt;p&gt;Orthogonal Code Generator (Cordy).&lt;/p&gt;

&lt;p&gt;Declarative decision language for portability.&lt;/p&gt;

&lt;p&gt;Splits portable code generation into two sub-tasks:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Compile input program to normalized form.&lt;/li&gt;
  &lt;li&gt;Convert normalized form to code for specific CPU.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;denotational-semantics&quot;&gt;Denotational Semantics&lt;/h1&gt;
&lt;p&gt;Functional description of PL&lt;sup id=&quot;fnref:pl&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:pl&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Includes grammar + semantics + code emission.&lt;/p&gt;

&lt;p&gt;Originally an &lt;em&gt;all-in-one&lt;/em&gt; concept resulting in large compilers that were not practical.&lt;/p&gt;

&lt;p&gt;Peter Lee “Realistic Compiler Generation” broke the concept down into sub-tasks and produced more practical results.&lt;/p&gt;
&lt;h1 id=&quot;normalization&quot;&gt;Normalization&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Triples&lt;/li&gt;
  &lt;li&gt;Data Descriptors
    &lt;h2 id=&quot;opcodes&quot;&gt;Opcodes&lt;/h2&gt;
    &lt;p&gt;Opcodes are triples.&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MOV R0,R1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;rtl&quot;&gt;RTL&lt;/h2&gt;
    &lt;p&gt;Register Transfer Logic created by Fraser/Davidson as peephole technology for portability.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Splits code selectiion into two sub-tasks&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Compile input program to normalized form (RTL “everything is a register”)&lt;/li&gt;
  &lt;li&gt;Convert normalized form to code for specific CPU.
    &lt;h2 id=&quot;data-descriptors&quot;&gt;Data Descriptors&lt;/h2&gt;
    &lt;p&gt;Normalized form for description of data locations.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Enables splitting of portable compilers into smaller sub-tasks.&lt;/p&gt;
&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:pl&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;PL means Programming Language. &lt;a href=&quot;#fnref:pl&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">normalization</summary></entry><entry><title type="html">API Takeaways</title><link href="https://computingsimplicity.neocities.org/2021/05/23/API-Takeaways.html" rel="alternate" type="text/html" title="API Takeaways" /><published>2021-05-23T00:00:00-04:00</published><updated>2021-05-23T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/23/API%20Takeaways</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/23/API-Takeaways.html">&lt;ul&gt;
  &lt;li&gt;restricted interface between components&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;input-apis&quot;&gt;Input APIs&lt;/h1&gt;
&lt;p&gt;APIs usually specify only the input side of software components.&lt;/p&gt;

&lt;h1 id=&quot;output-apis&quot;&gt;Output APIs&lt;/h1&gt;
&lt;p&gt;Full APIs must include, both, input and output descriptions.&lt;/p&gt;

&lt;h1 id=&quot;dlls&quot;&gt;DLLs&lt;/h1&gt;
&lt;p&gt;DLLs - .dll, .so, .dylib files - are one form of output API (created using indirection which is resolved by the linker).&lt;/p&gt;

&lt;p&gt;DLLs are not formalized to the point of having first-class output APIs.&lt;/p&gt;

&lt;h1 id=&quot;normalized-interfaces-apis&quot;&gt;Normalized Interfaces, APIs&lt;/h1&gt;

&lt;p&gt;Input APIs and output APIs should look the same.&lt;/p&gt;

&lt;p&gt;Currently we specify output APIs using a mish-mosh of syntax, e.g. exceptions, synchronous return values, etc.&lt;/p&gt;

&lt;h1 id=&quot;components&quot;&gt;Components&lt;/h1&gt;

&lt;p&gt;A Component is described by&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a name&lt;/li&gt;
  &lt;li&gt;an input interface&lt;/li&gt;
  &lt;li&gt;an output interface.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[N.B. Currently, we specify APIs with too much detail, a result of flatness instead of layering.  Libraries are hard to use because of the fact that too much detail is exposed at the top levels].&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">restricted interface between components</summary></entry><entry><title type="html">UNIX Takeaways 2</title><link href="https://computingsimplicity.neocities.org/2021/05/23/UNIX-Takeaways-2.html" rel="alternate" type="text/html" title="UNIX Takeaways 2" /><published>2021-05-23T00:00:00-04:00</published><updated>2021-05-23T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/23/UNIX%20Takeaways%202</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/23/UNIX-Takeaways-2.html">&lt;ul&gt;
  &lt;li&gt;restricted interfaces&lt;/li&gt;
  &lt;li&gt;low-level types for interfaces&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;restricted-interfaces&quot;&gt;Restricted Interfaces&lt;/h1&gt;

&lt;p&gt;UNIX commands have&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1 input (stdin)&lt;/li&gt;
  &lt;li&gt;2 outputs (stdout, stderr).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UNIX shows how much can be done with simple interfaces.&lt;/p&gt;

&lt;h1 id=&quot;low-level-types&quot;&gt;Low-Level Types&lt;/h1&gt;
&lt;p&gt;Typing should be done in layers, not in an &lt;em&gt;all-in-one&lt;/em&gt; basis.&lt;/p&gt;

&lt;p&gt;UNIX commands use a very simple, low-level type for communication between components - a line of text.&lt;/p&gt;

&lt;p&gt;This simplicity allows components to be plugged together.&lt;/p&gt;

&lt;p&gt;Note that more elaborate types can be used, but the fundamental (atomic) type for plugging components together remains constant (a line of text).&lt;/p&gt;

&lt;p&gt;More elaborate types can be enforced by components in UNIX pipelines.&lt;/p&gt;

&lt;h1 id=&quot;type-pipelines&quot;&gt;Type Pipelines&lt;/h1&gt;
&lt;p&gt;More elaborate types can be checked in layers in a type pipeline.  Each successive component in a pipeline either&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;passes data down the pipe (after checking it)&lt;/li&gt;
  &lt;li&gt;signals an error, e.g. by withholding (1) and sending an error object (/message) on a side-channel.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This structure inherently needs multiple outputs (e.g. at least stdout and stderr (I favor having more than 2)) which is not well-served by functional notation (which is fundamentally a 1-in-1-out notation&lt;sup id=&quot;fnref:bags&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:bags&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;)&lt;/p&gt;

&lt;h1 id=&quot;fbp&quot;&gt;FBP&lt;/h1&gt;

&lt;p&gt;FBP means Flow-Based Programming.&lt;/p&gt;

&lt;p&gt;UNIX commands are a subset of FBP&lt;sup id=&quot;fnref:cbp&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:cbp&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h1 id=&quot;edge-cases&quot;&gt;Edge-Cases&lt;/h1&gt;

&lt;p&gt;Q: What kinds of operations cannot be handled with the above?&lt;/p&gt;

&lt;p&gt;Q: Should we create PLs&lt;sup id=&quot;fnref:pl&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:pl&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; that are the Union of all edge-cases, or, should we create many SCNs&lt;sup id=&quot;fnref:scn&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:scn&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; instead?&lt;/p&gt;

&lt;p&gt;Q: Does PEG offer advantages over REGEX for creating commands (e.g. grep vs. fictional peggrep ; awk vs. fictional pegawk ; python vs. fictional pegpy ; lisp vs. peglisp)?  Is this an edge-case or something common to many apps?&lt;/p&gt;

&lt;p&gt;Q: Should PLs be hierarchical, not flat?  Should variables be hierarchical?  (Symbols, in general).  [Example: “y = mx + b” vs. “y = (slope * x) + intersect”.  Is the difference a language decision or a IDE feature?  Or, is this the goal of Projectional Editing?).]&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:bags&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Over time, the limits of functional notation have been addressed by playing whack-a-mole - adding bags onto the side of the otherwise-pure syntax, e.g. exceptions. &lt;a href=&quot;#fnref:bags&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:cbp&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I favor Component Based Programming, which is more similar to EE and LEGO.  FBP focuses on the flows of data while CBP focuses on the components themselves. &lt;a href=&quot;#fnref:cbp&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:pl&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;PL means Programming Language. &lt;a href=&quot;#fnref:pl&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:scn&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;SCN means Solution Centric Notation (essentially a light-weight DSL). &lt;a href=&quot;#fnref:scn&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">restricted interfaces low-level types for interfaces</summary></entry><entry><title type="html">UNIX Takeaways</title><link href="https://computingsimplicity.neocities.org/2021/05/23/UNIX-Takeaways.html" rel="alternate" type="text/html" title="UNIX Takeaways" /><published>2021-05-23T00:00:00-04:00</published><updated>2021-05-23T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/23/UNIX%20Takeaways</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/23/UNIX-Takeaways.html">&lt;ul&gt;
  &lt;li&gt;Isolation&lt;/li&gt;
  &lt;li&gt;Coordination Language&lt;/li&gt;
  &lt;li&gt;Concurrency&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;threads-are-isolation&quot;&gt;Threads are Isolation&lt;/h1&gt;

&lt;p&gt;Programs are completely separated from each other and can communicate only over very restricted channels.&lt;/p&gt;

&lt;p&gt;Threads are &lt;em&gt;envelopes&lt;/em&gt; that one can drop &lt;em&gt;calculators&lt;/em&gt; into.&lt;/p&gt;

&lt;h1 id=&quot;coordination-language&quot;&gt;Coordination Language&lt;/h1&gt;

&lt;p&gt;PLs have traditionally been restricted to expressing the contstruction of synchronous calculators.&lt;/p&gt;

&lt;p&gt;Few PLs address the issues of distributed programming&lt;sup id=&quot;fnref:alib&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:alib&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/bin/sh&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;) is a DSL for creating higher-level concurrent abstractions.&lt;/p&gt;

&lt;h2 id=&quot;pid&quot;&gt;PID&lt;/h2&gt;

&lt;p&gt;PIDs - process ID - are handles to first-class components.&lt;/p&gt;

&lt;h1 id=&quot;concurrency&quot;&gt;Concurrency&lt;/h1&gt;

&lt;p&gt;Concurrency is a programming paradigm.&lt;/p&gt;

&lt;p&gt;Parallelism is an application problem that needs to use the concurrent paradigm&lt;/p&gt;

&lt;h1 id=&quot;anti-takeaways&quot;&gt;Anti-Takeaways&lt;/h1&gt;
&lt;h2 id=&quot;time-sharing&quot;&gt;Time-Sharing&lt;/h2&gt;
&lt;h2 id=&quot;memory-sharing&quot;&gt;Memory Sharing&lt;/h2&gt;
&lt;h2 id=&quot;closures&quot;&gt;Closures&lt;/h2&gt;
&lt;p&gt;Threads are just closure-wannabees&lt;sup id=&quot;fnref:ccs&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:ccs&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;UNIX threads are just ad-hoc implementations of closures in C.&lt;/p&gt;
&lt;h2 id=&quot;dependency-spaghetti&quot;&gt;Dependency Spaghetti&lt;/h2&gt;
&lt;h2 id=&quot;rendezvous&quot;&gt;Rendezvous&lt;/h2&gt;
&lt;p&gt;Attempt to corral concurrency by making &lt;em&gt;everything&lt;/em&gt; synchronous.&lt;/p&gt;
&lt;h2 id=&quot;syntax-for-distributed-programming-is-minimal&quot;&gt;Syntax for Distributed Programming is Minimal&lt;/h2&gt;
&lt;p&gt;The UNIX shell syntax for distributed programming is muddied by the inclusion of many other features&lt;sup id=&quot;fnref:soc&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:soc&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&quot;continued-conflation-and-muddied-waters-between-programming-and-oss&quot;&gt;Continued Conflation and Muddied Waters Between Programming and O/Ss&lt;/h2&gt;
&lt;p&gt;UNIX contains several fundamental advances in PL features (e.g. |, &amp;amp;, fork, etc).&lt;/p&gt;

&lt;p&gt;These PL advances have, unfortunately, been conflated with Operating Systems and have largely been ignored in PL designs.&lt;/p&gt;
&lt;h2 id=&quot;union-of-coordination-and-string-processing-and-&quot;&gt;Union of Coordination and String Processing and …&lt;/h2&gt;
&lt;p&gt;O/Ss are just libraries.&lt;/p&gt;

&lt;p&gt;Windows, MacOS, Linux are just applications.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;problems&lt;/em&gt; that Windows, MacOS and Linux must solve are different from the problems that most apps need to solve.&lt;/p&gt;

&lt;p&gt;Not every app should have all of the operating system principles built-in, e.g. not every app needs memory sharing and time-sharing.&lt;/p&gt;

&lt;p&gt;Some apps use the concurrent programming paradigm.  This should not mean that they must include all of O/S-style threading.&lt;/p&gt;
&lt;h1 id=&quot;pipelines-vs-isolation&quot;&gt;Pipelines vs. Isolation&lt;/h1&gt;
&lt;p&gt;UNIX popularize pipelines of isolated components.&lt;/p&gt;

&lt;p&gt;These advances have been, unfortunately, overlooked due to&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;conflation with heavy technologies (e.g. O/Ss)&lt;/li&gt;
  &lt;li&gt;premature optimization (e.g. the ideas of &lt;em&gt;isolation&lt;/em&gt; were burned into hardware before they were sufficiently explored, e.g. C had some useful ideas about &lt;em&gt;isolation&lt;/em&gt; but these were missed in lieue of C’s system-language features)
    &lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;
    &lt;p&gt;Concurrency is not Parallelism - Rob Pike&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:alib&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Distributed programming is, currently, only addressed by second-class, assembler-like operations and libraries. &lt;a href=&quot;#fnref:alib&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ccs&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Maybe I mean /CCs?. &lt;a href=&quot;#fnref:ccs&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:soc&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Lack of Separation of Concerns &lt;a href=&quot;#fnref:soc&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">Isolation Coordination Language Concurrency</summary></entry><entry><title type="html">Structured Programming Takeaways</title><link href="https://computingsimplicity.neocities.org/2021/05/23/Structured-Programming-Takeaways.html" rel="alternate" type="text/html" title="Structured Programming Takeaways" /><published>2021-05-23T00:00:00-04:00</published><updated>2021-05-23T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/05/23/Structured%20Programming%20Takeaways</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/05/23/Structured-Programming-Takeaways.html">&lt;ul&gt;
  &lt;li&gt;Nesting&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;scoping&quot;&gt;Scoping&lt;/h1&gt;

&lt;p&gt;Scoping is nesting.&lt;/p&gt;

&lt;p&gt;Structured Programming suggested ways to scope control flow.&lt;/p&gt;

&lt;p&gt;Control flow spaghetti was discarded in lieue of structured control-flow concepts such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while loops&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;[N.B. The problem of Global Variables was, also, solved by using nesting (scoping), although this was not fundamentally a control-flow problem]&lt;/p&gt;

&lt;h1 id=&quot;what-is-not-nested-in-todays-pls&quot;&gt;What is &lt;em&gt;not&lt;/em&gt; nested in today’s PLs?&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;functions&lt;/li&gt;
  &lt;li&gt;types&lt;/li&gt;
  &lt;li&gt;CPS&lt;/li&gt;
  &lt;li&gt;environments&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;package-managers&quot;&gt;Package Managers&lt;/h1&gt;

&lt;p&gt;Packaging, package managers, are attempts for providing nesting for symbols.&lt;/p&gt;

&lt;p&gt;The fact that there is more than one kind of package manager implies that the concept has not been normalized, yet.&lt;/p&gt;

&lt;h1 id=&quot;docker&quot;&gt;Docker&lt;/h1&gt;
&lt;p&gt;Docker is an attempt at providing nesting and isolation.&lt;/p&gt;

&lt;h1 id=&quot;environments&quot;&gt;Environments&lt;/h1&gt;
&lt;p&gt;Environments and environment variables are just another use of flat global entities.&lt;/p&gt;

&lt;p&gt;In this case, isolation is implicitly provided by the physical hardware.&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">Nesting</summary></entry></feed>