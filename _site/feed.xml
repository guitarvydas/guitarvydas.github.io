<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://computingsimplicity.neocities.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://computingsimplicity.neocities.org/" rel="alternate" type="text/html" /><updated>2021-06-11T00:42:55-04:00</updated><id>https://computingsimplicity.neocities.org/feed.xml</id><title type="html">Computing Simplicity</title><subtitle>Various thoughts on making programming simpler, and, breaking programming down into several disciplines: Architecture, Engineering, Implementation.  Concurrency is not parallelism and concurrency is not multitasking.</subtitle><entry><title type="html">The Atomic API</title><link href="https://computingsimplicity.neocities.org/2021/06/10/Atomic-API.html" rel="alternate" type="text/html" title="The Atomic API" /><published>2021-06-10T00:00:00-04:00</published><updated>2021-06-10T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/06/10/Atomic%20API</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/06/10/Atomic-API.html">&lt;p&gt;The most &lt;em&gt;atomic&lt;/em&gt; API consists of a function with exactly one parameter and zero return value(s).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function api(param) {...}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The function runs forever.&lt;/p&gt;

&lt;p&gt;The function parameter is always of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;An &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event&lt;/code&gt; message contains two fields&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a tag&lt;/li&gt;
  &lt;li&gt;data.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;type-checking-the-api&quot;&gt;Type Checking the API&lt;/h1&gt;
&lt;p&gt;Type checking consists of ensuring that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event&lt;/code&gt; parameter is the correct shape (as above).&lt;/p&gt;

&lt;h1 id=&quot;layered-type-checking&quot;&gt;Layered Type Checking&lt;/h1&gt;
&lt;p&gt;Further type-checking is a layered form of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event&lt;/code&gt; data, like newtork packets.&lt;/p&gt;

&lt;p&gt;We can string type-checking filters together to successively ensure that events arriving at a software component are “valid”.&lt;/p&gt;

&lt;p&gt;This is akin to input validation for web-based forms (i.e. we already do this kind of type checking).&lt;/p&gt;

&lt;p&gt;We call this kind of type checking by a pipeline of filters &lt;em&gt;design rule checking&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Type checking by pipeline has had  several different names, e.g. input validation, business rules, OSI 7-layer model, etc.&lt;/p&gt;

&lt;p&gt;There can be no general definition of data within &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;events&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The definition of data is agreed upon by the sender and the receiver (much like the meaning of text lines in UNIX pipelines).&lt;/p&gt;

&lt;p&gt;An &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event&lt;/code&gt; tag is sufficiently large to hold a small &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; (0-31), i.e. the tag is on byte in size.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; portion of an event is at least 3 bytes long.&lt;/p&gt;

&lt;p&gt;The minimal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event&lt;/code&gt; data structure is&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1 byte tag&lt;/li&gt;
  &lt;li&gt;3 bytes data.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Larger events are accomodated by agreement of the sender and receiver.&lt;/p&gt;

&lt;p&gt;Typically, the event &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; field contains layered information. The layers are peeled by a pipeline of receivers.&lt;/p&gt;

&lt;p&gt;Events larger than 4 bytes are&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;parsed by a pipeline of receivers, or,&lt;/li&gt;
  &lt;li&gt;treated as garbage by the receivers (note that large events can appear as successive garbled messages). The Software Implementor(s) must ensure that components are correctly connected together. It is advisable that software components be designed with a &lt;em&gt;reset&lt;/em&gt; input that drives the component into a known, default state.  Systems can employ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watchdog timers&lt;/code&gt; that reset components much like watchdog timers in hardware designs.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It is advisable to design components in a manner similar to the OSI 7-layer model for networking. (Aside: components can contain component pipelines themselves, in order to process events in a layered manner).&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">The most atomic API consists of a function with exactly one parameter and zero return value(s).</summary></entry><entry><title type="html">CALL Violates Structured Programming</title><link href="https://computingsimplicity.neocities.org/2021/06/10/Call-Violates-Structured-Programming.html" rel="alternate" type="text/html" title="CALL Violates Structured Programming" /><published>2021-06-10T00:00:00-04:00</published><updated>2021-06-10T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/06/10/Call%20Violates%20Structured%20Programming</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/06/10/Call-Violates-Structured-Programming.html">&lt;p&gt;Structured Programming introduced the notion of &lt;em&gt;nesting&lt;/em&gt; control flow with constructs like &lt;em&gt;if-then-else&lt;/em&gt;, &lt;em&gt;while&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Object-Oriented Programming popularized the notion of &lt;em&gt;nesting&lt;/em&gt; data via inhertiance.&lt;/p&gt;

&lt;p&gt;OOP and Structure Programming do not fully &lt;em&gt;isolate&lt;/em&gt; control-flow. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CALL / RETURN&lt;/code&gt; is usually supported in hardware by a global variable (the Stack).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CALL / RETURN&lt;/code&gt; violates the single-entry-single-exit edict of Structured Programming. Programmers can CALL subroutines directly and “break through” the boundaries of a properly structured&lt;/p&gt;

&lt;p&gt;To enable software construction using components, we must fully &lt;em&gt;isolate&lt;/em&gt; data &lt;em&gt;and&lt;/em&gt; control-flow.&lt;/p&gt;

&lt;h1 id=&quot;threads-for-isolation-of-control-flow&quot;&gt;Threads for Isolation of Control Flow&lt;/h1&gt;
&lt;p&gt;Threads, common in desktop operating systems like Linux, MacOS and Windows, isolate control flow in a heavy-handed manner. Threads often employ full-preemption and hardware MMUs.&lt;/p&gt;

&lt;p&gt;Full preemption has caused a great deal of accidental complexity, e.g. the Mars Rover disaster.&lt;/p&gt;

&lt;p&gt;Fixes for known problems have been developed, but it is clear that &lt;em&gt;full preemption&lt;/em&gt; inhibits reasoning about designs.&lt;/p&gt;
&lt;h1 id=&quot;pure-functions-for-isolation-of-control-flow&quot;&gt;Pure Functions for Isolation of Control Flow&lt;/h1&gt;
&lt;p&gt;FP restricts programs by expunging mutability to achieve &lt;em&gt;isolation&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;These kinds of languages severely restrict the programming paradigm(s) that can be employed to solve practical problems.&lt;/p&gt;

&lt;h2 id=&quot;calculators---one-input-one-output&quot;&gt;Calculators - One Input One Output&lt;/h2&gt;
&lt;p&gt;FP makes it easy to treat computers as &lt;em&gt;calculators&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;FP assumes that all &lt;em&gt;functions&lt;/em&gt; have one block of inputs and one block of outputs.&lt;/p&gt;

&lt;p&gt;FP is not well-suited to solving problems using paradigms that exceed this simple model.&lt;/p&gt;

&lt;h3 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h3&gt;
&lt;p&gt;For example, &lt;em&gt;exceptions&lt;/em&gt; are usually treated as edge-cases with second-class syntax and second-class semantics.&lt;/p&gt;

&lt;h3 id=&quot;javascript&quot;&gt;Javascript&lt;/h3&gt;
&lt;p&gt;Javascript was invented for creating distributed programs (aka web pages).&lt;/p&gt;

&lt;p&gt;Javascript continues to use function-like syntax with the result that simple distributed operations need to be programmed as &lt;em&gt;callbacks&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;referential-transparency&quot;&gt;Referential Transparency&lt;/h2&gt;

&lt;p&gt;An ideal for component-based design is the ability to replace components with pin-compatible ones.&lt;/p&gt;

&lt;p&gt;In hardware design, this was called &lt;em&gt;pin compatibility&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In functional progamming languages, this is called &lt;em&gt;referential transparency&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;FP languages achieve &lt;em&gt;referential transparency&lt;/em&gt; by restricting the language paradigm that can be used.&lt;/p&gt;

&lt;p&gt;FP expunges mutability and mutable operations.&lt;/p&gt;

&lt;p&gt;(Note that this is &lt;em&gt;not&lt;/em&gt; the only way to achieve &lt;em&gt;referential transparency&lt;/em&gt;. A different solution was developed in the electronics industry in the 1950’s).&lt;/p&gt;
&lt;h1 id=&quot;hidden-dependencies---global-variables&quot;&gt;Hidden Dependencies - Global Variables&lt;/h1&gt;
&lt;p&gt;A major factor in the complexity of computer systems is the hidden dependencies between modules and the hardware-supported used of a global Stack.&lt;/p&gt;

&lt;p&gt;Earlier computers, e.g. the IBM 360, did not have a hardware-supported Stack (programmers had to simulate a Stack using the BALR instruction).&lt;/p&gt;

&lt;h1 id=&quot;hidden-dependencies---synchrony-vs-asynchrony&quot;&gt;Hidden Dependencies - Synchrony vs. Asynchrony&lt;/h1&gt;
&lt;p&gt;Most languages use a sequential function paradigm.&lt;/p&gt;

&lt;p&gt;This sequential model resists the natural paradigm for computing - asynchronous operation.&lt;/p&gt;

&lt;p&gt;It should be noted that asynchrony is common in human experience&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;the human body contains an autonomous nervous system which consists of some 500 independent units&lt;/li&gt;
  &lt;li&gt;children around the age of 5 learn to use a hard, real-time notation&lt;/li&gt;
  &lt;li&gt;businesses run in a top-down manner (aka Org Charts) and consist of many independent units.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;concurrency&quot;&gt;Concurrency&lt;/h1&gt;

&lt;p&gt;— spaghetti&lt;br /&gt;
— The Stack&lt;br /&gt;
— Scalability&lt;br /&gt;
— Superposition&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">Structured Programming introduced the notion of nesting control flow with constructs like if-then-else, while, etc.</summary></entry><entry><title type="html">Hierarchical Namespaces</title><link href="https://computingsimplicity.neocities.org/2021/06/10/Hierarchical-Namespaces.html" rel="alternate" type="text/html" title="Hierarchical Namespaces" /><published>2021-06-10T00:00:00-04:00</published><updated>2021-06-10T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/06/10/Hierarchical%20Namespaces</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/06/10/Hierarchical-Namespaces.html">&lt;p&gt;All names shall be extracted from namespaces.&lt;/p&gt;

&lt;p&gt;(This means that not only variable names, but function and type names be placed in namespaces).&lt;/p&gt;

&lt;p&gt;Namespaces shall be hierarchical.&lt;/p&gt;

&lt;p&gt;Namespaces can contain namespaces.&lt;/p&gt;

&lt;p&gt;A fully qualified name consists of 3 parts[^3parts]:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;component&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;namespace within the component, i.e. i/o/x/c/n (input, output, connection, component, other names, resp.)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;name (a string or a symbol).&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Corrollary: Each &lt;em&gt;software component&lt;/em&gt; contains 5 namespaces. Names are unique within a namespace, but may duplicate names in other namespaces, e.g. a &lt;em&gt;software component&lt;/em&gt; might contain an input called “a” and an output called “a” without any name-clashing problems (the first “a” is in the input namespace, whereas the second “a” is in the output namespace).&lt;/p&gt;

&lt;p&gt;A name can be represented by a tuple &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{component, namespace, name}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Names are relative and nested, in general, the above tuple is recursive, e.g.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\{\{component, namespace, name} namespace name}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The namespace syntax is not meant to be easily human-readable.&lt;/p&gt;

&lt;p&gt;Purely for human readability, we abbreviate namespace notation in UNIX-like syntax:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./c/outer/i/name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;where ‘.’ means the root component (also known as “self”) and the namespaces are abbreviated to a single letter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i/o/x/c/n&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">All names shall be extracted from namespaces.</summary></entry><entry><title type="html">Lisp 1.5 Memory</title><link href="https://computingsimplicity.neocities.org/2021/06/08/Lisp-1.5-Memory.html" rel="alternate" type="text/html" title="Lisp 1.5 Memory" /><published>2021-06-08T00:00:00-04:00</published><updated>2021-06-08T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/06/08/Lisp%201.5%20Memory</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/06/08/Lisp-1.5-Memory.html">&lt;p&gt;From Frits van der Wateren’s Lisp 1.5 for MC6800.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://github.com/guitarvydas/frits-van-der-wateren-lisp/blob/master/LISP.TXT&quot;&gt;source code&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;code-snippet&quot;&gt;Code Snippet&lt;/h1&gt;
&lt;h2 id=&quot;memory-layout-of-part-of-the-oblist&quot;&gt;Memory Layout of Part of the OBLIST&lt;/h2&gt;
&lt;h3 id=&quot;drawing-lisp-cells&quot;&gt;Drawing: Lisp Cells&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/guitarvydas/guitarvydas.github.io/blob/master/assets/2021-06-08-lisp-1-5-LISP%20Cells.svg&quot;&gt;cells&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;assembler-code&quot;&gt;Assembler Code&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/guitarvydas/guitarvydas.github.io/blob/master/assets/2021-06-08-lisp-1-5-OBL28.svg&quot;&gt;Assembler snipppet&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;drawing-direct-translation-from-assembler&quot;&gt;Drawing: Direct Translation From Assembler&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/guitarvydas/guitarvydas.github.io/blob/master/assets/2021-06-08-lisp-1-5-memory%201.svg&quot;&gt;memory 1&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;drawing-direct-translation-into-contiguous-memory&quot;&gt;Drawing: Direct Translation Into Contiguous Memory&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/guitarvydas/guitarvydas.github.io/blob/master/assets/2021-06-08-lisp-1-5-memory%202.svg&quot;&gt;memory 2&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">From Frits van der Wateren’s Lisp 1.5 for MC6800.</summary></entry><entry><title type="html">Namespaces</title><link href="https://computingsimplicity.neocities.org/2021/06/07/Namespaces.html" rel="alternate" type="text/html" title="Namespaces" /><published>2021-06-07T00:00:00-04:00</published><updated>2021-06-07T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/06/07/Namespaces</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/06/07/Namespaces.html">&lt;p&gt;Each component has a &lt;em&gt;namespace&lt;/em&gt; which is distinct from the namespaces in other components.&lt;/p&gt;

&lt;p&gt;Component naming is relative - there is no “global” namespace.&lt;/p&gt;

&lt;p&gt;For emphasis, I break namespaces into 5 sub-categories:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;/i for inputs&lt;/li&gt;
  &lt;li&gt;/o for outputs&lt;/li&gt;
  &lt;li&gt;/x for connections&lt;/li&gt;
  &lt;li&gt;/c for components (child components)&lt;/li&gt;
  &lt;li&gt;/n for all other names.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I choose to emphasize that the input namespace is distinct from the output namespace in all components.&lt;/p&gt;

&lt;p&gt;Likewise, /x and /c are distinct namespaces.&lt;/p&gt;

&lt;p&gt;Input names and output names can appear to be the same, but do not cause name-clashes (because they are in separate namespaces).&lt;/p&gt;

&lt;p&gt;I, arbitrarily, choose the following syntax:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a namespace reference consists of two parts - (1) the component and (2) the namespace within the comonent&lt;/li&gt;
  &lt;li&gt;a name reference consists of “:” followed by the name.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;comp/i:a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;refers to the “a” input port of the component “comp”.&lt;/p&gt;

&lt;p&gt;Further examples:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;comp/o:a - “a” output port of component “comp”&lt;/li&gt;
  &lt;li&gt;comp/x:1 - A connection within the component “comp”.  We &lt;em&gt;gensym&lt;/em&gt; the name of the connection to be “1”. The user doesn’t actually care.&lt;/li&gt;
  &lt;li&gt;comp/c:sub - The component “sub” in the namespace “c” of component “comp”.&lt;/li&gt;
  &lt;li&gt;comp/n:xyz - The symbol “xyz” in the namespace “n” of component “comp”.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;optimization-and-hiding&quot;&gt;Optimization and Hiding&lt;/h1&gt;
&lt;p&gt;Later, we might wish to adopt a UNIX-like naming scheme where all parts of a path use the “/” operator.&lt;/p&gt;

&lt;p&gt;For example, we might want to rewrite:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;comp/c:sub/i:a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;to look like:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;comp/c/sub/i/a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but, that is a syntactical bauble that can be applied later&lt;sup id=&quot;fnref:syntax&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:syntax&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;For now, for clarity, I will use the form: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comp/c:sub/i:a&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;abbreviating-&quot;&gt;Abbreviating ./&lt;/h1&gt;

&lt;p&gt;I will use the abbreviation &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt; to mean the &lt;em&gt;current component&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;For example &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./i:a&lt;/code&gt; means &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comp/i:a&lt;/code&gt; when it appears inside of the component “comp”.&lt;/p&gt;

&lt;p&gt;This is purely meant for human consumption - writability and readability.&lt;/p&gt;

&lt;p&gt;Automation will transform:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root comp
./i:a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;into&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root comp
comp/i:a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:syntax&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Syntax is cheap. &lt;a href=&quot;#fnref:syntax&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">Each component has a namespace which is distinct from the namespaces in other components.</summary></entry><entry><title type="html">Isolation III</title><link href="https://computingsimplicity.neocities.org/2021/06/07/Isolation-III.html" rel="alternate" type="text/html" title="Isolation III" /><published>2021-06-07T00:00:00-04:00</published><updated>2021-06-07T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/06/07/Isolation%20III</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/06/07/Isolation-III.html">&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True isolation&lt;/code&gt; is&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data isolation&lt;/code&gt; AND&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;control-flow isolation&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;call--return&quot;&gt;CALL / RETURN&lt;/h1&gt;
&lt;p&gt;CALL/RETURN does not isolate control-flow, it implies sequential operation.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var x = obj.method (...)&lt;/code&gt; is sequential.&lt;/p&gt;

&lt;h1 id=&quot;relational-programming&quot;&gt;Relational Programming&lt;/h1&gt;
&lt;p&gt;Relational programming does not imply sequential operation.&lt;/p&gt;

&lt;p&gt;All control flow is handled by the relational engine.&lt;/p&gt;

&lt;h1 id=&quot;unix-threads&quot;&gt;UNIX Threads&lt;/h1&gt;

&lt;p&gt;UNIX threads do not imply sequential operation.&lt;/p&gt;

&lt;p&gt;Uber control flow is handled by the dispatcher.&lt;/p&gt;

&lt;h1 id=&quot;functions-are-sequential&quot;&gt;Functions Are Sequential&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fn(a)-&amp;gt;b&lt;/code&gt; implies sequential operation.&lt;/p&gt;

&lt;p&gt;The parameters are delivered in a “sequential block” (all parameters are delivered at the same time).&lt;/p&gt;

&lt;p&gt;The return value is delivered in a “sequential block”.&lt;/p&gt;

&lt;p&gt;The caller waits for a result.&lt;/p&gt;

&lt;h1 id=&quot;concurrency-vs-parameters&quot;&gt;Concurrency vs. Parameters&lt;/h1&gt;

&lt;p&gt;Note that sequentialism leaks into parameter passing.&lt;/p&gt;

&lt;p&gt;In sequential programming, &lt;em&gt;all&lt;/em&gt; parameters must be delivered at the same time.&lt;/p&gt;

&lt;p&gt;In concurrent programming, parameters can be delivered&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;at any time&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;in any order&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;individually&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Grouping parameters together and grouping return values together is the exception, not the rule, in concurrent programming.&lt;/p&gt;

&lt;h1 id=&quot;lifetime---forever-vs-live-then-die&quot;&gt;Lifetime - Forever vs. Live-Then-Die&lt;/h1&gt;

&lt;p&gt;The caller does/can not care if the callee&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(a) lives forever, or,&lt;/li&gt;
  &lt;li&gt;(b) lives-then-dies.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(a) is server-like.&lt;/p&gt;

&lt;p&gt;(b) is function-like.&lt;/p&gt;

&lt;h1 id=&quot;need-to-know&quot;&gt;Need to Know&lt;/h1&gt;
&lt;p&gt;Saying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x.fn(...)&lt;/code&gt; implies that you know too much about “x”.&lt;/p&gt;

&lt;p&gt;That knowledge is hard-wired into the calling code and makes it hard to change later, aka accidental dependency.&lt;/p&gt;

&lt;p&gt;Suggestion: all methods have only one calling syntax and all methods have the &lt;em&gt;same&lt;/em&gt; parameter list syntactically, with the &lt;em&gt;same type&lt;/em&gt; (!).&lt;/p&gt;

&lt;h2 id=&quot;type-checking&quot;&gt;Type Checking&lt;/h2&gt;

&lt;p&gt;The suggestion is not to delete type-checking, but to move it elsewhere.&lt;/p&gt;

&lt;p&gt;We &lt;em&gt;already&lt;/em&gt; do this with compilers -&amp;gt; opcodes.&lt;/p&gt;

&lt;p&gt;Compilers can be viewed as type filters that strip away semantic information to produce untyped opcodes.&lt;/p&gt;

&lt;h1 id=&quot;choice&quot;&gt;Choice&lt;/h1&gt;

&lt;p&gt;In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var x = obj.method (...)&lt;/code&gt;, you do not get to choose whether the operation is concurrent or sequential.&lt;/p&gt;

&lt;p&gt;The choice is made for you and baked into your code (aka accidental dependency (aka accidentally not-isolated)).&lt;/p&gt;

&lt;h1 id=&quot;further-suggestion&quot;&gt;Further Suggestion&lt;/h1&gt;

&lt;p&gt;Suggestion: code cannot &lt;em&gt;call&lt;/em&gt; a method in an object.&lt;/p&gt;

&lt;p&gt;Code can only &lt;em&gt;send&lt;/em&gt; information to its &lt;em&gt;parent&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;parent&lt;/em&gt; can &lt;em&gt;choose&lt;/em&gt; to &lt;em&gt;send&lt;/em&gt; this information to another child for further processing.&lt;/p&gt;

&lt;p&gt;I.E. a function cannot &lt;em&gt;name&lt;/em&gt; other objects and methods.&lt;/p&gt;

&lt;h1 id=&quot;software-components&quot;&gt;Software Components&lt;/h1&gt;

&lt;p&gt;Software components can contain code.&lt;/p&gt;

&lt;p&gt;Software components can only &lt;em&gt;send&lt;/em&gt; information upwards to their &lt;em&gt;parents&lt;/em&gt;, or, they can &lt;em&gt;send&lt;/em&gt; commands to their children.&lt;/p&gt;

&lt;p&gt;Cross-talk is not allowed.&lt;/p&gt;

&lt;p&gt;Cross-talk produces non-scalable code.&lt;/p&gt;

&lt;p&gt;Corollary: components cannot communicate directly with their peers.&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">True isolation is data isolation AND control-flow isolation</summary></entry><entry><title type="html">Namespaces Working Paper</title><link href="https://computingsimplicity.neocities.org/2021/06/07/Namespaces-Working-Paper.html" rel="alternate" type="text/html" title="Namespaces Working Paper" /><published>2021-06-07T00:00:00-04:00</published><updated>2021-06-07T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/06/07/Namespaces%20Working%20Paper</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/06/07/Namespaces-Working-Paper.html">&lt;p&gt;&lt;a href=&quot;https://github.com/guitarvydas/guitarvydas.github.io/blob/master/assets/2021-06-07-wp-namespaces.svg&quot;&gt;diagram and factbase&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">diagram and factbase</summary></entry><entry><title type="html">Isolation II</title><link href="https://computingsimplicity.neocities.org/2021/06/06/Isolation-II.html" rel="alternate" type="text/html" title="Isolation II" /><published>2021-06-06T00:00:00-04:00</published><updated>2021-06-06T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/06/06/Isolation%20II</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/06/06/Isolation-II.html">&lt;p&gt;The only thing wrong with mutable state is that it is not isolated.&lt;/p&gt;

&lt;p&gt;Mutable state is not the problem, isolation is the problem.&lt;/p&gt;

&lt;h1 id=&quot;encapsulation&quot;&gt;Encapsulation&lt;/h1&gt;

&lt;p&gt;OOP-style encapsulation is not enough.&lt;/p&gt;

&lt;h1 id=&quot;unix-live-free-and-die&quot;&gt;UNIX Live Free and Die&lt;/h1&gt;

&lt;p&gt;UNIX-like processes that die and are automagically cleaned up are another way to get isolation.&lt;/p&gt;

&lt;p&gt;Even lowly C programs running under UNIX are isolated.&lt;/p&gt;

&lt;p&gt;[…]&lt;sup id=&quot;fnref:die&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:die&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h1 id=&quot;leaking-state&quot;&gt;Leaking State&lt;/h1&gt;
&lt;p&gt;Leaking state should not be allowed.&lt;/p&gt;

&lt;h1 id=&quot;leaking-dependencies&quot;&gt;Leaking Dependencies&lt;/h1&gt;
&lt;p&gt;Leaking depedencies should not be allowed.&lt;/p&gt;

&lt;h1 id=&quot;non-locality&quot;&gt;Non-Locality&lt;/h1&gt;

&lt;p&gt;I define non-local as:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Non-locality is: more than an eye-full.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Imagine if all code was only 5 lines long.&lt;/p&gt;

&lt;p&gt;Imagine if all code was only one window long.&lt;/p&gt;

&lt;p&gt;Imagine if all code was only one screen long.&lt;/p&gt;

&lt;p&gt;Imagine if all code fit on one piece of paper (i.e. a printed page).&lt;/p&gt;

&lt;p&gt;etc. etc.&lt;/p&gt;

&lt;p&gt;For example, 26 global variables, named A-Z, are more than I need for only 5 lines of code.&lt;/p&gt;

&lt;h1 id=&quot;the-unit-of-understandability&quot;&gt;The Unit of Understandability&lt;/h1&gt;

&lt;p&gt;7±2.&lt;/p&gt;

&lt;h1 id=&quot;problem-how-to-keep-software-units-small&quot;&gt;Problem: How To Keep Software Units Small?&lt;/h1&gt;

&lt;p&gt;The problem becomes: how do we keep all software units down to 7±2 lines in length?&lt;/p&gt;

&lt;h1 id=&quot;hierarchy&quot;&gt;Hierarchy&lt;/h1&gt;

&lt;p&gt;I favor hierarchy.&lt;/p&gt;

&lt;p&gt;Hierarchical variables.&lt;/p&gt;

&lt;p&gt;Hierarchical types.&lt;/p&gt;

&lt;p&gt;Hierarchical functions.&lt;/p&gt;

&lt;p&gt;Hierarchical return values.&lt;/p&gt;

&lt;p&gt;Hierarchical parameters.&lt;/p&gt;

&lt;p&gt;Hierarchical sub-systems (e.g. a &lt;em&gt;system&lt;/em&gt; can be more than 7±2 lines of code, as long as any sub-unit of code - isolated code - is only 7±2 lines long).&lt;/p&gt;

&lt;p&gt;etc. etc.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Flat-anything&lt;/em&gt; is bad.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Non-fractal&lt;/em&gt; anything is bad.&lt;/p&gt;

&lt;h1 id=&quot;trees&quot;&gt;Trees&lt;/h1&gt;

&lt;p&gt;Trees are hierarchical.&lt;/p&gt;

&lt;h2 id=&quot;graphs-and-dags&quot;&gt;Graphs and DAGs&lt;/h2&gt;

&lt;p&gt;Graphs and DAGs are not purely hierarchical, since they allow cross-talk between nodes.&lt;/p&gt;

&lt;h1 id=&quot;libraries-of-code&quot;&gt;Libraries of Code&lt;/h1&gt;

&lt;p&gt;Libraries create dependencies.&lt;/p&gt;

&lt;p&gt;Avoid libraries. (!)&lt;/p&gt;

&lt;p&gt;Avoid creating and using libraries as we understand them at present.&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:die&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Stolen from a license-plate I saw in a UNIX lab. “UNIX Live Free or Die”. &lt;a href=&quot;#fnref:die&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">The only thing wrong with mutable state is that it is not isolated.</summary></entry><entry><title type="html">Connecting Layers</title><link href="https://computingsimplicity.neocities.org/2021/06/06/Connecting-Modules.html" rel="alternate" type="text/html" title="Connecting Layers" /><published>2021-06-06T00:00:00-04:00</published><updated>2021-06-06T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/06/06/Connecting%20Modules</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/06/06/Connecting-Modules.html">&lt;p&gt;What is the minimum unit of connect-ability?&lt;/p&gt;

&lt;p&gt;Imagine that we want to connect one software module to another.&lt;/p&gt;

&lt;p&gt;What do we need to know to do this?&lt;/p&gt;

&lt;h1 id=&quot;connecting-audio-signals&quot;&gt;Connecting Audio Signals&lt;/h1&gt;

&lt;p&gt;Let’s imagine a physical real-world system.&lt;/p&gt;

&lt;p&gt;Imagine that we want to connect a guitar to a guitar amplifier.&lt;/p&gt;

&lt;p&gt;We connect the two using a cable (“guitar cord”).&lt;/p&gt;

&lt;p&gt;The only “typing” applied to the cable is the physical connector and the receptacle that it is going to be plugged into (e.g. 1/4-inch plug to 1/4-inch jack).&lt;/p&gt;

&lt;p&gt;Is the signal analog or digital? Is it +5V or +3V?&lt;/p&gt;

&lt;p&gt;The cable doesn’t care.&lt;/p&gt;

&lt;h1 id=&quot;connecting-software-modules-together&quot;&gt;Connecting Software Modules Together&lt;/h1&gt;

&lt;p&gt;What is a software cable?&lt;/p&gt;

&lt;p&gt;Can we connect two software components via a chain (pipeline) of increasingly specific type filters? Bits in at one end, type “xyz” out the other end?&lt;/p&gt;

&lt;p&gt;Or, do we connect the software components using a smart cable?&lt;/p&gt;

&lt;p&gt;How many smart cables do we need?&lt;/p&gt;

&lt;p&gt;Let’s imagine a very simple example. A box that generates “Hello World” strings.&lt;/p&gt;

&lt;p&gt;Can we connect that box to a calculator box?&lt;/p&gt;

&lt;p&gt;Maybe we have a “string-to-string” cable and a “number-to-number” cable? And a “string-to-number” cable? Do we need a “number-to-string” cable?&lt;/p&gt;

&lt;p&gt;How many smart cables do we need?&lt;/p&gt;

&lt;h1 id=&quot;networks&quot;&gt;Networks&lt;/h1&gt;

&lt;p&gt;Networks send packets of information.&lt;/p&gt;

&lt;p&gt;Information is wrapped in layers of information.&lt;/p&gt;

&lt;p&gt;Can my computer send a request to that server?&lt;/p&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;I only need to know the port number.&lt;/p&gt;

&lt;p&gt;I can send any kind of information to that server on my port-number-cable.&lt;/p&gt;

&lt;p&gt;The server has a “line filter” that rejects my information if it doesn’t look like a valid HTTP request.&lt;/p&gt;

&lt;p&gt;That “line filter” is a type checker.  More generally, it is a design-rules checker.&lt;/p&gt;

&lt;p&gt;That line filter strips off the outer-most layer of information and passes the rest on down the line.&lt;/p&gt;

&lt;p&gt;After my data passes through the first line filter, my data is passed through more checkers.&lt;/p&gt;

&lt;p&gt;How many more filters are there?&lt;/p&gt;

&lt;p&gt;I don’t know.&lt;/p&gt;

&lt;p&gt;I only know what I need to know.&lt;/p&gt;

&lt;p&gt;If I wrap my data in the correct set of layers, it will make it all the way to the end and I will receive a response (wrapped in layers that I define or agree to).&lt;/p&gt;

&lt;p&gt;Today’s software cables are based on the all-in-one mentality instead of the layered mentality.&lt;/p&gt;

&lt;p&gt;We are - slowly - beginning to rediscover what networking people already know, what electronics people knew before them, etc.&lt;/p&gt;

&lt;h1 id=&quot;layered-data&quot;&gt;Layered Data&lt;/h1&gt;

&lt;p&gt;We need to wrap information like Russian Dolls.&lt;/p&gt;

&lt;p&gt;Wrapping data in layers will allow us to build checkers that can be bolted into pipelines.&lt;/p&gt;

&lt;h1 id=&quot;no-dependencies&quot;&gt;No Dependencies&lt;/h1&gt;

&lt;p&gt;Software layers cannot poke information through to other layers.&lt;/p&gt;

&lt;p&gt;We learned that lesson with so-called global variables, and, with Structured Programming.&lt;/p&gt;

&lt;h1 id=&quot;scoping&quot;&gt;Scoping&lt;/h1&gt;

&lt;p&gt;Scope everything.&lt;/p&gt;

&lt;p&gt;Currently, Types and Functions are not very well scoped.&lt;/p&gt;

&lt;h1 id=&quot;trees&quot;&gt;Trees&lt;/h1&gt;

&lt;p&gt;Trees are hierarchical and do not poke information (incl. control flow) through to other layers.&lt;/p&gt;

&lt;h2 id=&quot;graphs&quot;&gt;Graphs&lt;/h2&gt;

&lt;p&gt;Graphs allow cross-talk between nodes.&lt;/p&gt;

&lt;p&gt;Graphs are not truly hierarchical.&lt;/p&gt;
&lt;h2 id=&quot;dags&quot;&gt;DAGs&lt;/h2&gt;
&lt;p&gt;DAGs allow cross-talk between nodes.&lt;/p&gt;

&lt;p&gt;DAGs are not truly hierarchical.&lt;/p&gt;

&lt;h2 id=&quot;optimization&quot;&gt;Optimization&lt;/h2&gt;
&lt;p&gt;Optimization sometime requires poking information through layer walls.&lt;/p&gt;

&lt;p&gt;This can be necessary, but, should be delayed as long as possible, since, by definition, it destroys (poke holes into) otherwise pluggable designs.&lt;/p&gt;

&lt;h2 id=&quot;low-level-operations&quot;&gt;Low-Level Operations&lt;/h2&gt;

&lt;p&gt;Any PL&lt;sup id=&quot;fnref:pl&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:pl&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; that provides, say “+” or “cons”, is too low-level for structured design and harms plug-ability of modules.&lt;/p&gt;

&lt;h1 id=&quot;transport-layer-for-functions&quot;&gt;Transport Layer for Functions&lt;/h1&gt;

&lt;p&gt;Referring to OSI’s model of layered networking, what is the Transport layer for functions?&lt;/p&gt;

&lt;p&gt;Do libraries obey the OSI model at the function level?&lt;/p&gt;

&lt;h1 id=&quot;cpu&quot;&gt;CPU&lt;/h1&gt;

&lt;p&gt;Most CPUs define the unit of pluggability to be the &lt;em&gt;byte&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Assembly op-codes are built on the assumption that instruction sequences have been pre-filtered.&lt;/p&gt;

&lt;p&gt;Additionally, many CPUs also define &lt;em&gt;sequentiality&lt;/em&gt; as a unit operation. Opcodes are sequential&lt;sup id=&quot;fnref:seq&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:seq&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:pl&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;PL means Programming Language &lt;a href=&quot;#fnref:pl&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:seq&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;There is no inherent reason that opcodes are interpreted in a sequential manner. In fact, the internal electronics of CPUs has circuitry to impose a sequential regimen onto opcode processing (i.e. this is a Design Choice, not inherent in the electronics itself). &lt;a href=&quot;#fnref:seq&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">What is the minimum unit of connect-ability?</summary></entry><entry><title type="html">Hierarchical Types</title><link href="https://computingsimplicity.neocities.org/2021/06/06/Hierarchical-Types.html" rel="alternate" type="text/html" title="Hierarchical Types" /><published>2021-06-06T00:00:00-04:00</published><updated>2021-06-06T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/06/06/Hierarchical%20Types</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/06/06/Hierarchical-Types.html">&lt;h1 id=&quot;hierarchical-types&quot;&gt;Hierarchical Types&lt;/h1&gt;

&lt;p&gt;Typed data is a packet with information arranged in layers wrapped in onion skins.&lt;/p&gt;

&lt;p&gt;Typing is a pipeline of filters that peels the information in a series of small steps.&lt;/p&gt;

&lt;p&gt;Networking already does this.&lt;/p&gt;

&lt;p&gt;Type-checking is (already) done like this. A type checker is an interpreter which peels a layer of information off from a program and passes the peeled program on to another interpreter (ultimately, the CPU, which is just another interpreter).&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See Also&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2020/12/09/Type-Stacks.html&quot;&gt;Type Stacks&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/01/14/References.html&quot;&gt;References&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://guitarvydas.github.io/2021/05/14/Table-Of-Contents.html&quot;&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;guitarvydas/guitarvydas.github.io&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async=&quot;&quot;&gt; 
&lt;/script&gt;</content><author><name></name></author><summary type="html">Hierarchical Types</summary></entry></feed>