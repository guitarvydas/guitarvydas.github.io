<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://computingsimplicity.neocities.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://computingsimplicity.neocities.org/" rel="alternate" type="text/html" /><updated>2021-04-02T07:15:05-04:00</updated><id>https://computingsimplicity.neocities.org/feed.xml</id><title type="html">Computing Simplicity</title><subtitle>Various thoughts on making programming simpler, and, breaking programming down into several disciplines: Architecture, Engineering, Implementation.  Concurrency is not parallelism and concurrency is not multitasking.  Until I get comments working on this blog, please email me.</subtitle><entry><title type="html">Projectional editing</title><link href="https://computingsimplicity.neocities.org/2021/04/02/Projectional-Editing.html" rel="alternate" type="text/html" title="Projectional editing" /><published>2021-04-02T00:00:00-04:00</published><updated>2021-04-02T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/02/Projectional%20Editing</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/02/Projectional-Editing.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Projectional Editing&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;projectionaleditingintwosteps&quot;&gt;Projectional Editing in Two Steps&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Reduce all input to normal form.&lt;/li&gt;
&lt;li&gt;Write rules against normal form. Rules &amp;#8212;&amp;gt; views.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1.normalform&quot;&gt;1. Normal Form&lt;/h1&gt;

&lt;p&gt;I favour a normal form consisting of &lt;em&gt;triples&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://guitarvydas.github.io/2021/03/16/Triples.html&quot;&gt;https://guitarvydas.github.io/2021/03/16/Triples.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2.rules&quot;&gt;2. Rules&lt;/h1&gt;

&lt;p&gt;You want to perform exhaustive search over &lt;em&gt;all&lt;/em&gt; of the triples.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;rule&lt;/em&gt; is just a group of related searches.&lt;/p&gt;

&lt;p&gt;Such searching can be done manually, using loops within loops.&lt;/p&gt;

&lt;p&gt;Or, one could use a tool &amp;#8212; a search engine &amp;#8212; to do the searching. One such search engine is PROLOG. Another engine might be miniKanren.&lt;/p&gt;

&lt;p&gt;PROLOG uses &lt;em&gt;backtracking&lt;/em&gt; to perform exhaustive search.&lt;/p&gt;

&lt;p&gt;PROLOG uses something called &lt;em&gt;logic&lt;/em&gt; &lt;em&gt;variables&lt;/em&gt; to hold the results of successful matches.&lt;/p&gt;

&lt;p&gt;There might be more than one match that succeeds in satisfying all of the search constraints. In such cases, PROLOG re-binds the values of the &lt;em&gt;logic variables&lt;/em&gt; and presents you, the programmer, with a set of consistent matches (as one set of bound &lt;em&gt;logic variables&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;MiniKanren, on the other hand, does not use the above method and keeps a running list of &lt;em&gt;all&lt;/em&gt; possible matches, then presents you, the programmer, with a list of &lt;em&gt;all&lt;/em&gt; matches that consistently solve the set of given match constraints.&lt;/p&gt;

&lt;h2 id=&quot;unification&quot;&gt;Unification&lt;/h2&gt;

&lt;p&gt;PROLOG uses an algorithm, called &lt;em&gt;unification&lt;/em&gt;, to re-bind &lt;em&gt;logic variables&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;One set of bindings describes &lt;em&gt;one&lt;/em&gt; solution to all of the match constraints.&lt;/p&gt;

&lt;p&gt;In essence, PROLOG &lt;em&gt;clears&lt;/em&gt; its &lt;em&gt;logic variables&lt;/em&gt; before calculating another solution. In essence, PROLOG memorizes previous solutions and does not present already-seen solutions again.&lt;/p&gt;

&lt;p&gt;[&lt;em&gt;Note, that this does not mean that duplicate solutions cannot be displayed &amp;#8212; PROLOG remembers the route that it used to find a solution, if it finds a different route which results in the same set of bindings, PROLOG will be happy to show you that solution as a possibility (much to the chagrin of PROLOG newbies).&lt;/em&gt;]&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Projectional Editing</summary></entry><entry><title type="html">Meta Programming</title><link href="https://computingsimplicity.neocities.org/2021/04/02/meta-programming.html" rel="alternate" type="text/html" title="Meta Programming" /><published>2021-04-02T00:00:00-04:00</published><updated>2021-04-02T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/02/meta-programming</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/02/meta-programming.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;meta-programming&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p&gt;Meta-programming is very much like projectional editing.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://guitarvydas.github.io/2021/04/02/Projectional-Editing.html&quot;&gt;https://guitarvydas.github.io/2021/04/02/Projectional-Editing.html&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">meta-programming</summary></entry><entry><title type="html">Crass simplifications</title><link href="https://computingsimplicity.neocities.org/2021/04/02/Crass-Simplifications.html" rel="alternate" type="text/html" title="Crass simplifications" /><published>2021-04-02T00:00:00-04:00</published><updated>2021-04-02T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/04/02/Crass%20Simplifications</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/04/02/Crass-Simplifications.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;plfa&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;I describe crass simplifications, which are not fully accurate, that I use to think about haughtier concepts, such as lambda calculus, free and bound variables.&lt;/p&gt;

&lt;h1 id=&quot;lambdacalculus&quot;&gt;Lambda Calculus&lt;/h1&gt;

&lt;p&gt;Lambda Calculus means &amp;#8220;everything is a function&amp;#8221;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In Common Lisp and Scheme, every function is a function. Every &lt;em&gt;function&lt;/em&gt; returns a value.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Counter-example:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In JavaScript, not everything is a function, for example&lt;/p&gt;

&lt;p&gt;function fn (x, y) {&lt;/p&gt;

&lt;p&gt;42;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;is different from&lt;/p&gt;

&lt;p&gt;function fn (x, y) {&lt;/p&gt;

&lt;p&gt;return 42;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;(One could say that the former is a procedure, not a function).&lt;/p&gt;

&lt;p&gt;To make JavaScript work like Lisp, one would need to ensure that &lt;em&gt;every&lt;/em&gt; function returns a 1&lt;sup&gt;st&lt;/sup&gt; class value. This can be done, but is boring to do, is error-prone, and results in unreadable (to humans) code.&lt;/p&gt;

&lt;h1 id=&quot;freevariables&quot;&gt;Free Variables&lt;/h1&gt;

&lt;p&gt;A &lt;em&gt;free variable&lt;/em&gt; can be thought of as being a &lt;em&gt;global variable&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;boundvariables&quot;&gt;Bound Variables&lt;/h1&gt;

&lt;p&gt;A &lt;em&gt;bound variable&lt;/em&gt; can be thought of as being&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a parameter&lt;/li&gt;
&lt;li&gt;a local variable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In fact, local variables are just syntactic sugar for nested lambdas, e.g.&lt;/p&gt;

&lt;p&gt;function (x) {&lt;/p&gt;

&lt;p&gt;var y;&lt;/p&gt;

&lt;p&gt;y = 41;&lt;/p&gt;

&lt;p&gt;return x + y;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;is really&lt;/p&gt;

&lt;p&gt;function (x) {&lt;/p&gt;

&lt;p&gt;function (y) {&lt;/p&gt;

&lt;p&gt;return x + y;&lt;/p&gt;

&lt;p&gt;} (41);&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&quot;examplefreeandboundvariables&quot;&gt;Example Free and Bound Variables&lt;/h1&gt;

&lt;p&gt;function (x) {&lt;/p&gt;

&lt;p&gt;return x + y;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;There are two variables in the above function, &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Variable &lt;em&gt;x&lt;/em&gt; is &lt;em&gt;bound&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Variable &lt;em&gt;y&lt;/em&gt; is &lt;em&gt;free&lt;/em&gt;. Variable &lt;em&gt;y&lt;/em&gt; is &lt;em&gt;unbound&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In the example below, &lt;em&gt;both&lt;/em&gt; variables are bound, but &lt;em&gt;y&lt;/em&gt; is uninitialized (&lt;em&gt;undefined&lt;/em&gt; in JavaScript-speak).&lt;/p&gt;

&lt;p&gt;function (x) {&lt;/p&gt;

&lt;p&gt;var y;&lt;/p&gt;

&lt;p&gt;return x + y;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">plfa</summary></entry><entry><title type="html">Simplicity vs complexity</title><link href="https://computingsimplicity.neocities.org/2021/03/30/Simplicity-vs-Complexity.html" rel="alternate" type="text/html" title="Simplicity vs complexity" /><published>2021-03-30T00:00:00-04:00</published><updated>2021-03-30T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/03/30/Simplicity%20vs%20Complexity</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/03/30/Simplicity-vs-Complexity.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Simplicity vs Complexity&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;simplicity&quot;&gt;Simplicity&lt;/h1&gt;

&lt;p&gt;A definition of &lt;em&gt;simplicity&lt;/em&gt; is&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lack of nuance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;complexity&quot;&gt;Complexity&lt;/h1&gt;

&lt;p&gt;Complexity is the opposite of simplicity.&lt;/p&gt;

&lt;p&gt;Complexity occurs in a system when there are too many variables to be juggled, at the same time, in a solution.&lt;/p&gt;

&lt;h1 id=&quot;simplification&quot;&gt;Simplification&lt;/h1&gt;

&lt;p&gt;To simplify something does not necessarily mean to delete variables from the system.&lt;/p&gt;

&lt;p&gt;One can simplify a problem by subdividing it. Divide and Conquer.&lt;/p&gt;

&lt;p&gt;I remember being told that humans can handle 7±2&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; items at a time.&lt;/p&gt;

&lt;p&gt;This would imply that one needs to apply Divide-and-Conquer until the number of variables in a subdivision is 7±2.&lt;/p&gt;

&lt;p&gt;The number of variables in a &lt;em&gt;system&lt;/em&gt; might be more than 7±2, say 100, but no part (subdivision) of the system should have more than 7±2 variables in it.&lt;/p&gt;

&lt;h2 id=&quot;physicists&quot;&gt;Physicists&lt;/h2&gt;

&lt;p&gt;Physicists simplify problems using approximations.&lt;/p&gt;

&lt;p&gt;When the effect of a variable is much less than (≪) the effect of some other variable, physicists make &lt;em&gt;simplifying assumptions &amp;#8212;&lt;/em&gt; they drop (elide) the former variable from their equations, dealing only with the latter variable(s).&lt;/p&gt;

&lt;p&gt;This does not mean that one approximation is valid in every situation.&lt;/p&gt;

&lt;p&gt;For example, in his book &amp;#8220;Order Out of Chaos&amp;#8221;, Nobel Laureate Ilya Prigogene&lt;a href=&quot;#fn:2&quot; id=&quot;fnref:2&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; decries the misuse of approximations that are not valid in certain situations.&lt;/p&gt;

&lt;p&gt;Often, people over-use an approximation, or a notation, once it has worked in some domain.&lt;/p&gt;

&lt;p&gt;I see this happening in programming, where, often the question is &amp;#8220;how do I re-cast this problem in a strongly-typed, functional manner?&amp;#8221; instead of asking &amp;#8220;what is the problem and how can it best be solved?&amp;#8221; and &amp;#8220;what approximations / notations are useful in this case?&amp;#8221;.&lt;/p&gt;

&lt;p&gt;In programming, we see this played out in synchronous notation being misused to solve asynchronous problems (e.g. multitasking and the accidental complexities it brought along) and in &amp;#8220;features&amp;#8221; like JavaScript&amp;#8217;s callbacks.&lt;/p&gt;

&lt;h1 id=&quot;errors&quot;&gt;Errors&lt;/h1&gt;

&lt;p&gt;Errors in one domain might not be errors in another domain.&lt;/p&gt;

&lt;p&gt;For example, a timeout is an error when building a ballistics calculator, but is an expected occurrence when building blockchain.&lt;/p&gt;

&lt;h1 id=&quot;tells-approximationmisuse&quot;&gt;Tells - Approximation Misuse&lt;/h1&gt;

&lt;p&gt;The &amp;#8220;tells&amp;#8221; of misuse of notations and approximations are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Increasing accidental complexity, e.g. mutexes, then thread safety, then priorities, etc.&lt;/li&gt;
&lt;li&gt;Deciding that something is &amp;#8220;hard&amp;#8221;, e.g. the generally agreed-upon notion that multitasking is just &amp;#8220;hard&amp;#8221;.&lt;a href=&quot;#fn:3&quot; id=&quot;fnref:3&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;divideandconquer&quot;&gt;Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Successful use of &lt;em&gt;divide and conquer&lt;/em&gt; reduces not only the number of variables at the input of a subdivision, but, also, reduces the number of outputs.&lt;/p&gt;

&lt;h2 id=&quot;fan-inandfan-out&quot;&gt;Fan-in and Fan-out&lt;/h2&gt;

&lt;p&gt;To be able to apply divide-and-conquer in infinitely many subdivisions&lt;a href=&quot;#fn:4&quot; id=&quot;fnref:4&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; a notation &lt;em&gt;must&lt;/em&gt; support reduction of the number of input ports and reduction of the number of output ports.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:2&quot;&gt;
&lt;p&gt;See https://guitarvydas.github.io/2021/01/14/References.html &lt;a href=&quot;#fnref:2&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:3&quot;&gt;
&lt;p&gt;This indicates that the wrong approximations and notation are being used. &lt;a href=&quot;#fnref:3&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:4&quot;&gt;
&lt;p&gt;see https://guitarvydas.github.io/2021/03/23/Everything&amp;#8211;is&amp;#8211;a&amp;#8211;Fractal.html &lt;a href=&quot;#fnref:4&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Simplicity vs Complexity</summary></entry><entry><title type="html">Mathematics redux</title><link href="https://computingsimplicity.neocities.org/2021/03/30/Mathematics-Redux.html" rel="alternate" type="text/html" title="Mathematics redux" /><published>2021-03-30T00:00:00-04:00</published><updated>2021-03-30T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/03/30/Mathematics%20Redux</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/03/30/Mathematics-Redux.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Mathematics Redux&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;twosubdivisionsofmathematics&quot;&gt;Two Subdivisions of Mathematics&lt;/h1&gt;

&lt;p&gt;Mathematics can be subdivided as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a notation&lt;/li&gt;
&lt;li&gt;a body of experience (e.g. in using the notation).&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;mathematicalnotation&quot;&gt;Mathematical Notation&lt;/h1&gt;

&lt;p&gt;Mathematical notation can be subdivided as:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;expressing a problem in mathematical notation&lt;/li&gt;
&lt;li&gt;manipulating the notation, reducing the expression of the problem.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;pencilandpaper&quot;&gt;Pencil and Paper&lt;/h2&gt;

&lt;p&gt;Mathematical notation was invented for use with pencil and paper.&lt;/p&gt;

&lt;p&gt;Mathematical notation is a 2D notation, not a 3D notation.&lt;/p&gt;

&lt;h2 id=&quot;timevariance&quot;&gt;Time Variance&lt;/h2&gt;

&lt;p&gt;Manipulation of mathematical notation works mostly because time-varying variables have been expunged from the notation (&amp;#8220;side-effect free&amp;#8221;).&lt;/p&gt;

&lt;p&gt;Removing time variance from the notation is an approximation. It works only in domains where time is not a major factor.&lt;/p&gt;

&lt;p&gt;[&lt;em&gt;Note that other approximations, like finite-element analysis, can give more accurate results in specific domains that have time variance.]&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;complexity&quot;&gt;Complexity&lt;/h1&gt;

&lt;p&gt;A &lt;em&gt;layer&lt;/em&gt; is only as complicated as one wishes to make it.&lt;/p&gt;

&lt;p&gt;The complexity lies in the amount of detail required to express the inputs and outputs of the layer.&lt;/p&gt;

&lt;p&gt;One can tune the complexity of each layer by using different notations and approximations in each layer, instead of trying to encompass &lt;em&gt;all&lt;/em&gt; variables in a single layer.&lt;/p&gt;

&lt;p&gt;Complexity is &amp;#8220;in the eye of the beholder&amp;#8221;. Mathematical notation appears complicated to some (most), but appears simple to those who have steeped themselves in the notation.&lt;/p&gt;

&lt;h2 id=&quot;whoistheaudience&quot;&gt;Who is the Audience?&lt;/h2&gt;

&lt;p&gt;Regarding mathematical notation, an interesting question to ask is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Who is the Intended Reader?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Is the notation meant to be used as communication between two mathematicians, or, between a mathematician and a non-mathematician (lawyer, graphics designer, construction worker, etc.)?&lt;/p&gt;

&lt;h2 id=&quot;details&quot;&gt;Details&lt;/h2&gt;

&lt;p&gt;Complexity comes from trying to address too many details at any one layer of a design.&lt;/p&gt;

&lt;p&gt;Successful complexity-management is the art of finding a group of inter-related details and relegating them to a layer.&lt;/p&gt;

&lt;h1 id=&quot;engineering&quot;&gt;Engineering&lt;/h1&gt;

&lt;p&gt;Engineers map notation from one domain into another.&lt;/p&gt;

&lt;p&gt;For example, in construction, Engineers use mathematics (from the Architects, from textbooks, etc.) and produce blueprints that are understood by construction workers.&lt;a href=&quot;#fn:2&quot; id=&quot;fnref:2&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Engineers filter out details.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;Actually, this can be subdivided even further. There is experience in using the notation and there is experience in thinking about problems (which are then mapped to this notation). &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:2&quot;&gt;
&lt;p&gt;One doesn't usually find Engineers performing actual construction work. Engineering is usually done before the construction begins. On&amp;#8211;site Engineers oversee that the work follows the specifications. Engineers might alter the specifications to better match reality as work progresses. &lt;a href=&quot;#fnref:2&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Mathematics Redux</summary></entry><entry><title type="html">State, analysis of</title><link href="https://computingsimplicity.neocities.org/2021/03/30/State,-Analysis-of.html" rel="alternate" type="text/html" title="State, analysis of" /><published>2021-03-30T00:00:00-04:00</published><updated>2021-03-30T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/03/30/State,%20Analysis%20of</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/03/30/State,-Analysis-of.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;State, Analysis of&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;stateandgoto&quot;&gt;State and GOTO&lt;/h1&gt;

&lt;p&gt;In this essay, I examine some of the uses of State.&lt;/p&gt;

&lt;p&gt;State has been maligned in literature, in the same manner that GOTO has been maligned.&lt;/p&gt;

&lt;p&gt;GOTO is used in every programming language — under the hood. Structured Programming showed us how to hide GOTO and to isolate&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; its use.&lt;/p&gt;

&lt;p&gt;State is used in threads, among other things.&lt;/p&gt;

&lt;p&gt;The problem is not State, but isolation of State.&lt;/p&gt;

&lt;p&gt;Another problem with State (and GOTO and Variables and Message Passing, etc.) is lack of code localization. Spaghetti state can be helped by strict nesting&lt;a href=&quot;#fn:2&quot; id=&quot;fnref:2&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;, in some instances.&lt;/p&gt;

&lt;p&gt;Throwing away all state might not be necessary.&lt;/p&gt;

&lt;h1 id=&quot;nuanceduseofcaseswitch&quot;&gt;Nuanced Use of Case (Switch)&lt;/h1&gt;

&lt;h2 id=&quot;casevs.types-oop&quot;&gt;Case vs. Types - OOP&lt;/h2&gt;

&lt;p&gt;One form of state is querying of object types.&lt;/p&gt;

&lt;p&gt;This problem was lassoed by Object-Oriented Programming&lt;a href=&quot;#fn:3&quot; id=&quot;fnref:3&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;casevs.continuations-statecharts&quot;&gt;Case vs. Continuations - StateCharts&lt;/h2&gt;

&lt;p&gt;CPS - Continuation Passing Style — is another form of GOTO. CPS is more powerful that GOTO.&lt;a href=&quot;#fn:4&quot; id=&quot;fnref:4&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CPS can become unruly when continuations are passed to regions of code that are not local to the origin of the continuation. JavaScript callbacks are an attempt to syntactically nest such uses, but callbacks failed to deliver enough benefits.&lt;/p&gt;

&lt;p&gt;Exceptions are another attempt at encapsulating CPS. Exceptions are flawed in that they are declared statically but operate dynamically. The dynamic call-chain determines the control-flow changes caused by exceptions.&lt;/p&gt;

&lt;p&gt;GOTO changes control-flow.&lt;/p&gt;

&lt;p&gt;OO bundles up data. (Closures also bundle up data).&lt;/p&gt;

&lt;p&gt;CPS bundles up and delivers, both, control-flow and data.&lt;/p&gt;

&lt;p&gt;StateCharts provide a way to describe non-linear changes to control-flow that retain code locality.&lt;/p&gt;

&lt;p&gt;I discuss the original StateCharts paper in
https://guitarvydas.github.io/2020/12/09/StateCharts.html
and
https://guitarvydas.github.io/2021/02/25/statecharts-(again).html&lt;/p&gt;

&lt;h2 id=&quot;patternmatching&quot;&gt;Pattern Matching&lt;/h2&gt;

&lt;p&gt;Pattern matching consists of two parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a pattern (a DSL)&lt;/li&gt;
&lt;li&gt;a matching engine.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One can obviate the need for flags (and associated if…then…else…endif code) by writing patterns instead.&lt;/p&gt;

&lt;p&gt;Pattern matching was explored in compiler technologies and is called parsing in that literature.&lt;/p&gt;

&lt;p&gt;Pattern matching is used in function languages, as a way to remove the need for variables and for writing declarative specifications of code using overloaded functions. PatternParsing is a more general form of this kind of pattern matching.&lt;/p&gt;

&lt;p&gt;A common use of pattern matching is REGEX. Patterns are written in a DSL called a REGEX and the matching engine is hidden from view. For example, to match and &amp;#8220;a&amp;#8221; followed by a &amp;#8220;b&amp;#8221;, one would write a REGEX DSL snippet &amp;#8220;/ab/&amp;#8221;.&lt;/p&gt;

&lt;p&gt;An early form of a pattern-matching-and-engine language is PROLOG. One would write patterns and the PROLOG engine would use backtracking to return an exhaustive list of all matches.&lt;/p&gt;

&lt;p&gt;Early forms of pattern matching in compilers was embodied in tools such as LEX and YACC.&lt;/p&gt;

&lt;p&gt;The most recent form of pattern matching is PEG. PEG subsumes the capabilities of REGEX, LEX and YACC.&lt;/p&gt;

&lt;p&gt;PEG uses a backtracking engine and, thus, subsumes some of the uses of PROLOG (and other relational technologies).&lt;/p&gt;

&lt;p&gt;PEG might enable a new breed of programming, for example DSLs that write DSLs (I call these SCLs&lt;a href=&quot;#fn:5&quot; id=&quot;fnref:5&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;PEG rules can be built in layers, hence, PEG could be used to match text and to match type information. This should allow PEG to be used instead of REGEX and Haskell.&lt;/p&gt;

&lt;h2 id=&quot;conditionalcompilation-ifdef&quot;&gt;Conditional Compilation - #IFDEF&lt;/h2&gt;

&lt;p&gt;Conditional compilation has been used as a way of creating &amp;#8220;portable&amp;#8221; programs by brute force.&lt;/p&gt;

&lt;p&gt;Conditional compilation is known as &amp;#8220;#ifdef&amp;#8221; in C-class languages and &amp;#8220;#+&amp;#8221; in Lisp-class languages.&lt;/p&gt;

&lt;p&gt;In &amp;#8220;#ifdef&amp;#8221; languages, a DSL is used to express conditional compilation. The DSL is usually distinct from the underlying language, e.g. the kind of expressions used in C #ifdef is a language unto itself and does not provide access to the full C language.&lt;/p&gt;

&lt;p&gt;In &amp;#8220;#+&amp;#8221; Lisp conditional compilation, the expression language is full Lisp itself — no extra DSL is created.&lt;/p&gt;

&lt;p&gt;Such conditional compilation is a small step towards the full generality of pattern matching. Little languages — SCLs and DSLs — built on top of these languages could provide the desired conditional compilation effects.&lt;/p&gt;

&lt;p&gt;Portability was explored in compiler technologies, for example the techniques developed for dealing with disparate target CPU architectures.&lt;/p&gt;

&lt;p&gt;Many of the successful techniques at portability used a two phase approach. The compiler would emit code for a generalized architecture (often called a VM, today) and a pattern-matcher would transform the generalized code into code specialized for a particular architecture.&lt;/p&gt;

&lt;p&gt;Some of the interesting technologies included:&lt;a href=&quot;#fn:6&quot; id=&quot;fnref:6&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Orthogonal Code Generator — a declarative specification that mapped abstract instructions into specific instructions&lt;/li&gt;
&lt;li&gt;RTL — the method used by gcc — the VM consisted of an &amp;#8220;infinite&amp;#8221; number of registers and the compiler would simply emit register-based code ; in the second pass a peephole optimizer would be used to convert the register-based code into code specialized for a specific CPU architecture&lt;/li&gt;
&lt;li&gt;Denotational Semantics — a method of defining a language in the functional domain, then mapping the functions into specialized code, Peter Lee defined the source language in phases (layers) and made the Denotational Semantics technique practical ; each phase was described as a function mapping a source language onto a simpler domain ; each target domain was simpler than the preceding domain until the final domain was some executable architecture (e.g. Scheme, 808x, etc.).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[Note that all of the above techniques are based on Divide and Conquer. The transformations become easier as more layers are added.]&lt;/p&gt;

&lt;h2 id=&quot;macros&quot;&gt;Macros&lt;/h2&gt;

&lt;p&gt;Macros are DSLs for changing the behaviour of compilers (and interpreters).&lt;/p&gt;

&lt;p&gt;Macros can program the compiler.&lt;/p&gt;

&lt;p&gt;In the extreme case — e.g. Lisp macros — macros employ the full underlying language. For example one can write a Lisp program that is run at compile-time. This lisp program — called a macro — creates new source code that is fed to the compiler.&lt;/p&gt;

&lt;p&gt;In the other extreme, e.g. C macros, a separate macro-processor phase is run and its output is fed to the C compiler. Such macros work in two steps — preprocess, then compile. Obviously, the Lisp method is more powerful, but carries more potential risk.&lt;/p&gt;

&lt;p&gt;Inlining of functions is a formalization of macros. Inlining is an attempt to encapsulate one use-case of macros, e.g. optimization of programs defined in the function-only domain.&lt;/p&gt;

&lt;p&gt;Lisp macro processing work recursively. C-style macro preprocessing works in only two steps.&lt;/p&gt;

&lt;p&gt;The ideal extension would be to have an infinite number of preprocessing steps — a pipeline of preprocessors. [PEG might be one way to achieve this effect. PEG grammars that emit programs that are further processed by other PEG grammars, and so on.]&lt;/p&gt;

&lt;h2 id=&quot;casevs.flags&quot;&gt;Case vs. Flags&lt;/h2&gt;

&lt;p&gt;PL constructs like
if … then … else … end if
allow code to query state flags with little constraint on how the code is nested.&lt;/p&gt;

&lt;p&gt;It is possible to write clear code using such constructs, but such structuring tends to be rare.&lt;/p&gt;

&lt;p&gt;Likewise, note that it is possible to write clear code in assembly language, including all forms of 1st class functions, etc.&lt;/p&gt;

&lt;p&gt;Code in general, needs to be constrained with syntactic sugar.&lt;/p&gt;

&lt;h1 id=&quot;functionsandfunctionalprogramming&quot;&gt;Functions and Functional Programming&lt;/h1&gt;

&lt;p&gt;FP (functional programming) is but one way to structure code.&lt;/p&gt;

&lt;p&gt;FP limits the available paradigms to, mostly, a one-in and one-out style. Various extensions to FP include exceptions and full-blown use of CPS, e.g. in Denotational Semantics, but, the results are increasingly less readable.&lt;/p&gt;

&lt;p&gt;FP works by prohibiting changes of state — this creates isolation between functions and allows manipulation of the notation.&lt;/p&gt;

&lt;p&gt;It should be noted that UNIX® processes also create isolation between blocks of code — no data nor control-flow can escape the boundaries of a process.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;Isolation is like encapsulation, but includes control&amp;#8211;flow. &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:2&quot;&gt;
&lt;p&gt;As seen with the solutions for Global Variables, Structured Programming, etc. &lt;a href=&quot;#fnref:2&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:3&quot;&gt;
&lt;p&gt;Bertrand Meyer pointed this out. &lt;a href=&quot;#fnref:3&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:4&quot;&gt;
&lt;p&gt;And, therefore, CPS is more dangerous that GOTO. &lt;a href=&quot;#fnref:4&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:5&quot;&gt;
&lt;p&gt;SCL mean Solution Centric Language. &lt;a href=&quot;#fnref:5&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:6&quot;&gt;
&lt;p&gt;See https://guitarvydas.github.io/2021/01/14/References.html &lt;a href=&quot;#fnref:6&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">State, Analysis of</summary></entry><entry><title type="html">Programming redux</title><link href="https://computingsimplicity.neocities.org/2021/03/30/Programming-Redux.html" rel="alternate" type="text/html" title="Programming redux" /><published>2021-03-30T00:00:00-04:00</published><updated>2021-03-30T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/03/30/Programming%20Redux</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/03/30/Programming-Redux.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Programming Redux&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p&gt;See &lt;a href=&quot;https://guitarvydas.github.io/2021/03/30/Mathematics-Redux.html&quot;&gt;https://guitarvydas.github.io/2021/03/30/Mathematics-Redux.html&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Replace all references to &lt;em&gt;mathematics&lt;/em&gt; by &lt;em&gt;PL&lt;/em&gt;s (Programming Languages).&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Programming Redux</summary></entry><entry><title type="html">Scls little languages playlist</title><link href="https://computingsimplicity.neocities.org/2021/03/29/SCLs-Little-Languages-Playlist.html" rel="alternate" type="text/html" title="Scls little languages playlist" /><published>2021-03-29T00:00:00-04:00</published><updated>2021-03-29T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/03/29/SCLs%20Little%20Languages%20Playlist</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/03/29/SCLs-Little-Languages-Playlist.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;LItlle Languages Playlist&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p&gt;(brief, rough, overview of Ohm, PEG, pattern matching, SCLs)&lt;/p&gt;

&lt;p&gt;Use the Ohm Editor (good for any PEG grammar) &lt;a href=&quot;https://ohmlang.github.io/editor/&quot;&gt;https://ohmlang.github.io/editor/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;peg&quot;&gt;PEG&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2020/12/27/PEG.html&quot;&gt;https://guitarvydas.github.io/2020/12/27/PEG.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;pegvs.otherpatternmatchers&quot;&gt;PEG vs. Other Pattern Matchers&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/03/17/PEG-vs.-Other-Pattern-Matchers.html&quot;&gt;https://guitarvydas.github.io/2021/03/17/PEG-vs.-Other-Pattern-Matchers.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;littlelanguagedevelopment&quot;&gt;Little Language Development&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/03/19/Racket-PEG.html&quot;&gt;https://guitarvydas.github.io/2021/03/19/Racket-PEG.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ohminsmallsteps&quot;&gt;Ohm in Small Steps&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2020/12/09/OhmInSmallSteps.html&quot;&gt;https://guitarvydas.github.io/2020/12/09/OhmInSmallSteps.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;racketpeg&quot;&gt;Racket Peg&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/03/19/Racket-PEG.html&quot;&gt;https://guitarvydas.github.io/2021/03/19/Racket-PEG.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;schemetojavascript&quot;&gt;Scheme to JavaScript&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/03/01/Scheme-to-Javascript.html&quot;&gt;https://guitarvydas.github.io/2021/03/01/Scheme-to-Javascript.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;svggrammar&quot;&gt;SVG Grammar&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/03/15/SVG-grammar.html&quot;&gt;https://guitarvydas.github.io/2021/03/15/SVG-grammar.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;gluemanual&quot;&gt;GLUE manual&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/03/24/Glue-Manual.html&quot;&gt;https://guitarvydas.github.io/2021/03/24/Glue-Manual.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;regexvspeg&quot;&gt;REGEX vs PEG&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/03/24/REGEX-vs-PEG.html&quot;&gt;https://guitarvydas.github.io/2021/03/24/REGEX-vs-PEG.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;svgtocode&quot;&gt;SVG to Code&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://guitarvydas.github.io/2021/03/24/SVG-to-Code-(1).html&quot;&gt;https://guitarvydas.github.io/2021/03/24/SVG-to-Code-(1).html&lt;/a&gt;&lt;/p&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">LItlle Languages Playlist</summary></entry><entry><title type="html">Message passing</title><link href="https://computingsimplicity.neocities.org/2021/03/27/Message-Passing.html" rel="alternate" type="text/html" title="Message passing" /><published>2021-03-27T00:00:00-04:00</published><updated>2021-03-27T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/03/27/Message%20Passing</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/03/27/Message-Passing.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;Message Passing&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;messagepassing&quot;&gt;Message Passing&lt;/h1&gt;

&lt;p&gt;In my opinion, the term &amp;#8220;message passing&amp;#8221; means &amp;#8220;fire and forget&amp;#8221;.&lt;/p&gt;

&lt;p&gt;A single, atomic operation.&lt;/p&gt;

&lt;p&gt;Send ().&lt;/p&gt;

&lt;p&gt;Asynchronous.&lt;/p&gt;

&lt;p&gt;AFAICT, most current, so-called forms of message-passing consist of two atomic operations:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Send ()&lt;/li&gt;
&lt;li&gt;Wait ().&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;which results in synchronous operation.&lt;/p&gt;

&lt;p&gt;Step 2. is usually implied by the use of CALL / RETURN.&lt;/p&gt;

&lt;p&gt;A gedanken test of true message-passing would be to convert all instances of all classes into separate threads (ignoring efficiency). One will be forced to convert every &amp;#8220;message send&amp;#8221; into two atomic operations — Send (), Wait ().&lt;/p&gt;

&lt;p&gt;Synchrony is so pervasive that we have sought ways to force-fit synchrony into inherently asynchronous paradigms (e.g. by using envelopes called threads, by implementing synchronous RPC, etc.).&lt;/p&gt;

&lt;h1 id=&quot;hardwaresupportglobalvariable&quot;&gt;Hardware Support Global Variable&lt;/h1&gt;

&lt;p&gt;It should be noted that our hardware, since The Stack was invented,&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; implicitly supports the synchronous CALL / RETURN paradigm by making The Stack into a global variable that records the dynamic call-chain.&lt;/p&gt;

&lt;p&gt;CALL modifies The Stack.&lt;/p&gt;

&lt;p&gt;RETURN modifies The Stack.&lt;/p&gt;

&lt;p&gt;Threads hide the fact The Stack is a global variable, by wrapping envelopes around it.&lt;/p&gt;

&lt;p&gt;See, also,
https://guitarvydas.github.io/2020/12/25/The-ALGOL-Bottleneck.html
https://guitarvydas.github.io/2021/02/25/The-Stack-is-a-Global-Variable-(again).html&lt;/p&gt;

&lt;h1 id=&quot;future&quot;&gt;Future&lt;/h1&gt;

&lt;p&gt;I believe that part of the future of computing lies in removing the redundant Wait ().&lt;/p&gt;

&lt;p&gt;We see it beginning to happen with distributed languages like HTML&lt;a href=&quot;#fn:2&quot; id=&quot;fnref:2&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We see it beginning to happen with the exploration of languages based on relations, etc.&lt;/p&gt;

&lt;p&gt;We see the need for this arising in technologies like p2p and blockchain (which tend to be concerned with asynchronous operations and network protocols).&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;Early IBM 360s did not have a Stack. Programmers needed to use the BALR instruction. &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:2&quot;&gt;
&lt;p&gt;See https://guitarvydas.github.io/2020/12/09/CALL&amp;#8211;RETURN&amp;#8211;Spaghetti.html for an idea on how to implement wait&amp;#8211;less Send() on current hardware. &lt;a href=&quot;#fnref:2&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">Message Passing</summary></entry><entry><title type="html">Cps considered to be a goto</title><link href="https://computingsimplicity.neocities.org/2021/03/27/CPS-Considered-to-be-a-GOTO.html" rel="alternate" type="text/html" title="Cps considered to be a goto" /><published>2021-03-27T00:00:00-04:00</published><updated>2021-03-27T00:00:00-04:00</updated><id>https://computingsimplicity.neocities.org/2021/03/27/CPS%20Considered%20to%20be%20a%20GOTO</id><content type="html" xml:base="https://computingsimplicity.neocities.org/2021/03/27/CPS-Considered-to-be-a-GOTO.html">&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;/&gt;
	&lt;title&gt;CPS Considered to be a GOTO&lt;/title&gt;
	&lt;meta name=&quot;author&quot; content=&quot;&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;goto&quot;&gt;GOTO&lt;/h1&gt;

&lt;p&gt;CPS — continuation passing style — is just a generalization of GOTO.&lt;/p&gt;

&lt;p&gt;First-class functions, too, are just generalizations of GOTOs.&lt;/p&gt;

&lt;p&gt;GOTO changes the program flow.&lt;/p&gt;

&lt;p&gt;First-class functions, hence, CPS, allow one to pass program flow around as first-class objects.&lt;/p&gt;

&lt;p&gt;One can call a first-class function object, hence invoke a continuation via CPS, at any point, well-away from its origin.&lt;/p&gt;

&lt;p&gt;In FORTRAN, there was a construct called a &amp;#8220;computed GOTO&amp;#8221;. CPS is even more &amp;#8220;powerful&amp;#8221; than this FORTRAN concept.&lt;/p&gt;

&lt;h1 id=&quot;spaghettiflow&quot;&gt;Spaghetti Flow&lt;/h1&gt;

&lt;p&gt;CPS (and first-class functions) can lead to spaghetti coding, much like GOTO did.&lt;/p&gt;

&lt;p&gt;Self-disciplined assembler programmers produced well-structured code in assembler.&lt;/p&gt;

&lt;p&gt;Average programmers needed &amp;#8220;help&amp;#8221; from Structured Programming languages.&lt;/p&gt;

&lt;p&gt;Self-disciplined assembler programmers complained about Structured Programming languages.&lt;/p&gt;

&lt;p&gt;No one bothered to write code in assembler — structured or spaghetti — after the self-disciplined assembler programmers retired.&lt;/p&gt;

&lt;p&gt;Self-disciplined FP programmers can produce well-structured code.&lt;/p&gt;

&lt;h1 id=&quot;usesforcps&quot;&gt;Uses for CPS&lt;/h1&gt;

&lt;p&gt;CPS is a low-level operation, like GOTO.&lt;/p&gt;

&lt;p&gt;As such, CPS is useful in building control-flow constructs.&lt;/p&gt;

&lt;p&gt;CPS is used in Denotational Semantics — which is a method for building languages and control-flow constructs.&lt;/p&gt;

&lt;p&gt;CPS should not be used for regular programming.&lt;/p&gt;

&lt;p&gt;Unstructured used of first-class functions should not be used for regular programming, either.&lt;/p&gt;

&lt;h1 id=&quot;threads&quot;&gt;Threads&lt;/h1&gt;

&lt;p&gt;When FP breaks out of its sweet-spot, we have to resort to constructs like threads.&lt;/p&gt;

&lt;p&gt;Threads are envelopes that allow the calculator-like paradigm to continue to be used — each calculator being wrapped in its own envelope VM.&lt;/p&gt;

&lt;p&gt;Threads are based on state. Thread envelopes hide this state, but do not eliminate state.&lt;/p&gt;

&lt;p&gt;In some use-cases,&lt;a href=&quot;#fn:1&quot; id=&quot;fnref:1&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; this kind of state is important enough that it should not be hidden from view.&lt;/p&gt;

&lt;p&gt;It is possible to extend the FP paradigm beyond its sweet-spot, but the question that needs to be asked is whether this is a good idea.&lt;/p&gt;

&lt;h1 id=&quot;thequestions&quot;&gt;The Questions&lt;/h1&gt;

&lt;p&gt;The questions to be asked are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What are we trying to accomplish?&lt;/li&gt;
&lt;li&gt;Why do we need to extend our notation to include CPS?&lt;/li&gt;
&lt;li&gt;What paradigm(s) is FP good for?&lt;/li&gt;
&lt;li&gt;What paradigm(s) is FP not so good for?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[The question is not: &amp;#8220;how do we paper-over the FP paradigm, once we have found a fault in it?&amp;#8221;]&lt;/p&gt;

&lt;h1 id=&quot;thefix&quot;&gt;The Fix&lt;/h1&gt;

&lt;h2 id=&quot;structuredscaffolds&quot;&gt;Structured Scaffolds&lt;/h2&gt;

&lt;p&gt;GOTOs were &amp;#8220;fixed&amp;#8221; by creating structured scaffolding around them.&lt;/p&gt;

&lt;p&gt;FP creates structured scaffolding around constructs using its strict one-in-one-out rule (function-call-and-function-return (I won&amp;#8217;t mention exceptions, which are based on a dynamic global variable&lt;a href=&quot;#fn:2&quot; id=&quot;fnref:2&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;)).
The FP paradigm is useful in one-in-one-out situations — e.g. fancy calculators&lt;a href=&quot;#fn:3&quot; id=&quot;fnref:3&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;morequesions&quot;&gt;More Quesions&lt;/h2&gt;

&lt;h3 id=&quot;state&quot;&gt;State&lt;/h3&gt;

&lt;p&gt;Is state The Problem?&lt;/p&gt;

&lt;p&gt;Or, is unstructured use of state a problem?&lt;/p&gt;

&lt;p&gt;State can be easily structured using StateCharts:
https://guitarvydas.github.io/2021/02/25/statecharts-(again).html
https://guitarvydas.github.io/2020/12/09/StateCharts.html&lt;/p&gt;

&lt;h3 id=&quot;globalvariables&quot;&gt;Global Variables&lt;/h3&gt;

&lt;p&gt;Were global variables The Problem?&lt;/p&gt;

&lt;p&gt;Or was unstructured use of variables a problem?&lt;/p&gt;

&lt;p&gt;The solution was to invent scoped variables, and, local variables.&lt;/p&gt;

&lt;p&gt;This implies that global variables were not actually the problem, but that unstructured use of variables was the problem.&lt;/p&gt;

&lt;h3 id=&quot;locality&quot;&gt;Locality&lt;/h3&gt;

&lt;p&gt;Lambda calculus gives us free variables.&lt;/p&gt;

&lt;p&gt;At what point do free variables become global variables?&lt;/p&gt;

&lt;p&gt;When a closure fits on one line, the variables don&amp;#8217;t appear to be global.&lt;/p&gt;

&lt;p&gt;When a closure fits on one window, the variables don&amp;#8217;t appear to be global.&lt;/p&gt;

&lt;p&gt;When a closure is large and doesn&amp;#8217;t fit into one viewport of one window, the free variables appear to be like global variables.&lt;/p&gt;

&lt;p&gt;It appears, to me, that locality is more important than global-ness. I could use&lt;a href=&quot;#fn:4&quot; id=&quot;fnref:4&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; a mini-language that had no local variables — and allowed only 26 variables at maximum. As long as lumps of that kind of code were well-isolated&lt;a href=&quot;#fn:5&quot; id=&quot;fnref:5&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;, the global-ness of the variables did not bother me.&lt;/p&gt;

&lt;p&gt;Currently, types and functions are in a flat space and are not localized / structured. Packaging systems are bandaids for this broader problem (of locality).&lt;/p&gt;

&lt;p&gt;Q: How does one Structure the use of types? How does one Structure the use of functions? Without causing new/hidden dependencies? Is packaging enough or is it a bandaid?&lt;/p&gt;

&lt;h3 id=&quot;inheritance&quot;&gt;Inheritance&lt;/h3&gt;

&lt;p&gt;Inheritance breaks locality, much like CPS does.&lt;/p&gt;

&lt;p&gt;It is possible to invoke a method well-away from the original source point.&lt;/p&gt;

&lt;p&gt;Inheritance for structuring code leads to debugging problems. One finds it hard to understand which methods can be overridden and where they are.&lt;/p&gt;

&lt;p&gt;Composition exhibits less of this kind of problem.&lt;/p&gt;

&lt;p&gt;Q: Can inheritance be cleaved into two pieces? The &amp;#8220;good&amp;#8221; inheritance vs. the &amp;#8220;bad&amp;#8221; kind?&lt;/p&gt;

&lt;p&gt;Q: What is code reuse? A: An implementation detail.&lt;/p&gt;

&lt;p&gt;Q: What is architectural reuse?&lt;a href=&quot;#fn:6&quot; id=&quot;fnref:6&quot; title=&quot;see footnote&quot; class=&quot;footnote&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;calculatorsanddesktops&quot;&gt;Calculators and Desktops&lt;/h2&gt;

&lt;p&gt;Calculators are like desktops — old-fashioned concepts that act like bridges into new paradigms.&lt;/p&gt;

&lt;p&gt;[It is my understanding that electric motors were first used to pump water uphill to create artificial streams that could power water wheels for mills and factories.]&lt;/p&gt;

&lt;h2 id=&quot;multipleparadigmsforeachsolution&quot;&gt;Multiple Paradigms for Each Solution&lt;/h2&gt;

&lt;p&gt;I believe that it is important to use paradigms that fit the problem. I believe in using multiple paradigms to solve any one problem. IMO, force-fitting the same paradigm onto all problems is old-fashioned thinking. I believe that programming can break through its asymptote only through the development of muti-paradigm workflows.&lt;/p&gt;

&lt;p&gt;[FYI - I, also, believe that diagrams should be raised to the same level of syntax as text. Diagrams show nesting in ways that is harder-to-read in text.]&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;

&lt;li id=&quot;fn:1&quot;&gt;
&lt;p&gt;e.g. sequencers, DAWs, machine control, robots &lt;a href=&quot;#fnref:1&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:2&quot;&gt;
&lt;p&gt;https://guitarvydas.github.io/2021/02/25/The&amp;#8211;Stack&amp;#8211;is&amp;#8211;a&amp;#8211;Global&amp;#8211;Variable&amp;#8211;(again).html &lt;a href=&quot;#fnref:2&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:3&quot;&gt;
&lt;p&gt;e.g. ballistics calculations &lt;a href=&quot;#fnref:3&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:4&quot;&gt;
&lt;p&gt;and, once, implemented &lt;a href=&quot;#fnref:4&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:5&quot;&gt;
&lt;p&gt;https://guitarvydas.github.io/2020/12/09/Isolation.html &lt;a href=&quot;#fnref:5&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn:6&quot;&gt;
&lt;p&gt;https://guitarvydas.github.io/2020/12/09/Reuse.html &lt;a href=&quot;#fnref:6&quot; title=&quot;return to body&quot; class=&quot;reversefootnote&quot;&gt;&amp;#160;&amp;#8617;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;

&lt;script src=&quot;https://utteranc.es/client.js&quot; 
        repo=&quot;guitarvydas/guitarvydas.github.io&quot; 
        issue-term=&quot;pathname&quot; 
        theme=&quot;github-light&quot; 
        crossorigin=&quot;anonymous&quot; 
        async&gt; 
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</content><author><name></name></author><summary type="html">CPS Considered to be a GOTO</summary></entry></feed>