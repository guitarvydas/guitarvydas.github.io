<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>What Is Programming</title>
  <meta name="CreationTime" content="2021-01-19T15:05:14Z">
  <meta name="ModificationTime" content="2021-01-19T15:05:14Z">
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1894.6">
  <style type="text/css">
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; text-indent: 18.0px; font: 12.0px Helvetica}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino}
    p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; min-height: 18.0px}
    p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Palatino}
    p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p11 {margin: 0.0px 0.0px 0.0px 36.0px; text-indent: -36.0px; font: 12.0px Helvetica}
    li.li7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino}
    li.li8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Palatino; min-height: 18.0px}
    span.s1 {font: 12.0px Helvetica}
    span.s2 {font: 13.0px Palatino}
    ul.ul1 {list-style-type: disc}
  </style>
</head>
<body>
<div style="width: 600px; margin: 0 auto">

<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>What Is Programming?</b></h2>
<p class="p2">Is mathematics programming?</p>
<p class="p3"><br></p>
<p class="p2">Is Javascript programming?</p>
<p class="p3"><br></p>
<p class="p2">What is programming?</p>
<p class="p3"><br></p>
<p class="p2">Is "GOTO Considered Harmful" about programming?</p>
<p class="p3"><br></p>
<p class="p2">Is The Mythical Man-Month about programming?<span class="Apple-converted-space">  </span>Where does "Second System" syndrome fit?</p>
<p class="p3"><br></p>
<p class="p2">How did Bell achieve four-nines (0.9999 uptime) in the 1900's without using Haskell?</p>
<p class="p3"><br></p>
<p class="p2">What is a "current directory"?<span class="Apple-converted-space">  </span>Is that related to programming?</p>
<p class="p3"><br></p>
<p class="p2">What is CamelCase?<span class="Apple-converted-space">  </span>Is that related to programming?</p>
<p class="p3"><br></p>
<p class="p2">I believe that the field of <i>programming</i> has not been sufficiently sub-divided.<span class="Apple-converted-space">  </span>I believe that <i>pure research</i> is, currently, being conflated with <i>applied research, </i>such as <i>architecture, engineering </i>and <i>implementation</i>.</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>What is Computing?</b></h2>
<p class="p2">For that matter, what is Computing? <span class="Apple-converted-space"> </span></p>
<p class="p3"><br></p>
<p class="p2">Is Computing about making calculations?</p>
<p class="p3"><br></p>
<p class="p2">Is Computing about controlling machines?</p>
<p class="p3"><br></p>
<p class="p2">Is Computing more than one thing?</p>
<p class="p3"><br></p>
<p class="p2">See my thoughts on this in <a href="https://guitarvydas.github.io/2021/01/02/The-Primary-Issue.html">https://guitarvydas.github.io/2021/01/02/The-Primary-Issue.html</a>.</p>
<p class="p3"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Categories of Programming</b></h2>
<p class="p2">The word <i>programming</i> is a loaded term.<span class="Apple-converted-space">  </span>It can mean many things.</p>
<p class="p3"><br></p>
<p class="p2">As usual, fractal-man comes to the rescue.</p>
<p class="p3"><br></p>
<p class="p2">We can sub-divide a loaded term to gain new insights.</p>
<p class="p3"><br></p>
<p class="p2">Off the top of my head, I see <i>programming</i> as four (4) different disciplines.</p>
<p class="p3"><br></p>
<p class="p2">At present our PLs are highly polarized - there are PLs for Pure Research and languages for Implementation, but not much in between (e.g. generally no PLs for Software Architecture and generally no PLs for Software Engineering).</p>
<p class="p3"><br></p>
<p class="p2">At present, all sub-categories of <i>programming</i> are conflated.<span class="Apple-converted-space">  </span>Most individual software professionals perform bits of each category. Most software professionals work on intuition.<span class="Apple-converted-space">  </span>Some individuals are better / more experienced / biased at certain goals and produce imbalanced results.</p>
<p class="p3"><br></p>
<p class="p2"><span class="Apple-converted-space">  </span>It might help to think of other<a id="fnlink1"></a><a href="#fn1"><sup>[1]</sup></a> disciplines, e.g. bridge construction.</p>
<p class="p3"><br></p>
<p class="p2">I list further thoughts below and in <span class="s1">Fig. 1</span></p>
<p class="p4"><br></p>
<p class="p5"><img src="/assets/2021-01-19-15-05-14-Images/Nesting.png" width="400px" height="302px" alt="Image"></p>
<p class="p6"><img src="/assets/2021-01-19-15-05-14-Images/Nesting1.png" width="400px" height="302px" alt="Image"></p>
<p class="p5">Fig. 1 Software Development Categories</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Pure Research</b></h2>
<p class="p2">Pure Research tries to define the boundaries of software design using first principles.</p>
<p class="p3"><br></p>
<p class="p2">Ironically, Pure Research defines things like numbers, but does not define what <i>programming</i> is.</p>
<p class="p3"><br></p>
<p class="p2">Pure Research, for example, does not constrain the use<a id="fnlink2"></a><a href="#fn2"><sup>[2]</sup></a> of GOTOs.<span class="Apple-converted-space">  </span>In fact, Pure Research gives us GOTOs-on-steroids in the form of CPS.<a id="fnlink3"></a><a href="#fn3"><sup>[3]</sup></a><span class="Apple-converted-space">  </span>CPS is useful for Denotational Semantics, but should not be used in day-to-day software applications (e.g. for Maintenance reasons).</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Research PLs</b></h2>
<p class="p2">Agda</p>
<p class="p2">Coq</p>
<p class="p2">Haskell<a id="fnlink4"></a><a href="#fn4"><sup>[4]</sup></a></p>
<p class="p2">(list incomplete and changing over time)</p>
<p class="p3"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Architecture</b></h2>
<p class="p2">Software Architecture is the embodiment of experience in solving day-to-day application problems.</p>
<p class="p3"><br></p>
<p class="p2">Tools of Software Architecture include:</p>
<p class="p3"><br></p>
<ul class="ul1">
  <li class="li7">RY (as opposed to DRY)<a id="fnlink5"></a><a href="#fn5"><sup>[5]</sup></a></li>
  <li class="li7">reuse of Architecture (as opposed to reuse of code)</li>
  <li class="li7">little languages<a id="fnlink6"></a><a href="#fn6"><sup>[6]</sup></a></li>
  <li class="li7">etc.</li>
</ul>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p2">UML is an early attempt at Software Architecture.</p>
<p class="p3"><br></p>
<p class="p2">Modeling (vs. compiling) is the domain of Software Architecture.</p>
<p class="p3"><br></p>
<p class="p2"><i>Superposition </i>is required by Software Architecture. Designing systems is only possible using technologies that provide <i>superposition</i>.<span class="Apple-converted-space">  </span>I argue<a id="fnlink7"></a><a href="#fn7"><sup>[7]</sup></a> that current software practices and languages inhibit <i>superposition</i>.</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Architecture PLs</b></h2>
<p class="p2">parts of UML</p>
<p class="p2">(list incomplete and changing over time)</p>
<p class="p3"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Tools of Architecture</b></h2>
<ul class="ul1">
  <li class="li7">RY (as opposed to DRY)<a id="fnlink8"></a><a href="#fn8"><sup>[8]</sup></a></li>
  <li class="li7">reuse of Architecture (as opposed to reuse of code)</li>
  <li class="li7">little languages<a id="fnlink9"></a><a href="#fn9"><sup>[9]</sup></a></li>
  <li class="li7">etc.</li>
  <li class="li8"><br></li>
</ul>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Engineering</b></h2>
<p class="p2">Engineering is not coding.</p>
<p class="p3"><br></p>
<p class="p2">Engineering is Applied Research.<span class="Apple-converted-space">  </span>Best-of-breed research applied to manifesting an architecture - a specific solution to a specific problem, as sketched by a Software Architect.</p>
<p class="p3"><br></p>
<p class="p2">Engineering is about filling in details left open during Architecture and making trade-offs to derive a workable final result.</p>
<p class="p3"><br></p>
<p class="p2">Engineering is specialization, not generalization.</p>
<p class="p3"><br></p>
<p class="p2">Engineering is about making trade-offs, using the best (most usable) bits of research to create specific applications.</p>
<p class="p3"><br></p>
<p class="p2">Engineering is about making cost-effective trade-offs.<span class="Apple-converted-space">  </span>[<i>What does cost-effective mean?<span class="Apple-converted-space">  </span>It depends on the specific problem / the specific customer.</i>]</p>
<p class="p3"><br></p>
<p class="p2">Engineering can be further broken down into sub-categories, for example:</p>
<ul class="ul1">
  <li class="li7">testing</li>
  <li class="li7">optimization [<i>What is being optimized?<span class="Apple-converted-space">  </span>Memory, CPU, UX, etc.?</i>]</li>
  <li class="li7">maintenance</li>
  <li class="li7">UX</li>
  <li class="li7">etc.</li>
</ul>
<p class="p3"><br></p>
<p class="p2">There is research<a id="fnlink10"></a><a href="#fn10"><sup>[10]</sup></a> that applies to Engineering, for example:</p>
<ul class="ul1">
  <li class="li7">debuggers</li>
  <li class="li7">restarts</li>
  <li class="li7">packaging, package managers</li>
  <li class="li7">optimization</li>
  <li class="li7">language features - what to keep, what to throw out</li>
  <li class="li7">better editors</li>
  <li class="li7">macro processing</li>
  <li class="li7">IDEs</li>
  <li class="li7">programming techniques, such as Structured Programming, OO, FP, etc.</li>
  <li class="li7">programming abstractions</li>
  <li class="li7">DSLs (programming abstractions)</li>
  <li class="li7">solution-centric<a id="fnlink11"></a><a href="#fn11"><sup>[11]</sup></a> abstractions</li>
  <li class="li7">testing strategies</li>
  <li class="li7">etc.</li>
</ul>
<p class="p3"><br></p>
<p class="p2">Compiling (vs. modeling) should the domain of Software Engineering.<span class="Apple-converted-space">  </span>Currently, <i>compiling</i> means creating <i>implementation</i> instead of doing Engineering.</p>
<p class="p3"><br></p>
<p class="p2"><i>Statecharts (UML2.0) </i>is a kind of Software Engineering language (there could be many more tools in this domain).</p>
<p class="p3"><br></p>
<p class="p2"><i>Drakon </i>might be another kind of Software Engineering language.</p>
<p class="p3"><br></p>
<p class="p2">DRY<a id="fnlink12"></a><a href="#fn12"><sup>[12]</sup></a> and OO are the domain of Maintenance Engineering.</p>
<p class="p3"><br></p>
<p class="p2"><i>Blueprints</i> are the domain of Structural Engineering.<span class="Apple-converted-space">  </span>There are few <i>blueprint</i> technologies for Software Engineering.</p>
<p class="p3"><br></p>
<p class="p9">Fig. 2 shows a rough diagram of design iterations that occur during Engineering.<a id="fnlink13"></a><a href="#fn13"><span class="s2"><sup>[13]</sup></span></a></p>
<p class="p3"><br></p>
<p class="p2"><img src="/assets/2021-01-19-15-05-14-Images/Nesting2.png" width="400px" height="302px" alt="Image"></p>
<p class="p5">Fig. 2 Engineering Iterations</p>
<p class="p8"><br></p>
<p class="p7">Optimization Engineering is also known as Production Engineering.</p>
<p class="p8"><br></p>
<p class="p7">Tools of Software Engineering include:</p>
<ul class="ul1">
  <li class="li7">little languages</li>
  <li class="li7">RY</li>
  <li class="li7">StateCharts</li>
  <li class="li7">m4</li>
  <li class="li7">pipelines</li>
  <li class="li7">PEG (Ohm-js, ESRAP, etc.)</li>
  <li class="li7">etc.</li>
  <li class="li8"><br></li>
</ul>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Engineering PLs</b></h2>
<p class="p2">StateCharts</p>
<p class="p2">parts of UML</p>
<p class="p2">Drakon</p>
<p class="p2">(list incomplete and changing over time)</p>
<p class="p3"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Implementation</b></h2>
<p class="p2">Implementation <i>is </i>coding.</p>
<p class="p3"><br></p>
<p class="p2">Implementors should code at the speed of touch-typing.<span class="Apple-converted-space">  </span>If they stop to think, then they are delving into Engineering and/or Architecture.</p>
<p class="p3"><br></p>
<p class="p2">Implementation can be further sub-divided.<span class="Apple-converted-space">  </span>For example:</p>
<p class="p3"><br></p>
<ul class="ul1">
  <li class="li7">test</li>
  <li class="li7">CI/CD</li>
  <li class="li7">Q/A</li>
  <li class="li7">alpha/beta coding</li>
  <li class="li7">production coding</li>
  <li class="li7">etc.</li>
  <li class="li8"><br></li>
</ul>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Implementation PLs</b></h2>
<p class="p2">PLs are <i>second sourced</i> if more than one implementation of the PL is available from different vendors.</p>
<p class="p3"><br></p>
<p class="p2">PLs that have standards allow one to switch between implementations easily.</p>
<p class="p3"><br></p>
<p class="p2">Such PLs include:</p>
<p class="p3"><br></p>
<p class="p2">C</p>
<p class="p2">Common Lisp</p>
<p class="p2">FORTRAN</p>
<p class="p2">ECMAscript</p>
<p class="p2">HTML</p>
<p class="p3"><br></p>
<p class="p2">Most other PLs are single-sourced, e.g.</p>
<p class="p2">Perl</p>
<p class="p2">Python</p>
<p class="p2">Rust</p>
<p class="p3"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Testing PLs / Tools</b></h2>
<p class="p2">CI tools</p>
<p class="p3"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Q/A Testing / Tools</b></h2>
<p class="p2">(list incomplete)</p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>Frameworks</b></h2>
<p class="p2">Rails</p>
<p class="p2">Query</p>
<p class="p2">no-code</p>
<p class="p2">(list incomplete and changing over time)</p>
<p class="p3"><br></p>
<h2 style="margin: 24.0px 0.0px 12.0px 0.0px; font: 20.0px Helvetica"><b>See also</b></h2>
<p class="p2">Mathematic is not reality</p>
<p class="p2"><a href="https://guitarvydas.github.io/2020/12/09/Mathematics-Is-Not-Reality.html">https://guitarvydas.github.io/2020/12/09/Mathematics-Is-Not-Reality.html</a></p>
<p class="p3"><br></p>
<p class="p2">Software development roles</p>
<p class="p2"><a href="https://guitarvydas.github.io/2020/12/10/Software-Development-Roles.html">https://guitarvydas.github.io/2020/12/10/Software-Development-Roles.html</a></p>
<p class="p3"><br></p>
<p class="p2">Pure Research vs. Applied Research</p>
<p class="p2"><a href="https://guitarvydas.github.io/2021/01/14/Pure-Research-vs-Applied-Research.html">https://guitarvydas.github.io/2021/01/14/Pure-Research-vs-Applied-Research.html</a></p>
<p class="p3"><br></p>
<p class="p2">New-Breed HLLs</p>
<p class="p2"><a href="https://guitarvydas.github.io/2020/12/09/New-Breed-HLLs.html">https://guitarvydas.github.io/2020/12/09/New-Breed-HLLs.html</a></p>
<p class="p10"><br></p>
<hr>
<p class="p5"><a id="fn1"></a><a href="#fnlink1"><span class="s2">[1]</span></a><span class="s2"> </span>Looking at other disciplines is "reuse".</p>
<p class="p5"><a id="fn2"></a><a href="#fnlink2"><span class="s2">[2]</span></a><span class="s2"> </span>Research into how to constrain GOTOs is the realm of Research into Applied Research.</p>
<p class="p5"><a id="fn3"></a><a href="#fnlink3"><span class="s2">[3]</span></a><span class="s2"> </span>CPS means Continuation Passing Style.</p>
<p class="p5"><a id="fn4"></a><a href="#fnlink4"><span class="s2">[4]</span></a><span class="s2"> </span>Is this correct?<span class="Apple-converted-space">  </span>Is Haskell a research language or is it a production language?</p>
<p class="p11"><a id="fn5"></a><a href="#fnlink5"><span class="s2">[5]</span></a><span class="s2"> </span>Imagine <i>git</i> for Architecture instead of code.<span class="Apple-converted-space">  </span>DRY detection and resolution should be automated.</p>
<p class="p11"><a id="fn6"></a><a href="#fnlink6"><span class="s2">[6]</span></a><span class="s2"> </span>I call little languages SCLs, meaning solution-specific languages.<span class="Apple-converted-space">  </span>SCLs are like DSLs, but more focussed.</p>
<p class="p11"><a id="fn7"></a><a href="#fnlink7"><span class="s2">[7]</span></a><span class="s2"> </span>See https://guitarvydas.github.io/2020/12/25/The-ALGOL-Bottleneck.html and https://guitarvydas.github.io/2020/12/09/CALL-RETURN-Spaghetti.html.</p>
<p class="p11"><a id="fn8"></a><a href="#fnlink8"><span class="s2">[8]</span></a><span class="s2"> </span>Imagine <i>git</i> for Architecture instead of code.<span class="Apple-converted-space">  </span>DRY detection and resolution should be automated.</p>
<p class="p11"><a id="fn9"></a><a href="#fnlink9"><span class="s2">[9]</span></a><span class="s2"> </span>I call little languages SCLs, meaning solution-specific languages.<span class="Apple-converted-space">  </span>SCLs are like DSLs, but more focussed.</p>
<p class="p11"><a id="fn10"></a><a href="#fnlink10"><span class="s2">[10]</span></a><span class="s2"> </span>This suggests further sub-divisions of Pure Research in the above diagram.</p>
<p class="p11"><a id="fn11"></a><a href="#fnlink11"><span class="s2">[11]</span></a><span class="s2"> </span>Solution-centric abstractions are more focussed than domain level abstractions.<span class="Apple-converted-space">  </span>I used the abbreviation SCL instead of DSL (solution-centric languages vs. domain specific languages)</p>
<p class="p11"><a id="fn12"></a><a href="#fnlink12"><span class="s2">[12]</span></a><span class="s2"> </span>DRY means Don't Repeat Yourself.</p>
<p class="p5"><a id="fn13"></a><a href="#fnlink13"><span class="s2">[13]</span></a><span class="s2"> </span>I was schooled in EE and am biased towards Engineering, hence, my diagram shows more detail in the Engineering phases.<span class="Apple-converted-space">  </span>The diagram should be extended to show phases in other categories and to show further sub-divisions of Engineering.<span class="Apple-converted-space">  </span>This is not a final diagram.</p>
</div>
</body>
</html>
