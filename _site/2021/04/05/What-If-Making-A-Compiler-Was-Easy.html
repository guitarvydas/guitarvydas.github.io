<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
	<meta charset="utf-8"/>
	<title>What If Compilers Were Easy?</title>
	<meta name="author" content=""/>
</head>
<body>

<h1 id="whatif">What If?</h1>

<p>What if it was easy to create compilers and languages?</p>

<p>Say, 10 minutes instead of several years?</p>

<p>How would your approach to programming change?</p>

<p>Does your favourite programming language have REGEX built in? Or, does it have a REGEX library?</p>

<p>What if writing a new language, a new DSL, were as easy as writing a REGEX?</p>

<h1 id="paradigmsnotlanguages">Paradigms, Not Languages</h1>

<p>Paradigms, e.g. OO, FP, message-passing, etc. would still be important.</p>

<p>Languages and syntax would no longer be important, if you could build languages as easily as writing REGEXs.</p>

<p>You could easily wrap a language around <em>any</em> given paradigm.</p>

<p>If you didn&#8217;t like a particular language, you would throw it away and build a new one to suit your needs (10 minutes, not years) .</p>

<h1 id="alanguageforeveryproblem">A Language for Every Problem</h1>

<p>If languages were cheap to build, you could build a new language every time you started a project.</p>

<p>This would be different, even, from creating DSLs.</p>

<p>Normally, we think of DSLs as being tied to particular technologies, like SQL is a DSL for database queries.</p>

<p>Instead, we could just invent a new DSL for <em>every</em> project. For example, if we used a database for Project XYZ, we could have an XYZ-DSL for the project. It would generate SQL queries based on what the Project XYZ needed.</p>

<p>XYZ-DSL would not be general. It would be specific <em>only</em> to project XYZ.</p>

<p>We <em>already</em> do that, when we build code in a programming language.</p>

<p>We don&#8217;t separate the code details from the architectural needs of the project.</p>

<p>We find a language, or a DSL, which is sufficiently general to handle most of the aspects of our problem (XYZ in this case).</p>

<p>Then we write code in that language until we solve the XYZ problem. We make problem XYZ <em>fit</em> the chosen language.</p>

<p>Sometimes, we don&#8217;t need all to use all of the fancy features of a language.</p>

<p>Sometimes, the details (is this a list?, is this an array?, is this an int?, is this a double?, etc.) obscure the real meat of the solution.</p>

<h1 id="regex">REGEX</h1>

<p>REGEX is a simple DSL.</p>

<p>REGEX was, originally, compiler technology.</p>

<p>Today, it is possible for non-specialists to use REGEX.</p>

<p>What can REGEX do?</p>

<ul>
<li>It can match strings.</li>
</ul>

<p>What can&#8217;t REGEX do?</p>

<ul>
<li>It can&#8217;t match nested strings.</li>
<li>It can&#8217;t match across lines.</li>
<li>REGEX is not recursive. It can&#8217;t call itself.</li>
</ul>

<p>Is there something that can do what REGEX can do <em>and</em> what REGEX can&#8217;t do?</p>

<p>Yes.</p>

<p>PEG.<a href="#fn:1" id="fnref:1" title="see footnote" class="footnote"><sup>1</sup></a></p>

<p>Is PEG built into other languages?</p>

<ul>
<li>No, not yet.<a href="#fn:2" id="fnref:2" title="see footnote" class="footnote"><sup>2</sup></a></li>
</ul>

<h1 id="scls">SCLs</h1>

<p>I call such languages SCLs &#8212; for <em>Solution Centric Languages</em>.</p>

<div class="footnotes">
<hr />
<ol>

<li id="fn:1">
<p>Actually, other parser technologies like ANTRL do this. PEG feels more &#8220;light weight&#8221; to me. <a href="#fnref:1" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

<li id="fn:2">
<p>There is &#8220;#lang peg&#8221; in Racket and a myriad of PEG libraries for many languages. PEG is usually added as an afterthought. For example, if Racket really, really used PEG, it wouldn't need macros. <a href="#fnref:2" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

</ol>
</div>

<script src="https://utteranc.es/client.js" 
        repo="guitarvydas/guitarvydas.github.io" 
        issue-term="pathname" 
        theme="github-light" 
        crossorigin="anonymous" 
        async> 
</script> 
</body>
</html>

